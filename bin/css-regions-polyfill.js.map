{"version":3,"sources":["..\\src\\core\\polyfill-dom-console.js","..\\src\\core\\dom-events.js","..\\src\\core\\css-syntax.js","..\\src\\core\\polyfill-dom-requestAnimationFrame.js","..\\src\\core\\dom-experimental-event-streams.js","..\\src\\core\\dom-query-selector-live.js","..\\src\\core\\css-cascade.js","..\\src\\core\\css-break.js","..\\src\\css-regions\\lib\\range-extensions.js","..\\src\\css-regions\\lib\\helpers.js","..\\src\\css-regions\\lib\\objectmodel.js","..\\src\\css-regions\\polyfill.js","..\\src\\requirements.js"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mD;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;ACxzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iE;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6D;;;;ACnXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sD;;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;AC5yBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;AC9aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0D;;;;ACjgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iD;;;;AC3mBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qD;;;;AChoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8C;;;;AC3+BA;AACA;AACA;AACA;AACA,sC","file":"css-regions-polyfill.js","sourcesContent":["!(function(window, document) { \"use strict\";\r\n\r\n\t//\r\n\t// some code for console polyfilling\r\n\t//\r\n\tif(!window.console) {\r\n\t\t\t\r\n\t\twindow.console = {\r\n\t\t\tbacklog: '',\r\n\t\t\t\r\n\t\t\tlog: function(x) { this.backlog+=x+'\\n'; if(window.debug) alert(x); },\r\n\t\t\t\r\n\t\t\tdir: function(x) { try { \r\n\t\t\t\t\r\n\t\t\t\tvar elm = function(e) {\r\n\t\t\t\t\tif(e.innerHTML) {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\ttagName: e.tagName,\r\n\t\t\t\t\t\t\tclassName: e.className,\r\n\t\t\t\t\t\t\tid: e.id,\r\n\t\t\t\t\t\t\tinnerHTML: e.innerHTML.substr(0,100)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tnodeName: e.nodeName,\r\n\t\t\t\t\t\t\tnodeValue: e.nodeValue\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\t\r\n\t\t\t\tvar jsonify = function(o) {\r\n\t\t\t\t\tvar seen=[];\r\n\t\t\t\t\tvar jso=JSON.stringify(o, function(k,v){\r\n\t\t\t\t\t\tif (typeof v =='object') {\r\n\t\t\t\t\t\t\tif ( !seen.indexOf(v) ) { return '__cycle__'; }\r\n\t\t\t\t\t\t\tif ( v instanceof window.Node) { return elm(v); }\r\n\t\t\t\t\t\t\tseen.push(v);\r\n\t\t\t\t\t\t} return v;\r\n\t\t\t\t\t});\r\n\t\t\t\t\treturn jso;\r\n\t\t\t\t};\r\n\t\t\t\t\r\n\t\t\t\tthis.log(jsonify(x)); \r\n\t\t\t\t\r\n\t\t\t} catch(ex) { this.log(x) } },\r\n\t\t\t\r\n\t\t\twarn: function(x) { this.log(x) },\r\n\t\t\t\r\n\t\t\terror: function(x) { this.log(\"ERROR:\"); this.log(x); }\r\n\t\t\t\r\n\t\t};\r\n\t\t\r\n\t\tif(!window.onerror) {\r\n\t\t\twindow.onerror = function() {\r\n\t\t\t\tconsole.log([].slice.call(arguments,0).join(\"\\n\"))\r\n\t\t\t};\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n\t//\r\n\t// this special console is used as a proxy emulating the CSS console of browsers\r\n\t//\r\n\twindow.cssConsole = {\r\n\t\tenabled: (!!window.debug), warnEnabled: (true),\r\n\t\tlog: function(x) { if(this.enabled) console.log(x) },\r\n\t\tdir: function(x) { if(this.enabled) console.dir(x) },\r\n\t\twarn: function(x) { if(this.warnEnabled) console.warn(x) },\r\n\t\terror: function(x) { console.error(x); }\r\n\t}\r\n\r\n})(window, document);\nrequire.define('src/core/polyfill-dom-console.js');","module.exports = (function(window, document) { \"use strict\";\r\n\r\n\trequire('src/core/polyfill-dom-console.js');\r\n\r\n\t//\r\n\t// some other basic om code\r\n\t//\r\n\tvar domEvents = {\r\n\t\t\r\n\t\t//\r\n\t\t// the following functions are about event cloning\r\n\t\t//\r\n\t\tcloneMouseEvent: function cloneMouseEvent(e) {\r\n\t\t\tvar evt = document.createEvent(\"MouseEvent\");\r\n\t\t\tevt.initMouseEvent( \r\n\t\t\t\te.type, \r\n\t\t\t\te.canBubble||e.bubbles, \r\n\t\t\t\te.cancelable, \r\n\t\t\t\te.view, \r\n\t\t\t\te.detail, \r\n\t\t\t\te.screenX, \r\n\t\t\t\te.screenY, \r\n\t\t\t\te.clientX, \r\n\t\t\t\te.clientY, \r\n\t\t\t\te.ctrlKey, \r\n\t\t\t\te.altKey, \r\n\t\t\t\te.shiftKey, \r\n\t\t\t\te.metaKey, \r\n\t\t\t\te.button, \r\n\t\t\t\te.relatedTarget\r\n\t\t\t);\r\n\t\t\treturn evt;\r\n\t\t},\r\n\t\t\r\n\t\tcloneKeyboardEvent: function cloneKeyboardEvent(e) {\r\n\t\t\t// TODO: this doesn't work cross-browser...\r\n\t\t\t// see https://gist.github.com/termi/4654819/ for the huge code\r\n\t\t\treturn domEvents.cloneCustomEvent(e);\r\n\t\t},\r\n\t\t\r\n\t\tcloneCustomEvent: function cloneCustomEvent(e) {\r\n\t\t\tvar ne = document.createEvent(\"CustomEvent\");\r\n\t\t\tne.initCustomEvent(e.type, e.canBubble||e.bubbles, e.cancelable, \"detail\" in e ? e.detail : e);\r\n\t\t\tfor(var prop in e) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif(e[prop] != ne[prop] && e[prop] != e.target) {\r\n\t\t\t\t\t\ttry { ne[prop] = e[prop]; }\r\n\t\t\t\t\t\tcatch (ex) { Object.defineProperty(ne,prop,{get:function() { return e[prop]} }) }\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch(ex) {}\r\n\t\t\t}\r\n\t\t\treturn ne;\r\n\t\t},\r\n\t\t\r\n\t\tcloneEvent: function cloneEvent(e) {\r\n\t\t\t\r\n\t\t\tif(e instanceof MouseEvent) {\r\n\t\t\t\treturn domEvents.cloneMouseEvent(e);\r\n\t\t\t} else if(e instanceof KeyboardEvent) {\r\n\t\t\t\treturn domEvents.cloneKeyboardEvent(e);\r\n\t\t\t} else {\r\n\t\t\t\treturn domEvents.cloneCustomEvent(e);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// allows you to drop event support to any class easily\r\n\t\t//\r\n\t\tEventTarget: {\r\n\t\t\timplementsIn: function(eventClass, static_class) {\r\n\t\t\t\t\r\n\t\t\t\tif(!static_class && typeof(eventClass)==\"function\") eventClass=eventClass.prototype;\r\n\t\t\t\t\r\n\t\t\t\teventClass.dispatchEvent = domEvents.EventTarget.prototype.dispatchEvent;\r\n\t\t\t\teventClass.addEventListener = domEvents.EventTarget.prototype.addEventListener;\r\n\t\t\t\teventClass.removeEventListener = domEvents.EventTarget.prototype.removeEventListener;\r\n\t\t\t\t\r\n\t\t\t},\r\n\t\t\tprototype: {}\r\n\t\t}\r\n\t\t\r\n\t};\r\n\r\n\tdomEvents.EventTarget.prototype.addEventListener = function(eventType,f) {\r\n\t\tif(!this.eventListeners) this.eventListeners=[];\r\n\t\t\r\n\t\tvar ls = (this.eventListeners[eventType] || (this.eventListeners[eventType]=[]));\r\n\t\tif(ls.indexOf(f)==-1) {\r\n\t\t\tls.push(f);\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n\tdomEvents.EventTarget.prototype.removeEventListener = function(eventType,f) {\r\n\t\tif(!this.eventListeners) this.eventListeners=[];\r\n\r\n\t\tvar ls = (this.eventListeners[eventType] || (this.eventListeners[eventType]=[])), i;\r\n\t\tif((i=ls.indexOf(f))!==-1) {\r\n\t\t\tls.splice(i,1);\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n\tdomEvents.EventTarget.prototype.dispatchEvent = function(event_or_type) {\r\n\t\tif(!this.eventListeners) this.eventListeners=[];\r\n\t\t\r\n\t\t// abort quickly when no listener has been set up\r\n\t\tif(typeof(event_or_type) == \"string\") {\r\n\t\t\tif(!this.eventListeners[event_or_type] || this.eventListeners[event_or_type].length==0) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif(!this.eventListeners[event_or_type.type] || this.eventListeners[event_or_type.type].length==0) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// convert the event\r\n\t\tvar event = event_or_type;\r\n\t\tfunction setUpPropertyForwarding(e,ee,key) {\r\n\t\t\tObject.defineProperty(ee,key,{\r\n\t\t\t\tget:function() {\r\n\t\t\t\t\tvar v = e[key]; \r\n\t\t\t\t\tif(typeof(v)==\"function\") {\r\n\t\t\t\t\t\treturn v.bind(e);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\treturn v;\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tset:function(v) {\r\n\t\t\t\t\te[key] = v;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\tfunction setUpTarget(e,v) {\r\n\t\t\ttry { Object.defineProperty(e,\"target\",{get:function() {return v}}); }\r\n\t\t\tcatch(ex) {}\r\n\t\t\tfinally {\r\n\t\t\t\t\r\n\t\t\t\tif(e.target !== v) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar ee = Object.create(Object.getPrototypeOf(e));\r\n\t\t\t\t\tee = setUpTarget(ee,v);\r\n\t\t\t\t\tfor(var key in e) {\r\n\t\t\t\t\t\tif(key != \"target\") setUpPropertyForwarding(e,ee,key);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn ee;\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\treturn e;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// try to set the target\r\n\t\tif(typeof(event)==\"object\") {\r\n\t\t\ttry { event=setUpTarget(event,this); } catch(ex) {}\r\n\t\t\t\r\n\t\t} else if(typeof(event)==\"string\") {\r\n\t\t\tevent = document.createEvent(\"CustomEvent\");\r\n\t\t\tevent.initCustomEvent(event_or_type, /*canBubble:*/ true, /*cancelable:*/ false, /*detail:*/this);\r\n\t\t\ttry { event=setUpTarget(event,this); } catch(ex) {}\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"dispatchEvent expect an Event object or a string containing the event type\");\r\n\t\t}\r\n\t\t\r\n\t\t// call all listeners\r\n\t\tvar ls = (this.eventListeners[event.type] || (this.eventListeners[event.type]=[]));\r\n\t\tfor(var i=ls.length; i--;) {\r\n\t\t\ttry { \r\n\t\t\t\tls[i](event);\r\n\t\t\t} catch(ex) {\r\n\t\t\t\tsetImmediate(function() { throw ex; });\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn event.isDefaultPrevented;\r\n\t}\r\n\t\r\n\treturn domEvents;\r\n\t\r\n})(window, document);\r\n\nrequire.define('src/core/dom-events.js');","//\r\n// note: this file is based on Tab Atkins's CSS Parser\r\n// please include him (@tabatkins) if you open any issue for this file\r\n// \r\nmodule.exports = (function(window, document) { \"use strict\";\r\n\r\n// \r\n// exports\r\n//\r\nvar cssSyntax = { \r\n\ttokenize: function(string) {/*filled later*/}, \r\n\tparse: function(tokens) {/*filled later*/}\r\n};\r\n\r\n//\r\n// css tokenizer\r\n//\r\n\r\n// Add support for token lists (superclass of array)\r\nfunction TokenList() {\r\n\tvar array = []; \r\n\tarray.toCSSString=TokenListToCSSString;\r\n\treturn array;\r\n}\r\nfunction TokenListToCSSString(sep) {\r\n\tif(sep) {\r\n\t\treturn this.map(function(o) { return o.toCSSString(); }).join(sep);\r\n\t} else {\r\n\t\treturn this.asCSSString || (this.asCSSString = (\r\n\t\t\tthis.map(function(o) { return o.toCSSString(); }).join(\"/**/\")\r\n\t\t\t\t.replace(/( +\\/\\*\\*\\/ *| * | *\\/\\*\\*\\/ +)/g,\" \")\r\n\t\t\t\t.replace(/( +\\/\\*\\*\\/ *| * | *\\/\\*\\*\\/ +)/g,\" \")\r\n\t\t\t\t.replace(/(\\!|\\:|\\;|\\@|\\.|\\,|\\*|\\=|\\&|\\\\|\\/|\\<|\\>|\\[|\\{|\\(|\\]|\\}|\\)|\\|)\\/\\*\\*\\//g,\"$1\")\r\n\t\t\t\t.replace(/\\/\\*\\*\\/(\\!|\\:|\\;|\\@|\\.|\\,|\\*|\\=|\\&|\\\\|\\/|\\<|\\>|\\[|\\{|\\(|\\]|\\}|\\)|\\|)/g,\"$1\")\r\n\t\t));\r\n\t}\r\n}\r\ncssSyntax.TokenList = TokenList;\r\ncssSyntax.TokenListToCSSString = TokenListToCSSString;\r\n\r\nfunction between(num, first, last) { return num >= first && num <= last; }\r\nfunction digit(code) { return between(code, 0x30,0x39); }\r\nfunction hexdigit(code) { return digit(code) || between(code, 0x41,0x46) || between(code, 0x61,0x66); }\r\nfunction uppercaseletter(code) { return between(code, 0x41,0x5a); }\r\nfunction lowercaseletter(code) { return between(code, 0x61,0x7a); }\r\nfunction letter(code) { return uppercaseletter(code) || lowercaseletter(code); }\r\nfunction nonascii(code) { return code >= 0x80; }\r\nfunction namestartchar(code) { return letter(code) || nonascii(code) || code == 0x5f; }\r\nfunction namechar(code) { return namestartchar(code) || digit(code) || code == 0x2d; }\r\nfunction nonprintable(code) { return between(code, 0,8) || code == 0xb || between(code, 0xe,0x1f) || code == 0x7f; }\r\nfunction newline(code) { return code == 0xa; }\r\nfunction whitespace(code) { return newline(code) || code == 9 || code == 0x20; }\r\nfunction badescape(code) { return newline(code) || isNaN(code); }\r\n\r\nvar maximumallowedcodepoint = 0x10ffff;\r\n\r\nfunction InvalidCharacterError(message) {\r\n\tthis.message = message;\r\n};\r\nInvalidCharacterError.prototype = new Error;\r\nInvalidCharacterError.prototype.name = 'InvalidCharacterError';\r\n\r\nfunction preprocess(str) {\r\n\t// Turn a string into an array of code points,\r\n\t// following the preprocessing cleanup rules.\r\n\tvar codepoints = [];\r\n\tfor(var i = 0; i < str.length; i++) {\r\n\t\tvar code = str.charCodeAt(i);\r\n\t\tif(code == 0xd && str.charCodeAt(i+1) == 0xa) {\r\n\t\t\tcode = 0xa; i++;\r\n\t\t}\r\n\t\tif(code == 0xd || code == 0xc) code = 0xa;\r\n\t\tif(code == 0x0) code = 0xfffd;\r\n\t\tif(between(code, 0xd800, 0xdbff) && between(str.charCodeAt(i+1), 0xdc00, 0xdfff)) {\r\n\t\t\t// Decode a surrogate pair into an astral codepoint.\r\n\t\t\tvar lead = code - 0xd800;\r\n\t\t\tvar trail = str.charCodeAt(i+1) - 0xdc00;\r\n\t\t\tcode = Math.pow(2, 21) + lead * Math.pow(2, 10) + trail;\r\n\t\t}\r\n\t\tcodepoints.push(code);\r\n\t}\r\n\treturn codepoints;\r\n}\r\n\r\nfunction stringFromCode(code) {\r\n\tif(code <= 0xffff) return String.fromCharCode(code);\r\n\t// Otherwise, encode astral char as surrogate pair.\r\n\tcode -= Math.pow(2, 21);\r\n\tvar lead = Math.floor(code/Math.pow(2, 10)) + 0xd800;\r\n\tvar trail = code % Math.pow(2, 10); + 0xdc00;\r\n\treturn String.fromCharCode(lead) + String.fromCharCode(trail);\r\n}\r\n\r\nfunction tokenize(str) {\r\n\tstr = preprocess(str);\r\n\tvar i = -1;\r\n\tvar tokens = new TokenList();\r\n\tvar code;\r\n\r\n\t// Line number information.\r\n\tvar line = 0;\r\n\tvar column = 0;\r\n\t// The only use of lastLineLength is in reconsume().\r\n\tvar lastLineLength = 0;\r\n\tvar incrLineno = function() {\r\n\t\tline += 1;\r\n\t\tlastLineLength = column;\r\n\t\tcolumn = 0;\r\n\t};\r\n\tvar locStart = {line:line, column:column};\r\n\r\n\tvar codepoint = function(i) {\r\n\t\tif(i >= str.length) {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\treturn str[i];\r\n\t}\r\n\tvar next = function(num) {\r\n\t\tif(num === undefined) { num = 1; }\r\n\t\tif(num > 3) { throw \"Spec Error: no more than three codepoints of lookahead.\"; }\r\n\t\treturn codepoint(i+num);\r\n\t};\r\n\tvar consume = function(num) {\r\n\t\tif(num === undefined)\r\n\t\t\tnum = 1;\r\n\t\ti += num;\r\n\t\tcode = codepoint(i);\r\n\t\tif(newline(code)) incrLineno();\r\n\t\telse column += num;\r\n\t\t//console.log('Consume '+i+' '+String.fromCharCode(code) + ' 0x' + code.toString(16));\r\n\t\treturn true;\r\n\t};\r\n\tvar reconsume = function() {\r\n\t\ti -= 1;\r\n\t\tif (newline(code)) {\r\n\t\t\tline -= 1;\r\n\t\t\tcolumn = lastLineLength;\r\n\t\t} else {\r\n\t\t\tcolumn -= 1;\r\n\t\t}\r\n\t\tlocStart.line = line;\r\n\t\tlocStart.column = column;\r\n\t\treturn true;\r\n\t};\r\n\tvar eof = function(codepoint) {\r\n\t\tif(codepoint === undefined) codepoint = code;\r\n\t\treturn codepoint == -1;\r\n\t};\r\n\tvar donothing = function() {};\r\n\tvar tokenizeerror = function() { console.log(\"Parse error at index \" + i + \", processing codepoint 0x\" + code.toString(16) + \".\");return true; };\r\n\r\n\tvar consumeAToken = function() {\r\n\t\tconsumeComments();\r\n\t\tconsume();\r\n\t\tif(whitespace(code)) {\r\n\t\t\twhile(whitespace(next())) consume();\r\n\t\t\treturn new WhitespaceToken;\r\n\t\t}\r\n\t\telse if(code == 0x22) return consumeAStringToken();\r\n\t\telse if(code == 0x23) {\r\n\t\t\tif(namechar(next()) || areAValidEscape(next(1), next(2))) {\r\n\t\t\t\tvar token = new HashToken();\r\n\t\t\t\tif(wouldStartAnIdentifier(next(1), next(2), next(3))) token.type = \"id\";\r\n\t\t\t\ttoken.value = consumeAName();\r\n\t\t\t\treturn token;\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x24) {\r\n\t\t\tif(next() == 0x3d) {\r\n\t\t\t\tconsume();\r\n\t\t\t\treturn new SuffixMatchToken();\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x27) return consumeAStringToken();\r\n\t\telse if(code == 0x28) return new OpenParenToken();\r\n\t\telse if(code == 0x29) return new CloseParenToken();\r\n\t\telse if(code == 0x2a) {\r\n\t\t\tif(next() == 0x3d) {\r\n\t\t\t\tconsume();\r\n\t\t\t\treturn new SubstringMatchToken();\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x2b) {\r\n\t\t\tif(startsWithANumber()) {\r\n\t\t\t\treconsume();\r\n\t\t\t\treturn consumeANumericToken();\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x2c) return new CommaToken();\r\n\t\telse if(code == 0x2d) {\r\n\t\t\tif(startsWithANumber()) {\r\n\t\t\t\treconsume();\r\n\t\t\t\treturn consumeANumericToken();\r\n\t\t\t} else if(next(1) == 0x2d && next(2) == 0x3e) {\r\n\t\t\t\tconsume(2);\r\n\t\t\t\treturn new CDCToken();\r\n\t\t\t} else if(startsWithAnIdentifier()) {\r\n\t\t\t\treconsume();\r\n\t\t\t\treturn consumeAnIdentlikeToken();\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x2e) {\r\n\t\t\tif(startsWithANumber()) {\r\n\t\t\t\treconsume();\r\n\t\t\t\treturn consumeANumericToken();\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x3a) return new ColonToken;\r\n\t\telse if(code == 0x3b) return new SemicolonToken;\r\n\t\telse if(code == 0x3c) {\r\n\t\t\tif(next(1) == 0x21 && next(2) == 0x2d && next(3) == 0x2d) {\r\n\t\t\t\tconsume(3);\r\n\t\t\t\treturn new CDOToken();\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x40) {\r\n\t\t\tif(wouldStartAnIdentifier(next(1), next(2), next(3))) {\r\n\t\t\t\treturn new AtKeywordToken(consumeAName());\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x5b) return new OpenSquareToken();\r\n\t\telse if(code == 0x5c) {\r\n\t\t\tif(startsWithAValidEscape()) {\r\n\t\t\t\treconsume();\r\n\t\t\t\treturn consumeAnIdentlikeToken();\r\n\t\t\t} else {\r\n\t\t\t\ttokenizeerror();\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x5d) return new CloseSquareToken();\r\n\t\telse if(code == 0x5e) {\r\n\t\t\tif(next() == 0x3d) {\r\n\t\t\t\tconsume();\r\n\t\t\t\treturn new PrefixMatchToken();\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x7b) return new OpenCurlyToken();\r\n\t\telse if(code == 0x7c) {\r\n\t\t\tif(next() == 0x3d) {\r\n\t\t\t\tconsume();\r\n\t\t\t\treturn new DashMatchToken();\r\n\t\t\t} else if(next() == 0x7c) {\r\n\t\t\t\tconsume();\r\n\t\t\t\treturn new ColumnToken();\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(code == 0x7d) return new CloseCurlyToken();\r\n\t\telse if(code == 0x7e) {\r\n\t\t\tif(next() == 0x3d) {\r\n\t\t\t\tconsume();\r\n\t\t\t\treturn new IncludeMatchToken();\r\n\t\t\t} else {\r\n\t\t\t\treturn new DelimToken(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(digit(code)) {\r\n\t\t\treconsume();\r\n\t\t\treturn consumeANumericToken();\r\n\t\t}\r\n\t\telse if(namestartchar(code)) {\r\n\t\t\treconsume();\r\n\t\t\treturn consumeAnIdentlikeToken();\r\n\t\t}\r\n\t\telse if(eof()) return new EOFToken();\r\n\t\telse return new DelimToken(code);\r\n\t};\r\n\r\n\tvar consumeComments = function() {\r\n\t\twhile(next(1) == 0x2f && next(2) == 0x2a) {\r\n\t\t\tconsume(2);\r\n\t\t\twhile(true) {\r\n\t\t\t\tconsume();\r\n\t\t\t\tif(code == 0x2a && next() == 0x2f) {\r\n\t\t\t\t\tconsume();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t} else if(eof()) {\r\n\t\t\t\t\ttokenizeerror();\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tvar consumeANumericToken = function() {\r\n\t\tvar num = consumeANumber();\r\n\t\tif(wouldStartAnIdentifier(next(1), next(2), next(3))) {\r\n\t\t\tvar token = new DimensionToken();\r\n\t\t\ttoken.value = num.value;\r\n\t\t\ttoken.repr = num.repr;\r\n\t\t\ttoken.type = num.type;\r\n\t\t\ttoken.unit = consumeAName();\r\n\t\t\treturn token;\r\n\t\t} else if(next() == 0x25) {\r\n\t\t\tconsume();\r\n\t\t\tvar token = new PercentageToken();\r\n\t\t\ttoken.value = num.value;\r\n\t\t\ttoken.repr = num.repr;\r\n\t\t\treturn token;\r\n\t\t} else {\r\n\t\t\tvar token = new NumberToken();\r\n\t\t\ttoken.value = num.value;\r\n\t\t\ttoken.repr = num.repr;\r\n\t\t\ttoken.type = num.type;\r\n\t\t\treturn token;\r\n\t\t}\r\n\t};\r\n\r\n\tvar consumeAnIdentlikeToken = function() {\r\n\t\tvar str = consumeAName();\r\n\t\tif(str.toLowerCase() == \"url\" && next() == 0x28) {\r\n\t\t\tconsume();\r\n\t\t\twhile(whitespace(next(1)) && whitespace(next(2))) consume();\r\n\t\t\tif(next() == 0x22 || next() == 0x27) {\r\n\t\t\t\treturn new FunctionToken(str);\r\n\t\t\t} else if(whitespace(next()) && (next(2) == 0x22 || next(2) == 0x27)) {\r\n\t\t\t\treturn new FunctionToken(str);\r\n\t\t\t} else {\r\n\t\t\t\treturn consumeAURLToken();\r\n\t\t\t}\r\n\t\t} else if(next() == 0x28) {\r\n\t\t\tconsume();\r\n\t\t\treturn new FunctionToken(str);\r\n\t\t} else {\r\n\t\t\treturn new IdentifierToken(str);\r\n\t\t}\r\n\t};\r\n\r\n\tvar consumeAStringToken = function(endingCodePoint) {\r\n\t\tif(endingCodePoint === undefined) endingCodePoint = code;\r\n\t\tvar string = \"\";\r\n\t\twhile(consume()) {\r\n\t\t\tif(code == endingCodePoint || eof()) {\r\n\t\t\t\treturn new StringToken(string);\r\n\t\t\t} else if(newline(code)) {\r\n\t\t\t\ttokenizeerror();\r\n\t\t\t\treconsume();\r\n\t\t\t\treturn new BadStringToken();\r\n\t\t\t} else if(code == 0x5c) {\r\n\t\t\t\tif(eof(next())) {\r\n\t\t\t\t\tdonothing();\r\n\t\t\t\t} else if(newline(next())) {\r\n\t\t\t\t\tconsume();\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstring += stringFromCode(consumeEscape())\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tstring += stringFromCode(code);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tvar consumeAURLToken = function() {\r\n\t\tvar token = new URLToken(\"\");\r\n\t\twhile(whitespace(next())) consume();\r\n\t\tif(eof(next())) return token;\r\n\t\twhile(consume()) {\r\n\t\t\tif(code == 0x29 || eof()) {\r\n\t\t\t\treturn token;\r\n\t\t\t} else if(whitespace(code)) {\r\n\t\t\t\twhile(whitespace(next())) consume();\r\n\t\t\t\tif(next() == 0x29 || eof(next())) {\r\n\t\t\t\t\tconsume();\r\n\t\t\t\t\treturn token;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconsumeTheRemnantsOfABadURL();\r\n\t\t\t\t\treturn new BadURLToken();\r\n\t\t\t\t}\r\n\t\t\t} else if(code == 0x22 || code == 0x27 || code == 0x28 || nonprintable(code)) {\r\n\t\t\t\ttokenizeerror();\r\n\t\t\t\tconsumeTheRemnantsOfABadURL();\r\n\t\t\t\treturn new BadURLToken();\r\n\t\t\t} else if(code == 0x5c) {\r\n\t\t\t\tif(startsWithAValidEscape()) {\r\n\t\t\t\t\ttoken.value += stringFromCode(consumeEscape());\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttokenizeerror();\r\n\t\t\t\t\tconsumeTheRemnantsOfABadURL();\r\n\t\t\t\t\treturn new BadURLToken();\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\ttoken.value += stringFromCode(code);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tvar consumeEscape = function() {\r\n\t\t// Assume the the current character is the \\\r\n\t\t// and the next code point is not a newline.\r\n\t\tconsume();\r\n\t\tif(hexdigit(code)) {\r\n\t\t\t// Consume 1-6 hex digits\r\n\t\t\tvar digits = [code];\r\n\t\t\tfor(var total = 0; total < 5; total++) {\r\n\t\t\t\tif(hexdigit(next())) {\r\n\t\t\t\t\tconsume();\r\n\t\t\t\t\tdigits.push(code);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(whitespace(next())) consume();\r\n\t\t\tvar value = parseInt(digits.map(function(x){return String.fromCharCode(x);}).join(''), 16);\r\n\t\t\tif( value > maximumallowedcodepoint ) value = 0xfffd;\r\n\t\t\treturn value;\r\n\t\t} else if(eof()) {\r\n\t\t\treturn 0xfffd;\r\n\t\t} else {\r\n\t\t\treturn code;\r\n\t\t}\r\n\t};\r\n\r\n\tvar areAValidEscape = function(c1, c2) {\r\n\t\tif(c1 != 0x5c) return false;\r\n\t\tif(newline(c2)) return false;\r\n\t\treturn true;\r\n\t};\r\n\tvar startsWithAValidEscape = function() {\r\n\t\treturn areAValidEscape(code, next());\r\n\t};\r\n\r\n\tvar wouldStartAnIdentifier = function(c1, c2, c3) {\r\n\t\tif(c1 == 0x2d) {\r\n\t\t\treturn namestartchar(c2) || c2 == 0x2d || areAValidEscape(c2, c3);\r\n\t\t} else if(namestartchar(c1)) {\r\n\t\t\treturn true;\r\n\t\t} else if(c1 == 0x5c) {\r\n\t\t\treturn areAValidEscape(c1, c2);\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n\tvar startsWithAnIdentifier = function() {\r\n\t\treturn wouldStartAnIdentifier(code, next(1), next(2));\r\n\t};\r\n\r\n\tvar wouldStartANumber = function(c1, c2, c3) {\r\n\t\tif(c1 == 0x2b || c1 == 0x2d) {\r\n\t\t\tif(digit(c2)) return true;\r\n\t\t\tif(c2 == 0x2e && digit(c3)) return true;\r\n\t\t\treturn false;\r\n\t\t} else if(c1 == 0x2e) {\r\n\t\t\tif(digit(c2)) return true;\r\n\t\t\treturn false;\r\n\t\t} else if(digit(c1)) {\r\n\t\t\treturn true;\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t};\r\n\tvar startsWithANumber = function() {\r\n\t\treturn wouldStartANumber(code, next(1), next(2));\r\n\t};\r\n\r\n\tvar consumeAName = function() {\r\n\t\tvar result = \"\";\r\n\t\twhile(consume()) {\r\n\t\t\tif(namechar(code)) {\r\n\t\t\t\tresult += stringFromCode(code);\r\n\t\t\t} else if(startsWithAValidEscape()) {\r\n\t\t\t\tresult += stringFromCode(consumeEscape());\r\n\t\t\t} else {\r\n\t\t\t\treconsume();\r\n\t\t\t\treturn result;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tvar consumeANumber = function() {\r\n\t\tvar repr = '';\r\n\t\tvar type = \"integer\";\r\n\t\tif(next() == 0x2b || next() == 0x2d) {\r\n\t\t\tconsume();\r\n\t\t\trepr += stringFromCode(code);\r\n\t\t}\r\n\t\twhile(digit(next())) {\r\n\t\t\tconsume();\r\n\t\t\trepr += stringFromCode(code);\r\n\t\t}\r\n\t\tif(next(1) == 0x2e && digit(next(2))) {\r\n\t\t\tconsume();\r\n\t\t\trepr += stringFromCode(code);\r\n\t\t\tconsume();\r\n\t\t\trepr += stringFromCode(code);\r\n\t\t\ttype = \"number\";\r\n\t\t\twhile(digit(next())) {\r\n\t\t\t\tconsume();\r\n\t\t\t\trepr += stringFromCode(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar c1 = next(1), c2 = next(2), c3 = next(3);\r\n\t\tif((c1 == 0x45 || c1 == 0x65) && digit(c2)) {\r\n\t\t\tconsume();\r\n\t\t\trepr += stringFromCode(code);\r\n\t\t\tconsume();\r\n\t\t\trepr += stringFromCode(code);\r\n\t\t\ttype = \"number\";\r\n\t\t\twhile(digit(next())) {\r\n\t\t\t\tconsume();\r\n\t\t\t\trepr += stringFromCode(code);\r\n\t\t\t}\r\n\t\t} else if((c1 == 0x45 || c1 == 0x65) && (c2 == 0x2b || c2 == 0x2d) && digit(c3)) {\r\n\t\t\tconsume();\r\n\t\t\trepr += stringFromCode(code);\r\n\t\t\tconsume();\r\n\t\t\trepr += stringFromCode(code);\r\n\t\t\tconsume();\r\n\t\t\trepr += stringFromCode(code);\r\n\t\t\ttype = \"number\";\r\n\t\t\twhile(digit(next())) {\r\n\t\t\t\tconsume();\r\n\t\t\t\trepr += stringFromCode(code);\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar value = convertAStringToANumber(repr);\r\n\t\treturn {type:type, value:value, repr:repr};\r\n\t};\r\n\r\n\tvar convertAStringToANumber = function(string) {\r\n\t\t// CSS's number rules are identical to JS, afaik.\r\n\t\treturn +string;\r\n\t};\r\n\r\n\tvar consumeTheRemnantsOfABadURL = function() {\r\n\t\twhile(consume()) {\r\n\t\t\tif(code == 0x2d || eof()) {\r\n\t\t\t\treturn;\r\n\t\t\t} else if(startsWithAValidEscape()) {\r\n\t\t\t\tconsumeEscape();\r\n\t\t\t\tdonothing();\r\n\t\t\t} else {\r\n\t\t\t\tdonothing();\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\r\n\r\n\tvar iterationCount = 0;\r\n\twhile(!eof(next())) {\r\n\t\ttokens.push(consumeAToken());\r\n\t\tif(iterationCount++ > str.length*2) throw new Error(\"The CSS Tokenizer is infinite-looping\");\r\n\t}\r\n\treturn tokens;\r\n}\r\n\r\nfunction CSSParserToken() { return this; }\r\nCSSParserToken.prototype.toJSON = function() {\r\n\treturn {token: this.tokenType};\r\n}\r\nCSSParserToken.prototype.toString = function() { return this.tokenType; }\r\nCSSParserToken.prototype.toCSSString = function() { return ''+this; }\r\n\r\nfunction BadStringToken() { return this; }\r\nBadStringToken.prototype = new CSSParserToken;\r\nBadStringToken.prototype.tokenType = \"BADSTRING\";\r\nBadStringToken.prototype.toCSSString = function() { return \"'\"; }\r\n\r\nfunction BadURLToken() { return this; }\r\nBadURLToken.prototype = new CSSParserToken;\r\nBadURLToken.prototype.tokenType = \"BADURL\";\r\nBadURLToken.prototype.toCSSString = function() { return \"url(\"; }\r\n\r\nfunction WhitespaceToken() { return this; }\r\nWhitespaceToken.prototype = new CSSParserToken;\r\nWhitespaceToken.prototype.tokenType = \"WHITESPACE\";\r\nWhitespaceToken.prototype.toString = function() { return \"WS\"; }\r\nWhitespaceToken.prototype.toCSSString = function() { return \" \"; }\r\n\r\nfunction CDOToken() { return this; }\r\nCDOToken.prototype = new CSSParserToken;\r\nCDOToken.prototype.tokenType = \"CDO\";\r\nCDOToken.prototype.toCSSString = function() { return \"<!--\"; }\r\n\r\nfunction CDCToken() { return this; }\r\nCDCToken.prototype = new CSSParserToken;\r\nCDCToken.prototype.tokenType = \"CDC\";\r\nCDCToken.prototype.toCSSString = function() { return \"-->\"; }\r\n\r\nfunction ColonToken() { return this; }\r\nColonToken.prototype = new CSSParserToken;\r\nColonToken.prototype.tokenType = \":\";\r\n\r\nfunction SemicolonToken() { return this; }\r\nSemicolonToken.prototype = new CSSParserToken;\r\nSemicolonToken.prototype.tokenType = \";\";\r\n\r\nfunction CommaToken() { return this; }\r\nCommaToken.prototype = new CSSParserToken;\r\nCommaToken.prototype.tokenType = \",\";\r\nCommaToken.prototype.value = \";\"; // backwards-compat with DELIM token\r\n\r\nfunction GroupingToken() { return this; }\r\nGroupingToken.prototype = new CSSParserToken;\r\n\r\nfunction OpenCurlyToken() { this.value = \"{\"; this.mirror = \"}\"; return this; }\r\nOpenCurlyToken.prototype = new GroupingToken;\r\nOpenCurlyToken.prototype.tokenType = \"{\";\r\n\r\nfunction CloseCurlyToken() { this.value = \"}\"; this.mirror = \"{\"; return this; }\r\nCloseCurlyToken.prototype = new GroupingToken;\r\nCloseCurlyToken.prototype.tokenType = \"}\";\r\n\r\nfunction OpenSquareToken() { this.value = \"[\"; this.mirror = \"]\"; return this; }\r\nOpenSquareToken.prototype = new GroupingToken;\r\nOpenSquareToken.prototype.tokenType = \"[\";\r\n\r\nfunction CloseSquareToken() { this.value = \"]\"; this.mirror = \"[\"; return this; }\r\nCloseSquareToken.prototype = new GroupingToken;\r\nCloseSquareToken.prototype.tokenType = \"]\";\r\n\r\nfunction OpenParenToken() { this.value = \"(\"; this.mirror = \")\"; return this; }\r\nOpenParenToken.prototype = new GroupingToken;\r\nOpenParenToken.prototype.tokenType = \"(\";\r\n\r\nfunction CloseParenToken() { this.value = \")\"; this.mirror = \"(\"; return this; }\r\nCloseParenToken.prototype = new GroupingToken;\r\nCloseParenToken.prototype.tokenType = \")\";\r\n\r\nfunction IncludeMatchToken() { return this; }\r\nIncludeMatchToken.prototype = new CSSParserToken;\r\nIncludeMatchToken.prototype.tokenType = \"~=\";\r\n\r\nfunction DashMatchToken() { return this; }\r\nDashMatchToken.prototype = new CSSParserToken;\r\nDashMatchToken.prototype.tokenType = \"|=\";\r\n\r\nfunction PrefixMatchToken() { return this; }\r\nPrefixMatchToken.prototype = new CSSParserToken;\r\nPrefixMatchToken.prototype.tokenType = \"^=\";\r\n\r\nfunction SuffixMatchToken() { return this; }\r\nSuffixMatchToken.prototype = new CSSParserToken;\r\nSuffixMatchToken.prototype.tokenType = \"$=\";\r\n\r\nfunction SubstringMatchToken() { return this; }\r\nSubstringMatchToken.prototype = new CSSParserToken;\r\nSubstringMatchToken.prototype.tokenType = \"*=\";\r\n\r\nfunction ColumnToken() { return this; }\r\nColumnToken.prototype = new CSSParserToken;\r\nColumnToken.prototype.tokenType = \"||\";\r\n\r\nfunction EOFToken() { return this; }\r\nEOFToken.prototype = new CSSParserToken;\r\nEOFToken.prototype.tokenType = \"EOF\";\r\nEOFToken.prototype.toCSSString = function() { return \"\"; }\r\n\r\nfunction DelimToken(code) {\r\n\tthis.value = stringFromCode(code);\r\n\treturn this;\r\n}\r\nDelimToken.prototype = new CSSParserToken;\r\nDelimToken.prototype.tokenType = \"DELIM\";\r\nDelimToken.prototype.toString = function() { return \"DELIM(\"+this.value+\")\"; }\r\nDelimToken.prototype.toCSSString = function() {\r\n\treturn (this.value == \"\\\\\") ? \"\\\\\\n\" : this.value;\r\n}\r\n\r\nfunction StringValuedToken() { return this; }\r\nStringValuedToken.prototype = new CSSParserToken;\r\nStringValuedToken.prototype.ASCIIMatch = function(str) {\r\n\treturn this.value.toLowerCase() == str.toLowerCase();\r\n}\r\n\r\nfunction IdentifierToken(val) {\r\n\tthis.value = val;\r\n}\r\nIdentifierToken.prototype = new StringValuedToken;\r\nIdentifierToken.prototype.tokenType = \"IDENT\";\r\nIdentifierToken.prototype.toString = function() { return \"IDENT(\"+this.value+\")\"; }\r\nIdentifierToken.prototype.toCSSString = function() {\r\n\treturn escapeIdent(this.value);\r\n}\r\n\r\nfunction FunctionToken(val) {\r\n\tthis.value = val;\r\n\tthis.mirror = \")\";\r\n}\r\nFunctionToken.prototype = new StringValuedToken;\r\nFunctionToken.prototype.tokenType = \"FUNCTION\";\r\nFunctionToken.prototype.toString = function() { return \"FUNCTION(\"+this.value+\")\"; }\r\nFunctionToken.prototype.toCSSString = function() {\r\n\treturn escapeIdent(this.value) + \"(\";\r\n}\r\n\t\r\nfunction AtKeywordToken(val) {\r\n\tthis.value = val;\r\n}\r\nAtKeywordToken.prototype = new StringValuedToken;\r\nAtKeywordToken.prototype.tokenType = \"AT-KEYWORD\";\r\nAtKeywordToken.prototype.toString = function() { return \"AT(\"+this.value+\")\"; }\r\nAtKeywordToken.prototype.toCSSString = function() {\r\n\treturn \"@\" + escapeIdent(this.value);\r\n}\r\n\r\nfunction HashToken(val) {\r\n\tthis.value = val;\r\n\tthis.type = \"unrestricted\";\r\n}\r\nHashToken.prototype = new StringValuedToken;\r\nHashToken.prototype.tokenType = \"HASH\";\r\nHashToken.prototype.toString = function() { return \"HASH(\"+this.value+\")\"; }\r\nHashToken.prototype.toCSSString = function() {\r\n\tvar escapeValue = (this.type == \"id\") ? escapeIdent : escapeHash;\r\n\treturn \"#\" + escapeValue(this.value);\r\n}\r\n\r\nfunction StringToken(val) {\r\nthis.value = val;\r\n}\r\nStringToken.prototype = new StringValuedToken;\r\nStringToken.prototype.tokenType = \"STRING\";\r\nStringToken.prototype.toString = function() {\r\n\treturn '\"' + escapeString(this.value) + '\"';\r\n}\r\n\r\nfunction URLToken(val) {\r\n\tthis.value = val;\r\n}\r\nURLToken.prototype = new StringValuedToken;\r\nURLToken.prototype.tokenType = \"URL\";\r\nURLToken.prototype.toString = function() { return \"URL(\"+this.value+\")\"; }\r\nURLToken.prototype.toCSSString = function() {\r\n\treturn 'url(\"' + escapeString(this.value) + '\")';\r\n}\r\n\r\nfunction NumberToken() {\r\n\tthis.value = null;\r\n\tthis.type = \"integer\";\r\n\tthis.repr = \"\";\r\n}\r\nNumberToken.prototype = new CSSParserToken;\r\nNumberToken.prototype.tokenType = \"NUMBER\";\r\nNumberToken.prototype.toString = function() {\r\n\tif(this.type == \"integer\")\r\n\t\treturn \"INT(\"+this.value+\")\";\r\n\treturn \"NUMBER(\"+this.value+\")\";\r\n}\r\nNumberToken.prototype.toJSON = function() {\r\n\tvar json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\r\n\tjson.value = this.value;\r\n\tjson.type = this.type;\r\n\tjson.repr = this.repr;\r\n\treturn json;\r\n}\r\nNumberToken.prototype.toCSSString = function() { return this.repr; };\r\n\r\nfunction PercentageToken() {\r\n\tthis.value = null;\r\n\tthis.repr = \"\";\r\n}\r\nPercentageToken.prototype = new CSSParserToken;\r\nPercentageToken.prototype.tokenType = \"PERCENTAGE\";\r\nPercentageToken.prototype.toString = function() { return \"PERCENTAGE(\"+this.value+\")\"; }\r\nPercentageToken.prototype.toCSSString = function() { return this.repr + \"%\"; }\r\n\r\nfunction DimensionToken() {\r\n\tthis.value = null;\r\n\tthis.type = \"integer\";\r\n\tthis.repr = \"\";\r\n\tthis.unit = \"\";\r\n}\r\nDimensionToken.prototype = new CSSParserToken;\r\nDimensionToken.prototype.tokenType = \"DIMENSION\";\r\nDimensionToken.prototype.toString = function() { return \"DIM(\"+this.value+\",\"+this.unit+\")\"; }\r\nDimensionToken.prototype.toCSSString = function() {\r\n\tvar source = this.repr;\r\n\tvar unit = escapeIdent(this.unit);\r\n\tif(unit[0].toLowerCase() == \"e\" && (unit[1] == \"-\" || between(unit.charCodeAt(1), 0x30, 0x39))) {\r\n\t\t// Unit is ambiguous with scinot\r\n\t\t// Remove the leading \"e\", replace with escape.\r\n\t\tunit = \"\\\\65 \" + unit.slice(1, unit.length);\r\n\t}\r\n\treturn source+unit;\r\n}\r\n\r\nfunction escapeIdent(string) {\r\n\tstring = ''+string;\r\n\tvar result = '';\r\n\tvar firstcode = string.charCodeAt(0);\r\n\tfor(var i = 0; i < string.length; i++) {\r\n\t\tvar code = string.charCodeAt(i);\r\n\t\tif(code == 0x0) {\r\n\t\t\tthrow new InvalidCharacterError('Invalid character: the input contains U+0000.');\r\n\t\t}\r\n\r\n\t\tif(\r\n\t\t\tbetween(code, 0x1, 0x1f) || code == 0x7f ||\r\n\t\t\t(i == 0 && between(code, 0x30, 0x39)) ||\r\n\t\t\t(i == 1 && between(code, 0x30, 0x39) && firstcode == 0x2d)\r\n\t\t) {\r\n\t\t\tresult += '\\\\' + code.toString(16) + ' ';\r\n\t\t} else if(\r\n\t\t\tcode >= 0x80 ||\r\n\t\t\tcode == 0x2d ||\r\n\t\t\tcode == 0x5f ||\r\n\t\t\tbetween(code, 0x30, 0x39) ||\r\n\t\t\tbetween(code, 0x41, 0x5a) ||\r\n\t\t\tbetween(code, 0x61, 0x7a)\r\n\t\t) {\r\n\t\t\tresult += string[i];\r\n\t\t} else {\r\n\t\t\tresult += '\\\\' + string[i];\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nfunction escapeHash(string) {\r\n\t// Escapes the contents of \"unrestricted\"-type hash tokens.\r\n\t// Won't preserve the ID-ness of \"id\"-type hash tokens;\r\n\t// use escapeIdent() for that.\r\n\tstring = ''+string;\r\n\tvar result = '';\r\n\tvar firstcode = string.charCodeAt(0);\r\n\tfor(var i = 0; i < string.length; i++) {\r\n\t\tvar code = string.charCodeAt(i);\r\n\t\tif(code == 0x0) {\r\n\t\t\tthrow new InvalidCharacterError('Invalid character: the input contains U+0000.');\r\n\t\t}\r\n\r\n\t\tif(\r\n\t\t\tcode >= 0x80 ||\r\n\t\t\tcode == 0x2d ||\r\n\t\t\tcode == 0x5f ||\r\n\t\t\tbetween(code, 0x30, 0x39) ||\r\n\t\t\tbetween(code, 0x41, 0x5a) ||\r\n\t\t\tbetween(code, 0x61, 0x7a)\r\n\t\t) {\r\n\t\t\tresult += string[i];\r\n\t\t} else {\r\n\t\t\tresult += '\\\\' + code.toString(16) + ' ';\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nfunction escapeString(string) {\r\n\tstring = ''+string;\r\n\tvar result = '';\r\n\tfor(var i = 0; i < string.length; i++) {\r\n\t\tvar code = string.charCodeAt(i);\r\n\r\n\t\tif(code == 0x0) {\r\n\t\t\tthrow new InvalidCharacterError('Invalid character: the input contains U+0000.');\r\n\t\t}\r\n\r\n\t\tif(between(code, 0x1, 0x1f) || code == 0x7f) {\r\n\t\t\tresult += '\\\\' + code.toString(16) + ' ';\r\n\t\t} else if(code == 0x22 || code == 0x5c) {\r\n\t\t\tresult += '\\\\' + string[i];\r\n\t\t} else {\r\n\t\t\tresult += string[i];\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n// Exportation.\r\ncssSyntax.tokenize = tokenize;\r\ncssSyntax.IdentToken = IdentifierToken;\r\ncssSyntax.IdentifierToken = IdentifierToken;\r\ncssSyntax.FunctionToken = FunctionToken;\r\ncssSyntax.AtKeywordToken = AtKeywordToken;\r\ncssSyntax.HashToken = HashToken;\r\ncssSyntax.StringToken = StringToken;\r\ncssSyntax.BadStringToken = BadStringToken;\r\ncssSyntax.URLToken = URLToken;\r\ncssSyntax.BadURLToken = BadURLToken;\r\ncssSyntax.DelimToken = DelimToken;\r\ncssSyntax.NumberToken = NumberToken;\r\ncssSyntax.PercentageToken = PercentageToken;\r\ncssSyntax.DimensionToken = DimensionToken;\r\ncssSyntax.IncludeMatchToken = IncludeMatchToken;\r\ncssSyntax.DashMatchToken = DashMatchToken;\r\ncssSyntax.PrefixMatchToken = PrefixMatchToken;\r\ncssSyntax.SuffixMatchToken = SuffixMatchToken;\r\ncssSyntax.SubstringMatchToken = SubstringMatchToken;\r\ncssSyntax.ColumnToken = ColumnToken;\r\ncssSyntax.WhitespaceToken = WhitespaceToken;\r\ncssSyntax.CDOToken = CDOToken;\r\ncssSyntax.CDCToken = CDCToken;\r\ncssSyntax.ColonToken = ColonToken;\r\ncssSyntax.SemicolonToken = SemicolonToken;\r\ncssSyntax.CommaToken = CommaToken;\r\ncssSyntax.OpenParenToken = OpenParenToken;\r\ncssSyntax.CloseParenToken = CloseParenToken;\r\ncssSyntax.OpenSquareToken = OpenSquareToken;\r\ncssSyntax.CloseSquareToken = CloseSquareToken;\r\ncssSyntax.OpenCurlyToken = OpenCurlyToken;\r\ncssSyntax.CloseCurlyToken = CloseCurlyToken;\r\ncssSyntax.EOFToken = EOFToken;\r\ncssSyntax.CSSParserToken = CSSParserToken;\r\ncssSyntax.GroupingToken = GroupingToken;\r\n\r\n//\r\n// css parser\r\n//\r\n\r\nfunction TokenStream(tokens) {\r\n\t// Assume that tokens is an array.\r\n\tthis.tokens = tokens;\r\n\tthis.i = -1;\r\n}\r\nTokenStream.prototype.tokenAt = function(i) {\r\n\tif(i < this.tokens.length)\r\n\t\treturn this.tokens[i];\r\n\treturn new EOFToken();\r\n}\r\nTokenStream.prototype.consume = function(num) {\r\n\tif(num === undefined) num = 1;\r\n\tthis.i += num;\r\n\tthis.token = this.tokenAt(this.i);\r\n\t//console.log(this.i, this.token);\r\n\treturn true;\r\n}\r\nTokenStream.prototype.next = function() {\r\n\treturn this.tokenAt(this.i+1);\r\n}\r\nTokenStream.prototype.reconsume = function() {\r\n\tthis.i--;\r\n}\r\n\r\nfunction parseerror(s, msg) {\r\n\tconsole.log(\"Parse error at token \" + s.i + \": \" + s.token + \".\\n\" + msg);\r\n\treturn true;\r\n}\r\nfunction donothing(){ return true; };\r\n\r\nfunction consumeAListOfRules(s, topLevel) {\r\n\tvar rules = new TokenList();\r\n\tvar rule;\r\n\twhile(s.consume()) {\r\n\t\tif(s.token instanceof WhitespaceToken) {\r\n\t\t\tcontinue;\r\n\t\t} else if(s.token instanceof EOFToken) {\r\n\t\t\treturn rules;\r\n\t\t} else if(s.token instanceof CDOToken || s.token instanceof CDCToken) {\r\n\t\t\tif(topLevel == \"top-level\") continue;\r\n\t\t\ts.reconsume();\r\n\t\t\tif(rule = consumeAStyleRule(s)) rules.push(rule);\r\n\t\t} else if(s.token instanceof AtKeywordToken) {\r\n\t\t\ts.reconsume();\r\n\t\t\tif(rule = consumeAnAtRule(s)) rules.push(rule);\r\n\t\t} else {\r\n\t\t\ts.reconsume();\r\n\t\t\tif(rule = consumeAStyleRule(s)) rules.push(rule);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction consumeAnAtRule(s) {\r\n\ts.consume();\r\n\tvar rule = new AtRule(s.token.value);\r\n\twhile(s.consume()) {\r\n\t\tif(s.token instanceof SemicolonToken || s.token instanceof EOFToken) {\r\n\t\t\treturn rule;\r\n\t\t} else if(s.token instanceof OpenCurlyToken) {\r\n\t\t\trule.value = consumeASimpleBlock(s);\r\n\t\t\treturn rule;\r\n\t\t} else if(s.token instanceof SimpleBlock && s.token.name == \"{\") {\r\n\t\t\trule.value = s.token;\r\n\t\t\treturn rule;\r\n\t\t} else {\r\n\t\t\ts.reconsume();\r\n\t\t\trule.prelude.push(consumeAComponentValue(s));\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction consumeAStyleRule(s) {\r\n\tvar rule = new StyleRule();\r\n\twhile(s.consume()) {\r\n\t\tif(s.token instanceof EOFToken) {\r\n\t\t\tparseerror(s, \"Hit EOF when trying to parse the prelude of a qualified rule.\");\r\n\t\t\treturn;\r\n\t\t} else if(s.token instanceof OpenCurlyToken) {\r\n\t\t\trule.value = consumeASimpleBlock(s);\r\n\t\t\treturn rule;\r\n\t\t} else if(s.token instanceof SimpleBlock && s.token.name == \"{\") {\r\n\t\t\trule.value = s.token;\r\n\t\t\treturn rule;\r\n\t\t} else {\r\n\t\t\ts.reconsume();\r\n\t\t\trule.prelude.push(consumeAComponentValue(s));\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction consumeAListOfDeclarations(s) {\r\n\tvar decls = new TokenList();\r\n\twhile(s.consume()) {\r\n\t\tif(s.token instanceof WhitespaceToken || s.token instanceof SemicolonToken) {\r\n\t\t\tdonothing();\r\n\t\t} else if(s.token instanceof EOFToken) {\r\n\t\t\treturn decls;\r\n\t\t} else if(s.token instanceof AtKeywordToken) {\r\n\t\t\ts.reconsume();\r\n\t\t\tdecls.push(consumeAnAtRule(s));\r\n\t\t} else if(s.token instanceof IdentifierToken) {\r\n\t\t\tvar temp = [s.token];\r\n\t\t\twhile(!(s.next() instanceof SemicolonToken || s.next() instanceof EOFToken))\r\n\t\t\t\ttemp.push(consumeAComponentValue(s));\r\n\t\t\tvar decl;\r\n\t\t\tif(decl = consumeADeclaration(new TokenStream(temp))) decls.push(decl);\r\n\t\t} else {\r\n\t\t\tparseerror(s);\r\n\t\t\ts.reconsume();\r\n\t\t\twhile(!(s.next() instanceof SemicolonToken || s.next() instanceof EOFToken))\r\n\t\t\t\tconsumeAComponentValue(s);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction consumeADeclaration(s) {\r\n\t// Assumes that the next input token will be an ident token.\r\n\ts.consume();\r\n\tvar decl = new Declaration(s.token.value);\r\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\r\n\tif(!(s.next() instanceof ColonToken)) {\r\n\t\tparseerror(s);\r\n\t\treturn;\r\n\t} else {\r\n\t\ts.consume();\r\n\t}\r\n\twhile(!(s.next() instanceof EOFToken)) {\r\n\t\tdecl.value.push(consumeAComponentValue(s));\r\n\t}\r\n\tvar foundImportant = false;\r\n\tfor(var i = decl.value.length - 1; i >= 0; i--) {\r\n\t\tif(decl.value[i] instanceof WhitespaceToken) {\r\n\t\t\tcontinue;\r\n\t\t} else if(decl.value[i] instanceof IdentifierToken && decl.value[i].ASCIIMatch(\"important\")) {\r\n\t\t\tfoundImportant = true;\r\n\t\t} else if(foundImportant && decl.value[i] instanceof DelimToken && decl.value[i].value == \"!\") {\r\n\t\t\tdecl.value.splice(i, decl.value.length);\r\n\t\t\tdecl.important = true;\r\n\t\t\tbreak;\r\n\t\t} else {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn decl;\r\n}\r\n\r\nfunction consumeAComponentValue(s) {\r\n\ts.consume();\r\n\tif(s.token instanceof OpenCurlyToken || s.token instanceof OpenSquareToken || s.token instanceof OpenParenToken)\r\n\t\treturn consumeASimpleBlock(s);\r\n\tif(s.token instanceof FunctionToken)\r\n\t\treturn consumeAFunction(s);\r\n\treturn s.token;\r\n}\r\n\r\nfunction consumeASimpleBlock(s) {\r\n\tvar mirror = s.token.mirror;\r\n\tvar block = new SimpleBlock(s.token.value);\r\n\twhile(s.consume()) {\r\n\t\tif(s.token instanceof EOFToken || (s.token instanceof GroupingToken && s.token.value == mirror))\r\n\t\t\treturn block;\r\n\t\telse {\r\n\t\t\ts.reconsume();\r\n\t\t\tblock.value.push(consumeAComponentValue(s));\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction consumeAFunction(s) {\r\n\tvar func = new Func(s.token.value);\r\n\twhile(s.consume()) {\r\n\t\tif(s.token instanceof EOFToken || s.token instanceof CloseParenToken)\r\n\t\t\treturn func;\r\n\t\telse {\r\n\t\t\ts.reconsume();\r\n\t\t\tfunc.value.push(consumeAComponentValue(s));\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction normalizeInput(input) {\r\n\tif(typeof input == \"string\")\r\n\t\treturn new TokenStream(tokenize(input));\r\n\tif(input instanceof TokenStream)\r\n\t\treturn input;\r\n\tif(input.length !== undefined)\r\n\t\treturn new TokenStream(input);\r\n\telse throw SyntaxError(input);\r\n}\r\n\r\nfunction parseAStylesheet(s) {\r\n\ts = normalizeInput(s);\r\n\tvar sheet = new Stylesheet();\r\n\tsheet.value = consumeAListOfRules(s, \"top-level\");\r\n\treturn sheet;\r\n}\r\n\r\nfunction parseAListOfRules(s) {\r\n\ts = normalizeInput(s);\r\n\treturn consumeAListOfRules(s);\r\n}\r\n\r\nfunction parseARule(s) {\r\n\ts = normalizeInput(s);\r\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\r\n\tif(s.next() instanceof EOFToken) throw SyntaxError();\r\n\tif(s.next() instanceof AtKeywordToken) {\r\n\t\tvar rule = consumeAnAtRule(s);\r\n\t} else {\r\n\t\tvar rule = consumeAStyleRule(s);\r\n\t\tif(!rule) throw SyntaxError();\r\n\t}\r\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\r\n\tif(s.next() instanceof EOFToken)\r\n\t\treturn rule;\r\n\tthrow SyntaxError();\r\n}\r\n\r\nfunction parseADeclaration(s) {\r\n\ts = normalizeInput(s);\r\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\r\n\tif(!(s.next() instanceof IdentifierToken)) throw SyntaxError();\r\n\tvar decl = consumeADeclaration(s);\r\n\tif(!decl) { throw new SyntaxError() }\r\n\treturn decl;\r\n}\r\n\r\nfunction parseAListOfDeclarations(s) {\r\n\ts = normalizeInput(s);\r\n\treturn consumeAListOfDeclarations(s);\r\n}\r\n\r\nfunction parseAComponentValue(s) {\r\n\ts = normalizeInput(s);\r\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\r\n\tif(s.next() instanceof EOFToken) throw SyntaxError();\r\n\tvar val = consumeAComponentValue(s);\r\n\tif(!val) throw SyntaxError();\r\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\r\n\tif(!(s.next() instanceof EOFToken)) throw new SyntaxError();\r\n\treturn val;\r\n}\r\n\r\nfunction parseAListOfComponentValues(s) {\r\n\ts = normalizeInput(s);\r\n\tvar vals = new TokenList();\r\n\twhile(true) {\r\n\t\tvar val = consumeAComponentValue(s);\r\n\t\tif(val instanceof EOFToken)\r\n\t\t\treturn vals\r\n\t\telse\r\n\t\t\tvals.push(val);\r\n\t}\r\n}\r\n\r\nfunction parseACommaSeparatedListOfComponentValues(s) {\r\n\ts = normalizeInput(s);\r\n\tvar listOfCVLs = new TokenList();\r\n\twhile(true) {\r\n\t\tvar vals = new TokenList();\r\n\t\twhile(true) {\r\n\t\t\tvar val = consumeAComponentValue(s);\r\n\t\t\tif(val instanceof EOFToken) {\r\n\t\t\t\tlistOfCVLs.push(vals);\r\n\t\t\t\treturn listOfCVLs;\r\n\t\t\t} else if(val instanceof CommaToken) {\r\n\t\t\t\tlistOfCVLs.push(vals);\r\n\t\t\t\tbreak;\r\n\t\t\t} else {\r\n\t\t\t\tvals.push(val);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction CSSParserRule() { return this; }\r\nCSSParserRule.prototype.toString = function(indent) {\r\n\treturn JSON.stringify(this,null,indent);\r\n}\r\n\r\nfunction Stylesheet() {\r\n\tthis.value = new TokenList();\r\n\treturn this;\r\n}\r\nStylesheet.prototype = new CSSParserRule;\r\nStylesheet.prototype.type = \"STYLESHEET\";\r\nStylesheet.prototype.toCSSString = function() { return this.value.toCSSString(\"\\n\"); }\r\n\r\nfunction AtRule(name) {\r\n\tthis.name = name;\r\n\tthis.prelude = new TokenList();\r\n\tthis.value = null;\r\n\treturn this;\r\n}\r\nAtRule.prototype = new CSSParserRule;\r\nAtRule.prototype.toCSSString = function() { \r\n\tif(this.value) {\r\n\t\treturn \"@\" + escapeIdent(this.name) + \" \" + this.prelude.toCSSString() + this.value.toCSSString(); \r\n\t} else {\r\n\t\treturn \"@\" + escapeIdent(this.name) + \" \" + this.prelude.toCSSString() + '; '; \r\n\t}\r\n}\r\nAtRule.prototype.toStylesheet = function() {\r\n\treturn this.asStylesheet || (this.asStylesheet = this.value ? parseAStylesheet(this.value.value) : new Stylesheet());\r\n}\r\n\r\nfunction StyleRule() {\r\n\tthis.prelude = new TokenList(); this.selector = this.prelude;\r\n\tthis.value = null;\r\n\treturn this;\r\n}\r\nStyleRule.prototype = new CSSParserRule;\r\nStyleRule.prototype.type = \"STYLE-RULE\";\r\nStyleRule.prototype.toCSSString = function() {\r\n\treturn this.prelude.toCSSString() + this.value.toCSSString();\r\n}\r\nStyleRule.prototype.getSelector = function() {\r\n\treturn this.prelude;\r\n}\r\nStyleRule.prototype.getDeclarations = function() {\r\n\tif(!(this.value instanceof SimpleBlock)) { return new TokenList(); }\r\n\tvar value = this.value.value; return parseAListOfDeclarations(value);\r\n}\r\n\r\n\r\nfunction Declaration(name) {\r\n\tthis.name = name;\r\n\tthis.value = new TokenList();\r\n\tthis.important = false;\r\n\treturn this;\r\n}\r\nDeclaration.prototype = new CSSParserRule;\r\nDeclaration.prototype.type = \"DECLARATION\";\r\nDeclaration.prototype.toCSSString = function() {\r\n\treturn this.name + ':' + this.value.toCSSString() + '; ';\r\n}\r\n\r\nfunction SimpleBlock(type) {\r\n\tthis.name = type;\r\n\tthis.value = new TokenList();\r\n\treturn this;\r\n}\r\nSimpleBlock.prototype = new CSSParserRule;\r\nSimpleBlock.prototype.type = \"BLOCK\";\r\nSimpleBlock.prototype.toCSSString = function() {\r\n\tswitch(this.name) {\r\n\t\tcase \"(\":\r\n\t\t\treturn \"(\" + this.value.toCSSString() + \")\";\r\n\t\t\t\r\n\t\tcase \"[\":\r\n\t\t\treturn \"[\" + this.value.toCSSString() + \"]\";\r\n\t\t\t\r\n\t\tcase \"{\":\r\n\t\t\treturn \"{\" + this.value.toCSSString() + \"}\";\r\n\t\t\r\n\t\tdefault: //best guess\r\n\t\t\treturn this.name + this.value.toCSSString() + this.name;\r\n\t}\r\n}\r\n\r\nfunction Func(name) {\r\n\tthis.name = name;\r\n\tthis.value = new TokenList();\r\n\treturn this;\r\n}\r\nFunc.prototype = new CSSParserRule;\r\nFunc.prototype.type = \"FUNCTION\";\r\nFunc.prototype.toCSSString = function() {\r\n\treturn this.name+'('+this.value.toCSSString()+')';\r\n}\r\nFunc.prototype.getArguments = function() {\r\n\tvar args = new TokenList(); var arg = new TokenList(); var value = this.value;\r\n\tfor(var i = 0; i<value.length; i++) {\r\n\t\tif(value[i].tokenType == ',') {\r\n\t\t\targs.push(arg); arg = new TokenList();\r\n\t\t} else {\r\n\t\t\targ.push(value[i])\r\n\t\t}\r\n\t}\r\n\tif(args.length > 0 || arg.length > 0) { args.push(arg); }\r\n\treturn args;\r\n}\r\n\r\nfunction FuncArg() {\r\n\tthis.value = new TokenList();\r\n\treturn this;\r\n}\r\nFuncArg.prototype = new CSSParserRule;\r\nFuncArg.prototype.type = \"FUNCTION-ARG\";\r\nFuncArg.prototype.toCSSString = function() {\r\n\treturn this.value.toCSSString()+', ';\r\n}\r\n\r\n// Exportation.\r\ncssSyntax.CSSParserRule = CSSParserRule;\r\ncssSyntax.Stylesheet = Stylesheet;\r\ncssSyntax.AtRule = AtRule;\r\ncssSyntax.StyleRule = StyleRule;\r\ncssSyntax.Declaration = Declaration;\r\ncssSyntax.SimpleBlock = SimpleBlock;\r\ncssSyntax.Func = Func;\r\ncssSyntax.parseAStylesheet = parseAStylesheet;\r\ncssSyntax.parseAListOfRules = parseAListOfRules;\r\ncssSyntax.parseARule = parseARule;\r\ncssSyntax.parseADeclaration = parseADeclaration;\r\ncssSyntax.parseAListOfDeclarations = parseAListOfDeclarations;\r\ncssSyntax.parseAComponentValue = parseAComponentValue;\r\ncssSyntax.parseAListOfComponentValues = parseAListOfComponentValues;\r\ncssSyntax.parseACommaSeparatedListOfComponentValues = parseACommaSeparatedListOfComponentValues;\r\ncssSyntax.parse = parseAStylesheet;\r\ncssSyntax.parseCSSValue = parseAListOfComponentValues;\r\n\r\nreturn cssSyntax;\r\n\r\n}());\r\n\nrequire.define('src/core/css-syntax.js');","void function() {\r\n\t\r\n\t// request animation frame\r\n    var vendors = ['webkit', 'moz', 'ms', 'o'];\r\n    for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {\r\n        var vp = vendors[i];\r\n        window.requestAnimationFrame = window[vp+'RequestAnimationFrame'];\r\n        window.cancelAnimationFrame = (window[vp+'CancelAnimationFrame'] || window[vp+'CancelRequestAnimationFrame']);\r\n    }\r\n    if (!window.requestAnimationFrame || !window.cancelAnimationFrame) {\r\n\t\t\r\n\t\t// tick every 16ms\r\n        var listener_index = 0; var listeners = []; var tmp = []; var tick = function() {\r\n\t\t\tvar now = +(new Date()); var callbacks = listeners; listeners = tmp;\r\n\t\t\tfor(var i = 0; i<callbacks.length; i++) { callbacks[i](now); }\r\n\t\t\tlistener_index += callbacks.length; callbacks.length = 0; tmp = callbacks;\r\n\t\t\tsetTimeout(tick, 16);\r\n\t\t}; tick();\r\n\t\t\r\n\t\t// add a listener\r\n        window.requestAnimationFrame = function(callback) {\r\n            return listener_index + listeners.push(callback);\r\n        };\r\n\t\t\r\n\t\t// remove a listener\r\n        window.cancelAnimationFrame = function(index) {\r\n\t\t\tindex -= listener_index; if(index >= 0 && index < listeners.length) {\r\n\t\t\t\tlisteners[index] = function() {};\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n    }\r\n\t\r\n\t// setImmediate\r\n\tif(!window.setImmediate) {\r\n\t\twindow.setImmediate = function(f) { return setTimeout(f, 0) };\r\n\t\twindow.cancelImmediate = clearTimeout;\r\n\t}\r\n\t\r\n}();\r\n\nrequire.define('src/core/polyfill-dom-requestAnimationFrame.js');","/////////////////////////////////////////////////////////////////\r\n////                                                         ////\r\n////                 prerequirements of qSL                  ////\r\n////                                                         ////\r\n/////////////////////////////////////////////////////////////////\r\n////                                                         ////\r\n////   Please note that I require querySelectorAll to work   ////\r\n////                                                         ////\r\n////   See http://github.com/termi/CSS_selector_engine/      ////\r\n////   for a polyfill for older browsers                     ////\r\n////                                                         ////\r\n/////////////////////////////////////////////////////////////////\r\n\r\n// TODO: improve event streams\r\n// - look for a few optimizations ideas in gecko/webkit\r\n// - use arrays in CompositeEventStream to avoid nested debouncings\r\nmodule.exports = (function(window, document) { \"use strict\";\r\n\r\n\t///\r\n\t/// event stream implementation\r\n\t/// please note this is required to 'live update' the qSA requests\r\n\t///\r\n\tfunction EventStream(connect, disconnect, reconnect) {\r\n\t\tvar self=this;\r\n\t\t\r\n\t\t// validate arguments\r\n\t\tif(!disconnect) disconnect=function(){};\r\n\t\tif(!reconnect) reconnect=connect;\r\n\t\t\r\n\t\t// high-level states\r\n\t\tvar isConnected=false;\r\n\t\tvar isDisconnected=false;\r\n\t\tvar shouldDisconnect=false;\r\n\t\t\r\n\t\t// global variables\r\n\t\tvar callback=null;\r\n\t\tvar yieldEvent = function() {\r\n\t\t\t\r\n\t\t\t// call the callback function, and pend disposal\r\n\t\t\tshouldDisconnect=true;\r\n\t\t\ttry { callback && callback(self); } catch(ex) { setImmediate(function() { throw ex; }); }\r\n\t\t\t\r\n\t\t\t// if no action was taken, dispose\r\n\t\t\tif(shouldDisconnect) { dispose(); }\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t// export the interface\r\n\t\tvar schedule = this.schedule = function(newCallback) {\r\n\t\t\r\n\t\t\t// do not allow to schedule on disconnected event streams\r\n\t\t\tif(isDisconnected) { throw new Error(\"Cannot schedule on a disconnected event stream\"); }\r\n\t\t\t\r\n\t\t\t// do not allow to schedule on already scheduled event streams\r\n\t\t\tif(isConnected && !shouldDisconnect) { throw new Error(\"Cannot schedule on an already-scheduled event stream\"); }\r\n\t\t\t\r\n\t\t\t// schedule the new callback\r\n\t\t\tcallback=newCallback; shouldDisconnect=false;\r\n\t\t\t\r\n\t\t\t// reconnect to the stream\r\n\t\t\tif(isConnected) {\r\n\t\t\t\treconnect(yieldEvent);\r\n\t\t\t} else {\r\n\t\t\t\tconnect(yieldEvent);\r\n\t\t\t\tisConnected=true;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tvar dispose = this.dispose = function() {\r\n\t\t\r\n\t\t\t// do not allow to dispose non-connected streams\r\n\t\t\tif(isConnected) {\r\n\t\t\t\r\n\t\t\t\t// disconnect & save resources\r\n\t\t\t\tdisconnect(); \r\n\t\t\t\tself=null; yieldEvent=null; callback=null; \r\n\t\t\t\tisConnected=false; isDisconnected=true; shouldDisconnect=false;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t///\r\n\t/// call a function every frame\r\n\t///\r\n\tfunction AnimationFrameEventStream(options) {\r\n\t\t\r\n\t\t// flag that says whether the observer is still needed or not\r\n\t\tvar rid = 0;\r\n\t\t\t\r\n\t\t// start the event stream\r\n\t\tEventStream.call(\r\n\t\t\tthis, \r\n\t\t\tfunction connect(yieldEvent) { rid = requestAnimationFrame(yieldEvent); },\r\n\t\t\tfunction disconnect() { cancelAnimationFrame(rid); }\r\n\t\t);\r\n\t\t\r\n\t}\r\n\r\n\t///\r\n\t/// call a function every timeout\r\n\t///\r\n\tfunction TimeoutEventStream(options) {\r\n\t\t\r\n\t\t// flag that says whether the observer is still needed or not\r\n\t\tvar rid = 0; var timeout=(typeof(options)==\"number\") ? (+options) : (\"timeout\" in options ? +options.timeout : 333);\r\n\t\t\t\r\n\t\t// start the event stream\r\n\t\tEventStream.call(\r\n\t\t\tthis, \r\n\t\t\tfunction connect(yieldEvent) { rid = setTimeout(yieldEvent, timeout); },\r\n\t\t\tfunction disconnect() { clearTimeout(rid); }\r\n\t\t);\r\n\t\t\r\n\t}\r\n\r\n\t///\r\n\t/// call a function every time the mouse moves\r\n\t///\r\n\tfunction MouseEventStream() {\r\n\t\tvar self=this; var pointermove = ((\"PointerEvent\" in window) ? \"pointermove\" : ((\"MSPointerEvent\" in window) ? \"MSPointerMove\" : \"mousemove\"));\r\n\r\n\t\t// flag that says whether the event is still observed or not\r\n\t\tvar scheduled = false; var interval=0;\r\n\t\t\r\n\t\t// handle the synchronous nature of mutation events\r\n\t\tvar yieldEvent=null;\r\n\t\tvar yieldEventDelayed = function() {\r\n\t\t\tif(scheduled) return;\r\n\t\t\twindow.removeEventListener(pointermove, yieldEventDelayed, true);\r\n\t\t\tscheduled = requestAnimationFrame(yieldEvent);\r\n\t\t}\r\n\t\t\r\n\t\t// start the event stream\r\n\t\tEventStream.call(\r\n\t\t\tthis, \r\n\t\t\tfunction connect(newYieldEvent) {\r\n\t\t\t\tyieldEvent=newYieldEvent;\r\n\t\t\t\twindow.addEventListener(pointermove, yieldEventDelayed, true);\r\n\t\t\t},\r\n\t\t\tfunction disconnect() { \r\n\t\t\t\twindow.removeEventListener(pointermove, yieldEventDelayed, true);\r\n\t\t\t\tcancelAnimationFrame(scheduled); yieldEventDelayed=null; yieldEvent=null; scheduled=false;\r\n\t\t\t},\r\n\t\t\tfunction reconnect(newYieldEvent) { \r\n\t\t\t\tyieldEvent=newYieldEvent; scheduled=false;\r\n\t\t\t\twindow.addEventListener(pointermove, yieldEventDelayed, true);\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t}\r\n\r\n\t///\r\n\t/// call a function every time the mouse is clicked/unclicked\r\n\t///\r\n\tfunction MouseButtonEventStream() {\r\n\t\tvar self=this; \r\n\t\tvar pointerup = ((\"PointerEvent\" in window) ? \"pointerup\" : ((\"MSPointerEvent\" in window) ? \"MSPointerUp\" : \"mouseup\"));\r\n\t\tvar pointerdown = ((\"PointerEvent\" in window) ? \"pointerdown\" : ((\"MSPointerEvent\" in window) ? \"MSPointerDown\" : \"mousedown\"));\r\n\r\n\t\t// flag that says whether the event is still observed or not\r\n\t\tvar scheduled = false; var interval=0;\r\n\t\t\r\n\t\t// handle the synchronous nature of mutation events\r\n\t\tvar yieldEvent=null;\r\n\t\tvar yieldEventDelayed = function() {\r\n\t\t\tif(scheduled) return;\r\n\t\t\twindow.removeEventListener(pointerup, yieldEventDelayed, true);\r\n\t\t\twindow.removeEventListener(pointerdown, yieldEventDelayed, true);\r\n\t\t\tscheduled = requestAnimationFrame(yieldEvent);\r\n\t\t}\r\n\t\t\r\n\t\t// start the event stream\r\n\t\tEventStream.call(\r\n\t\t\tthis, \r\n\t\t\tfunction connect(newYieldEvent) {\r\n\t\t\t\tyieldEvent=newYieldEvent;\r\n\t\t\t\twindow.addEventListener(pointerup, yieldEventDelayed, true);\r\n\t\t\t\twindow.addEventListener(pointerdown, yieldEventDelayed, true);\r\n\t\t\t},\r\n\t\t\tfunction disconnect() { \r\n\t\t\t\twindow.removeEventListener(pointerup, yieldEventDelayed, true);\r\n\t\t\t\twindow.removeEventListener(pointerdown, yieldEventDelayed, true);\r\n\t\t\t\tcancelAnimationFrame(scheduled); yieldEventDelayed=null; yieldEvent=null; scheduled=false;\r\n\t\t\t},\r\n\t\t\tfunction reconnect(newYieldEvent) { \r\n\t\t\t\tyieldEvent=newYieldEvent; scheduled=false;\r\n\t\t\t\twindow.addEventListener(pointerup, yieldEventDelayed, true);\r\n\t\t\t\twindow.addEventListener(pointerdown, yieldEventDelayed, true);\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t}\r\n\r\n\t///\r\n\t/// call a function whenever the DOM is modified\r\n\t///\r\n\tvar DOMUpdateEventStream;\r\n\tif(\"MutationObserver\" in window) {\r\n\t\tDOMUpdateEventStream = function DOMUpdateEventStream(options) {\r\n\t\t\t \r\n\t\t\t// configuration of the observer\r\n\t\t\tif(options) {\r\n\t\t\t\tvar target = \"target\" in options ? options.target : document.documentElement;\r\n\t\t\t\tvar config = { \r\n\t\t\t\t\tsubtree: \"subtree\" in options ? !!options.subtree : true, \r\n\t\t\t\t\tattributes: \"attributes\" in options ? !!options.attributes : true, \r\n\t\t\t\t\tchildList: \"childList\" in options ? !!options.childList : true, \r\n\t\t\t\t\tcharacterData: \"characterData\" in options ? !!options.characterData : false\r\n\t\t\t\t};\r\n\t\t\t} else {\r\n\t\t\t\tvar target = document.documentElement;\r\n\t\t\t\tvar config = { \r\n\t\t\t\t\tsubtree: true, \r\n\t\t\t\t\tattributes: true, \r\n\t\t\t\t\tchildList: true, \r\n\t\t\t\t\tcharacterData: false\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t// start the event stream\r\n\t\t\tvar observer = null;\r\n\t\t\tEventStream.call(\r\n\t\t\t\tthis, \r\n\t\t\t\tfunction connect(yieldEvent) { if(config) { observer=new MutationObserver(yieldEvent); observer.observe(target,config); target=null; config=null; } },\r\n\t\t\t\tfunction disconnect() { observer && observer.disconnect(); observer=null; },\r\n\t\t\t\tfunction reconnect() { observer.takeRecords(); }\r\n\t\t\t);\r\n\r\n\t\t}\r\n\t} else if(\"MutationEvent\" in window) {\r\n\t\tDOMUpdateEventStream = function DOMUpdateEventStream(options) {\r\n\t\t\tvar self=this;\r\n\r\n\t\t\t// flag that says whether the event is still observed or not\r\n\t\t\tvar scheduled = false;\r\n\t\t\t\r\n\t\t\t// configuration of the observer\r\n\t\t\tif(options) {\r\n\t\t\t\tvar target = \"target\" in options ? options.target : document.documentElement;\r\n\t\t\t} else {\r\n\t\t\t\tvar target = document.documentElement;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// handle the synchronous nature of mutation events\r\n\t\t\tvar yieldEvent=null;\r\n\t\t\tvar yieldEventDelayed = function() {\r\n\t\t\t\tif(scheduled || !yieldEventDelayed) return;\r\n\t\t\t\tdocument.removeEventListener(\"DOMContentLoaded\", yieldEventDelayed, false);\r\n\t\t\t\tdocument.removeEventListener(\"DOMContentLoaded\", yieldEventDelayed, false);\r\n\t\t\t\ttarget.removeEventListener(\"DOMSubtreeModified\", yieldEventDelayed, false);\r\n\t\t\t\tscheduled = requestAnimationFrame(yieldEvent);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// start the event stream\r\n\t\t\tEventStream.call(\r\n\t\t\t\tthis, \r\n\t\t\t\tfunction connect(newYieldEvent) {\r\n\t\t\t\t\tyieldEvent=newYieldEvent;\r\n\t\t\t\t\tdocument.addEventListener(\"DOMContentLoaded\", yieldEventDelayed, false);\r\n\t\t\t\t\ttarget.addEventListener(\"DOMSubtreeModified\", yieldEventDelayed, false);\r\n\t\t\t\t},\r\n\t\t\t\tfunction disconnect() { \r\n\t\t\t\t\tdocument.removeEventListener(\"DOMContentLoaded\", yieldEventDelayed, false);\r\n\t\t\t\t\ttarget.removeEventListener(\"DOMSubtreeModified\", yieldEventDelayed, false);\r\n\t\t\t\t\tcancelAnimationFrame(scheduled); yieldEventDelayed=null; yieldEvent=null; scheduled=false;\r\n\t\t\t\t},\r\n\t\t\t\tfunction reconnect(newYieldEvent) { \r\n\t\t\t\t\tyieldEvent=newYieldEvent; scheduled=false;\r\n\t\t\t\t\ttarget.addEventListener(\"DOMSubtreeModified\", yieldEventDelayed, false);\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t\t\r\n\t\t}\r\n\t} else {\r\n\t\tDOMUpdateEventStream = AnimationFrameEventStream;\r\n\t}\r\n\r\n\t///\r\n\t/// call a function every time the focus shifts\r\n\t///\r\n\tfunction FocusEventStream() {\r\n\t\tvar self=this;\r\n\t\t\r\n\t\t// handle the filtering nature of focus events\r\n\t\tvar yieldEvent=null; var previousActiveElement=null; var previousHasFocus=false; var rid=0;\r\n\t\tvar yieldEventDelayed = function() {\r\n\t\t\t\r\n\t\t\t// if the focus didn't change\r\n\t\t\tif(previousActiveElement==document.activeElement && previousHasFocus==document.hasFocus()) {\r\n\t\t\t\t\r\n\t\t\t\t// then do not generate an event\r\n\t\t\t\tsetTimeout(yieldEventDelayed, 333); // focus that didn't move is expected to stay\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// else, generate one & save config\r\n\t\t\t\tpreviousActiveElement=document.activeElement;\r\n\t\t\t\tpreviousHasFocus=document.hasFocus();\r\n\t\t\t\tyieldEvent();\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// start the event stream\r\n\t\tEventStream.call(\r\n\t\t\tthis, \r\n\t\t\tfunction connect(newYieldEvent) {\r\n\t\t\t\tyieldEvent=newYieldEvent;\r\n\t\t\t\trid=setTimeout(yieldEventDelayed, 500); // let the document load\r\n\t\t\t},\r\n\t\t\tfunction disconnect() { \r\n\t\t\t\tclearTimeout(rid); yieldEventDelayed=null; yieldEvent=null; rid=0;\r\n\t\t\t},\r\n\t\t\tfunction reconnect(newYieldEvent) { \r\n\t\t\t\tyieldEvent=newYieldEvent;\r\n\t\t\t\trid=setTimeout(yieldEventDelayed, 100); // focus by tab navigation moves fast\r\n\t\t\t}\r\n\t\t);\r\n\t\t\r\n\t}\r\n\r\n\t///\r\n\t/// composite event stream\r\n\t/// because sometimes you need more than one event source\r\n\t///\r\n\tfunction CompositeEventStream(stream1, stream2) {\r\n\t\tvar self=this;\r\n\t\t\r\n\t\t// fields\r\n\t\tvar yieldEvent=null; var s1=false, s2=false;\r\n\t\tvar yieldEventWrapper=function(s) { \r\n\t\t\tif(s==stream1) s1=true;\r\n\t\t\tif(s==stream2) s2=true;\r\n\t\t\tif(s1&&s2) return;\r\n\t\t\tyieldEvent(self);\r\n\t\t}\r\n\t\t\r\n\t\t// start the event stream\r\n\t\tEventStream.call(\r\n\t\t\tthis, \r\n\t\t\tfunction connect(newYieldEvent) {\r\n\t\t\t\tyieldEvent=newYieldEvent;\r\n\t\t\t\tstream1.schedule(yieldEventWrapper);\r\n\t\t\t\tstream2.schedule(yieldEventWrapper);\r\n\t\t\t},\r\n\t\t\tfunction disconnect() { \r\n\t\t\t\tstream1.dispose();\r\n\t\t\t\tstream2.dispose();\r\n\t\t\t},\r\n\t\t\tfunction reconnect(newYieldEvent) { \r\n\t\t\t\tyieldEvent=newYieldEvent;\r\n\t\t\t\ts1 && stream1.schedule(yieldEventWrapper);\r\n\t\t\t\ts2 && stream2.schedule(yieldEventWrapper);\r\n\t\t\t\ts1 = s2 = false;\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\t\r\n\treturn {\r\n\t\tEventStream:                EventStream,\r\n\t\tAnimationFrameEventStream:  AnimationFrameEventStream,\r\n\t\tTimeoutEventStream:         TimeoutEventStream,\r\n\t\tMouseEventStream:           MouseEventStream,\r\n\t\tMouseButtonEventStream:     MouseButtonEventStream,\r\n\t\tDOMUpdateEventStream:       DOMUpdateEventStream,\r\n\t\tFocusEventStream:           FocusEventStream,\r\n\t\tCompositeEventStream:       CompositeEventStream\r\n\t};\r\n\r\n})(window, document);\nrequire.define('src/core/dom-experimental-event-streams.js');","/////////////////////////////////////////////////////////////////\r\n////                                                         ////\r\n////                  Implementation of qSL                  ////\r\n////                                                         ////\r\n/////////////////////////////////////////////////////////////////\r\n////                                                         ////\r\n////   Please note that I require querySelectorAll to work   ////\r\n////                                                         ////\r\n////   See http://github.com/termi/CSS_selector_engine/      ////\r\n////   for a polyfill for older browsers                     ////\r\n////                                                         ////\r\n/////////////////////////////////////////////////////////////////\r\n\r\nmodule.exports = (function(window, document) { \"use strict\";\r\n\r\n\t// import dependencies\r\n\tvar eventStreams = require('src/core/dom-experimental-event-streams.js'),\r\n\t    DOMUpdateEventStream = eventStreams.DOMUpdateEventStream,\r\n\t\tAnimationFrameEventStream = eventStreams.AnimationFrameEventStream,\r\n\t\tCompositeEventStream = eventStreams.CompositeEventStream,\r\n\t\tFocusEventStream = eventStreams.FocusEventStream,\r\n\t\tMouseButtonEventStream = eventStreams.MouseButtonEventStream,\r\n\t\tTimeoutEventStream = eventStreams.TimeoutEventStream,\r\n\t\tMouseEventStream = eventStreams.MouseEventStream;\r\n\r\n\t///\r\n\t/// the live querySelectorAll implementation\r\n\t///\r\n\tfunction querySelectorLive(selector, handler, root) {\r\n\t\t\r\n\t\t// restrict the selector coverage to some part of the DOM only\r\n\t\tvar root = root || document;\r\n\t\t\r\n\t\t// TODO: make use of \"mutatedAncestorElement\" to update only elements inside the mutated zone\r\n\t\t\r\n\t\tvar currentElms = [];\r\n\t\tvar loop = function loop(eventStream) {\r\n\t\t\t\r\n\t\t\t// schedule next run\r\n\t\t\teventStream.schedule(loop);\r\n\t\t\t\r\n\t\t\t// update elements matching the selector\r\n\t\t\tvar newElms = [];\r\n\t\t\tvar oldElms = currentElms.slice(0);\r\n\t\t\tvar temps = root.querySelectorAll(selector);\r\n\t\t\tfor(var i=newElms.length=temps.length; i;) { newElms.push(temps[--i]); }\r\n\t\t\tcurrentElms = newElms.slice(0); temps=null;\r\n\t\t\t\r\n\t\t\t// first let's clear all elements that have been removed from the document\r\n\t\t\toldElms = oldElms.filter(function(e) {\r\n\t\t\t\t\r\n\t\t\t\t// check whether the current element is still there\r\n\t\t\t\tvar isStillInDocument = (\r\n\t\t\t\t\te===document.documentElement \r\n\t\t\t\t\t|| document.documentElement.contains(e)\r\n\t\t\t\t);\r\n\t\t\t\t\r\n\t\t\t\tif(isStillInDocument) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// NEED_COMPARE: we will compare this element to the new list\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// DELETE: raise onremoved, pop old elements\r\n\t\t\t\t\ttry { handler.onremoved && handler.onremoved(e); } catch(ex) { setImmediate(function() {throw ex})}\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\t// now pop and match until both lists are exhausted\r\n\t\t\t// (we use the fact the returned elements are in document order)\r\n\t\t\tvar el1 = oldElms.pop();\r\n\t\t\tvar el2 = newElms.pop();\r\n\t\t\twhile(el1 || el2) {\r\n\t\t\t\tif(el1===el2) {\r\n\t\t\t\t\r\n\t\t\t\t\t// MATCH: pop both elements\r\n\t\t\t\t\tel1 = oldElms.pop();\r\n\t\t\t\t\tel2 = newElms.pop();\r\n\t\t\t\t\t\r\n\t\t\t\t} else if (el2 && /*el1 is after el2*/(!el1||(el2.compareDocumentPosition(el1) & (1|2|8|32))===0)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// INSERT: raise onadded, pop new elements\r\n\t\t\t\t\ttry { handler.onadded && handler.onadded(el2); } catch(ex) { setImmediate(function() {throw ex})}\r\n\t\t\t\t\tel2 = newElms.pop();\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t\t// DELETE: raise onremoved, pop old elements\r\n\t\t\t\t\ttry { handler.onremoved && handler.onremoved(el1); } catch(ex) { setImmediate(function() {throw ex})}\r\n\t\t\t\t\tel1 = oldElms.pop();\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t};\r\n\t\t\r\n\t\t// use the event stream that best matches our needs\r\n\t\tvar simpleSelector = selector.replace(/:(dir|lang|root|empty|blank|nth-child|nth-last-child|first-child|last-child|only-child|nth-of-type|nth-last-of-child|fist-of-type|last-of-type|only-of-type|not|matches|default)\\b/gi,'')\r\n\t\tvar eventStream; if(simpleSelector.indexOf(':') == -1) {\r\n\t\t\t\r\n\t\t\t// static stuff only\r\n\t\t\teventStream = new DOMUpdateEventStream({target:root}); \r\n\t\t\t\r\n\t\t} else {\r\n\t\t\t\r\n\t\t\t// dynamic stuff too\r\n\t\t\teventStream = new DOMUpdateEventStream({target:root}); \r\n\t\t\tif(DOMUpdateEventStream != AnimationFrameEventStream) {\r\n\t\t\t\r\n\t\t\t\t// detect the presence of focus-related pseudo-classes\r\n\t\t\t\tvar reg = /:(focus|active)\\b/gi;\r\n\t\t\t\tif(reg.test(simpleSelector)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// mouse events should be listened\r\n\t\t\t\t\teventStream = new CompositeEventStream(\r\n\t\t\t\t\t\tnew FocusEventStream(),\r\n\t\t\t\t\t\teventStream\r\n\t\t\t\t\t);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// simplify simpleSelector\r\n\t\t\t\t\tvar reg = /:(focus)\\b/gi;\r\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, ''); // :active has other hooks\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// detect the presence of mouse-button-related pseudo-classes\r\n\t\t\t\tvar reg = /:(active)\\b/gi;\r\n\t\t\t\tif(reg.test(simpleSelector)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// mouse events should be listened\r\n\t\t\t\t\teventStream = new CompositeEventStream(\r\n\t\t\t\t\t\tnew MouseButtonEventStream(),\r\n\t\t\t\t\t\teventStream\r\n\t\t\t\t\t);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// simplify simpleSelector\r\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// detect the presence of user input pseudo-classes\r\n\t\t\t\tvar reg = /:(target|checked|indeterminate|valid|invalid|in-range|out-of-range|user-error)\\b/gi;\r\n\t\t\t\tif(reg.test(simpleSelector)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// slowly dynamic stuff do happen\r\n\t\t\t\t\teventStream = new CompositeEventStream(\r\n\t\t\t\t\t\tnew TimeoutEventStream(250),\r\n\t\t\t\t\t\teventStream\r\n\t\t\t\t\t);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// simplify simpleSelector\r\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\r\n\r\n\t\t\t\t\tvar reg = /:(any-link|link|visited|local-link|enabled|disabled|read-only|read-write|required|optional)\\b/gi;\r\n\t\t\t\t\t// simplify simpleSelector\r\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// detect the presence of nearly-static pseudo-classes\r\n\t\t\t\tvar reg = /:(any-link|link|visited|local-link|enabled|disabled|read-only|read-write|required|optional)\\b/gi;\r\n\t\t\t\tif(reg.test(simpleSelector)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// nearly static stuff do happen\r\n\t\t\t\t\teventStream = new CompositeEventStream(\r\n\t\t\t\t\t\tnew TimeoutEventStream(333),\r\n\t\t\t\t\t\teventStream\r\n\t\t\t\t\t);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// simplify simpleSelector\r\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// detect the presence of mouse-related pseudo-classes\r\n\t\t\t\tvar reg = /:(hover)\\b/gi;\r\n\t\t\t\tif(reg.test(simpleSelector)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// mouse events should be listened\r\n\t\t\t\t\teventStream = new CompositeEventStream(\r\n\t\t\t\t\t\tnew MouseEventStream(),\r\n\t\t\t\t\t\teventStream\r\n\t\t\t\t\t);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// simplify simpleSelector\r\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// detect the presence of unknown pseudo-classes\r\n\t\t\t\tif(simpleSelector.indexOf(':') !== -1) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// other stuff do happen, too (let's give up on events)\r\n\t\t\t\t\teventStream = new AnimationFrameEventStream(); \r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t// start handling changes\r\n\t\tloop(eventStream);\r\n\t\t\r\n\t}\r\n\t\r\n\treturn querySelectorLive;\r\n\t\r\n})(window, document);\nrequire.define('src/core/dom-query-selector-live.js');","// TODO: comment about the 'no_auto_stylesheet_detection' flag?\r\n\r\nmodule.exports = (function(window, document) { \"use strict\";\r\n\t\r\n\t// import dependencies\r\n\trequire('src/core/polyfill-dom-console.js');\r\n\trequire('src/core/polyfill-dom-requestAnimationFrame.js');\r\n\tvar cssSyntax = require('src/core/css-syntax.js');\r\n\tvar domEvents = require('src/core/dom-events.js');\r\n\tvar querySelectorLive = require('src/core/dom-query-selector-live.js');\r\n\t\r\n\t// define the module\r\n\tvar cssCascade = {\r\n\t\t\r\n\t\t//\r\n\t\t// returns the priority of a unique selector (NO COMMA!)\r\n\t\t// { the return value is an integer, with the same formula as webkit }\r\n\t\t//\r\n\t\tcomputeSelectorPriorityOf: function computeSelectorPriorityOf(selector) {\r\n\t\t\tif(typeof selector == \"string\") selector = cssSyntax.parse(selector.trim()+\"{}\").value[0].selector;\r\n\t\t\t\r\n\t\t\tvar numberOfIDs = 0;\r\n\t\t\tvar numberOfClasses = 0;\r\n\t\t\tvar numberOfTags = 0;\r\n\t\t\t\r\n\t\t\t// TODO: improve this parser, or find one on the web\r\n\t\t\tfor(var i = 0; i < selector.length; i++) {\r\n\t\t\t\t\r\n\t\t\t\tif(selector[i] instanceof cssSyntax.IdentifierToken) {\r\n\t\t\t\t\tnumberOfTags++;\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(selector[i] instanceof cssSyntax.DelimToken) {\r\n\t\t\t\t\tif(selector[i].value==\".\") {\r\n\t\t\t\t\t\tnumberOfClasses++; i++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(selector[i] instanceof cssSyntax.ColonToken) {\r\n\t\t\t\t\tif(selector[++i] instanceof cssSyntax.ColonToken) {\r\n\t\t\t\t\t\tnumberOfTags++; i++;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else if((selector[i] instanceof cssSyntax.Func) && (/^(not|matches)$/i).test(selector[i].name)) {\r\n\t\t\t\t\t\tvar nestedPriority = this.computeSelectorPriorityOf(selector[i].value);\r\n\t\t\t\t\t\tnumberOfTags += nestedPriority % 256; nestedPriority /= 256;\r\n\t\t\t\t\t\tnumberOfClasses += nestedPriority % 256; nestedPriority /= 256;\r\n\t\t\t\t\t\tnumberOfIDs += nestedPriority;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tnumberOfClasses++;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(selector[i] instanceof cssSyntax.SimpleBlock) {\r\n\t\t\t\t\tif(selector[i].name==\"[\") {\r\n\t\t\t\t\t\tnumberOfClasses++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(selector[i] instanceof cssSyntax.HashToken) {\r\n\t\t\t\t\tnumberOfIDs++;\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// TODO: stop ignoring unknown symbols?\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(numberOfIDs>255) numberOfIDs=255;\r\n\t\t\tif(numberOfClasses>255) numberOfClasses=255;\r\n\t\t\tif(numberOfTags>255) numberOfTags=255;\r\n\t\t\t\r\n\t\t\treturn ((numberOfIDs*256)+numberOfClasses)*256+numberOfTags;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// returns an array of the css rules matching an element\r\n\t\t//\r\n\t\tfindAllMatchingRules: function findAllMatchingRules(element) {\r\n\t\t\treturn this.findAllMatchingRulesWithPseudo(element);\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// returns an array of the css rules matching a pseudo-element\r\n\t\t//\r\n\t\tfindAllMatchingRulesWithPseudo: function findAllMatchingRules(element,pseudo) {\r\n\t\t\tpseudo = pseudo ? (''+pseudo).toLowerCase() : pseudo;\r\n\t\t\t\r\n\t\t\t// let's look for new results if needed...\r\n\t\t\tvar results = [];\r\n\t\t\t\r\n\t\t\t// walk the whole stylesheet...\r\n\t\t\tvar visit = function(rules) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tfor(var r = rules.length; r--; ) {\r\n\t\t\t\t\t\tvar rule = rules[r]; \r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// media queries hook\r\n\t\t\t\t\t\tif(rule.disabled) continue;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif(rule instanceof cssSyntax.StyleRule) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// consider each selector independently\r\n\t\t\t\t\t\t\tvar subrules = rule.subRules || cssCascade.splitRule(rule);\r\n\t\t\t\t\t\t\tfor(var sr = subrules.length; sr--; ) {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tvar selector = subrules[sr].selector.toCSSString().replace(/ *(\\/\\*\\*\\/|  ) */g,' ').trim();\r\n\t\t\t\t\t\t\t\tif(pseudo) {\r\n\t\t\t\t\t\t\t\t\t// WE ONLY ACCEPT SELECTORS ENDING WITH THE PSEUDO\r\n\t\t\t\t\t\t\t\t\tvar selectorLow = selector.toLowerCase();\r\n\t\t\t\t\t\t\t\t\tvar newLength = selector.length-pseudo.length-1;\r\n\t\t\t\t\t\t\t\t\tif(newLength<=0) continue;\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tif(selectorLow.lastIndexOf('::'+pseudo)==newLength-1) {\r\n\t\t\t\t\t\t\t\t\t\tselector = selector.substr(0,newLength-1);\r\n\t\t\t\t\t\t\t\t\t} else if(selectorLow.lastIndexOf(':'+pseudo)==newLength) {\r\n\t\t\t\t\t\t\t\t\t\tselector = selector.substr(0,newLength);\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// fix selectors like \"#element > :first-child ~ ::before\"\r\n\t\t\t\t\t\t\t\t\tif(selector.trim().length == 0) { selector = '*' }\r\n\t\t\t\t\t\t\t\t\telse if(selector[selector.length-1] == ' ') { selector += '*' }\r\n\t\t\t\t\t\t\t\t\telse if(selector[selector.length-1] == '+') { selector += '*' }\r\n\t\t\t\t\t\t\t\t\telse if(selector[selector.length-1] == '>') { selector += '*' }\r\n\t\t\t\t\t\t\t\t\telse if(selector[selector.length-1] == '~') { selector += '*' }\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// look if the selector matches\r\n\t\t\t\t\t\t\t\tvar isMatching = false;\r\n\t\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t\tif(element.matches) isMatching=element.matches(selector)\r\n\t\t\t\t\t\t\t\t\telse if(element.matchesSelector) isMatching=element.matchesSelector(selector)\r\n\t\t\t\t\t\t\t\t\telse if(element.oMatchesSelector) isMatching=element.oMatchesSelector(selector)\r\n\t\t\t\t\t\t\t\t\telse if(element.msMatchesSelector) isMatching=element.msMatchesSelector(selector)\r\n\t\t\t\t\t\t\t\t\telse if(element.mozMatchesSelector) isMatching=element.mozMatchesSelector(selector)\r\n\t\t\t\t\t\t\t\t\telse if(element.webkitMatchesSelector) isMatching=element.webkitMatchesSelector(selector)\r\n\t\t\t\t\t\t\t\t\telse { throw new Error(\"no element.matches?\") }\r\n\t\t\t\t\t\t\t\t} catch(ex) { debugger; setImmediate(function() { throw ex; }) }\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// if yes, add it to the list of matched selectors\r\n\t\t\t\t\t\t\t\tif(isMatching) { results.push(subrules[sr]); }\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t} else if(rule instanceof cssSyntax.AtRule && rule.name==\"media\") {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// visit them\r\n\t\t\t\t\t\t\tvisit(rule.toStylesheet().value);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (ex) {\r\n\t\t\t\t\tsetImmediate(function() { throw ex; });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor(var s=cssCascade.stylesheets.length; s--; ) {\r\n\t\t\t\tvar rules = cssCascade.stylesheets[s];\r\n\t\t\t\tvisit(rules);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn results;\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// a list of all properties supported by the current browser\r\n\t\t//\r\n\t\tallCSSProperties: null,\r\n\t\tgetAllCSSProperties: function getAllCSSProperties() {\r\n\t\t\t\r\n\t\t\tif(this.allCSSProperties) return this.allCSSProperties;\r\n\t\t\t\r\n\t\t\t// get all claimed properties\r\n\t\t\tvar s = getComputedStyle(document.documentElement); var ps = new Array(s.length);\r\n\t\t\tfor(var i=s.length; i--; ) {\r\n\t\t\t\tps[i] = s[i];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// FIX A BUG WHERE WEBKIT DOESN'T REPORT ALL PROPERTIES\r\n\t\t\tif(ps.indexOf('content')==-1) {ps.push('content');}\r\n\t\t\tif(ps.indexOf('counter-reset')==-1) {\r\n\t\t\t\t\r\n\t\t\t\tps.push('counter-reset');\r\n\t\t\t\tps.push('counter-increment');\r\n\t\t\t\t\r\n\t\t\t\t// FIX A BUG WHERE WEBKIT RETURNS SHIT FOR THE COMPUTED VALUE OF COUNTER-RESET\r\n\t\t\t\tcssCascade.computationUnsafeProperties['counter-reset']=true;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// save in a cache for faster access the next times\r\n\t\t\treturn this.allCSSProperties = ps;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t// \r\n\t\t// those properties are not safe for computation->specified round-tripping\r\n\t\t// \r\n\t\tcomputationUnsafeProperties: {\r\n\t\t\t\"bottom\"          : true,\r\n\t\t\t\"direction\"       : true,\r\n\t\t\t\"display\"         : true,\r\n\t\t\t\"font-size\"       : true,\r\n\t\t\t\"height\"          : true,\r\n\t\t\t\"left\"            : true,\r\n\t\t\t\"line-height\"     : true,\r\n\t\t\t\"margin-left\"     : true,\r\n\t\t\t\"margin-right\"    : true,\r\n\t\t\t\"margin-bottom\"   : true,\r\n\t\t\t\"margin-top\"      : true,\r\n\t\t\t\"max-height\"      : true,\r\n\t\t\t\"max-width\"       : true,\r\n\t\t\t\"min-height\"      : true,\r\n\t\t\t\"min-width\"       : true,\r\n\t\t\t\"padding-left\"    : true,\r\n\t\t\t\"padding-right\"   : true,\r\n\t\t\t\"padding-bottom\"  : true,\r\n\t\t\t\"padding-top\"     : true,\r\n\t\t\t\"right\"           : true,\r\n\t\t\t\"text-align\"      : true,\r\n\t\t\t\"text-align-last\" : true,\r\n\t\t\t\"top\"             : true,\r\n\t\t\t\"width\"           : true,\r\n\t\t\t__proto__         : null,\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// a list of property we should inherit...\r\n\t\t//\r\n\t\tinheritingProperties: {\r\n\t\t\t\"border-collapse\"       : true,\r\n\t\t\t\"border-spacing\"        : true,\r\n\t\t\t\"caption-side\"          : true,\r\n\t\t\t\"color\"                 : true,\r\n\t\t\t\"cursor\"                : true,\r\n\t\t\t\"direction\"             : true,\r\n\t\t\t\"empty-cells\"           : true,\r\n\t\t\t\"font-family\"           : true,\r\n\t\t\t\"font-size\"             : true,\r\n\t\t\t\"font-style\"            : true,\r\n\t\t\t\"font-variant\"          : true,\r\n\t\t\t\"font-weight\"           : true,\r\n\t\t\t\"font\"                  : true,\r\n\t\t\t\"letter-spacing\"        : true,\r\n\t\t\t\"line-height\"           : true,\r\n\t\t\t\"list-style-image\"      : true,\r\n\t\t\t\"list-style-position\"   : true,\r\n\t\t\t\"list-style-type\"       : true,\r\n\t\t\t\"list-style\"            : true,\r\n\t\t\t\"orphans\"               : true,\r\n\t\t\t\"quotes\"                : true,\r\n\t\t\t\"text-align\"            : true,\r\n\t\t\t\"text-indent\"           : true,\r\n\t\t\t\"text-transform\"        : true,\r\n\t\t\t\"visibility\"            : true,\r\n\t\t\t\"white-space\"           : true,\r\n\t\t\t\"widows\"                : true,\r\n\t\t\t\"word-break\"            : true,\r\n\t\t\t\"word-spacing\"          : true,\r\n\t\t\t\"word-wrap\"             : true,\r\n\t\t\t__proto__               : null,\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// returns the default style for a tag\r\n\t\t//\r\n\t\tdefaultStylesForTag: Object.create ? Object.create(null) : {},\r\n\t\tgetDefaultStyleForTag: function getDefaultStyleForTag(tagName) {\r\n\t\t\t\r\n\t\t\t// get result from cache\r\n\t\t\tvar result = this.defaultStylesForTag[tagName];\r\n\t\t\tif(result) return result;\r\n\t\t\t\r\n\t\t\t// create dummy virtual element\r\n\t\t\tvar element = document.createElement(tagName);\r\n\t\t\tvar style = this.defaultStylesForTag[tagName] = getComputedStyle(element);\r\n\t\t\tif(style.display) return style;\r\n\t\t\t\r\n\t\t\t// webkit fix: insert the dummy element anywhere (head -> display:none)\r\n\t\t\tdocument.head.insertBefore(element, document.head.firstChild);\r\n\t\t\treturn style;\r\n\t\t},\r\n\t\t\r\n\t\t// \r\n\t\t// returns the specified style of an element. \r\n\t\t// REMARK: may or may not unwrap \"inherit\" and \"initial\" depending on implementation\r\n\t\t// REMARK: giving \"matchedRules\" as a parameter allow you to mutualize the \"findAllMatching\" rules calls\r\n\t\t// \r\n\t\tgetSpecifiedStyle: function getSpecifiedStyle(element, cssPropertyName, matchedRules) {\r\n\t\t\t\r\n\t\t\t// hook for css regions\r\n\t\t\tvar fragmentSource;\r\n\t\t\tif(fragmentSource=element.getAttribute('data-css-regions-fragment-of')) {\r\n\t\t\t\tfragmentSource = document.querySelector('[data-css-regions-fragment-source=\"'+fragmentSource+'\"]');\r\n\t\t\t\tif(fragmentSource) return cssCascade.getSpecifiedStyle(fragmentSource, cssPropertyName);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// give IE a thumbs up for this!\r\n\t\t\tif(element.currentStyle && !window.opera) {\r\n\t\t\t\t\r\n\t\t\t\t// ask IE to manage the style himself...\r\n\t\t\t\tvar bestValue = element.myStyle[cssPropertyName] || element.currentStyle[cssPropertyName] || '';\r\n\t\t\t\t\r\n\t\t\t\t// return a parsed representation of the value\r\n\t\t\t\treturn cssSyntax.parseAListOfComponentValues(bestValue);\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// TODO: support the \"initial\" and \"inherit\" things?\r\n\t\t\t\t\r\n\t\t\t\t// first, let's try inline style as it's fast and generally accurate\r\n\t\t\t\t// TODO: what if important rules override that?\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif(bestValue = element.style.getPropertyValue(cssPropertyName) || element.myStyle[cssPropertyName]) {\r\n\t\t\t\t\t\treturn cssSyntax.parseAListOfComponentValues(bestValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch(ex) {}\r\n\t\t\t\t\r\n\t\t\t\t// find all relevant style rules\r\n\t\t\t\tvar isBestImportant=false; var bestPriority = 0; var bestValue = new cssSyntax.TokenList();\r\n\t\t\t\tvar rules = matchedRules || (\r\n\t\t\t\t\tcssPropertyName in cssCascade.monitoredProperties\r\n\t\t\t\t\t? element.myMatchedRules || []\r\n\t\t\t\t\t: cssCascade.findAllMatchingRules(element)\r\n\t\t\t\t);\r\n\t\t\t\t\r\n\t\t\t\tvar visit = function(rules) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tfor(var i=rules.length; i--; ) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// media queries hook\r\n\t\t\t\t\t\tif(rules[i].disabled) continue;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// find a relevant declaration\r\n\t\t\t\t\t\tif(rules[i] instanceof cssSyntax.StyleRule) {\r\n\t\t\t\t\t\t\tvar decls = rules[i].getDeclarations();\r\n\t\t\t\t\t\t\tfor(var j=decls.length-1; j>=0; j--) {\r\n\t\t\t\t\t\t\t\tif(decls[j].type==\"DECLARATION\") {\r\n\t\t\t\t\t\t\t\t\tif(decls[j].name==cssPropertyName) {\r\n\t\t\t\t\t\t\t\t\t\t// only works if selectors containing a \",\" are deduplicated\r\n\t\t\t\t\t\t\t\t\t\tvar currentPriority = cssCascade.computeSelectorPriorityOf(rules[i].selector);\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\tif(isBestImportant) {\r\n\t\t\t\t\t\t\t\t\t\t\t// only an important declaration can beat another important declaration\r\n\t\t\t\t\t\t\t\t\t\t\tif(decls[j].important) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tif(currentPriority >= bestPriority) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tbestPriority = currentPriority;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tbestValue = decls[j].value;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t// an important declaration beats any non-important declaration\r\n\t\t\t\t\t\t\t\t\t\t\tif(decls[j].important) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tisBestImportant = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\tbestPriority = currentPriority;\r\n\t\t\t\t\t\t\t\t\t\t\t\tbestValue = decls[j].value;\r\n\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\t// the selector priority has to be higher otherwise\r\n\t\t\t\t\t\t\t\t\t\t\t\tif(currentPriority >= bestPriority) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tbestPriority = currentPriority;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tbestValue = decls[j].value;\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if((rules[i] instanceof cssSyntax.AtRule) && (rules[i].name==\"media\")) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// visit them\r\n\t\t\t\t\t\t\tvisit(rules[i].toStylesheet())\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tvisit(rules);\r\n\t\t\t\t\r\n\t\t\t\t// return our best guess...\r\n\t\t\t\treturn bestValue||null;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t\r\n\t\t//\r\n\t\t// start monitoring a new stylesheet\r\n\t\t// (should usually not be used because stylesheets load automatically)\r\n\t\t//\r\n\t\tstylesheets: [],\r\n\t\tloadStyleSheet: function loadStyleSheet(cssText,i) {\r\n\t\t\t\r\n\t\t\t// load in order\r\n\t\t\t\r\n\t\t\t// parse the stylesheet content\r\n\t\t\tvar rules = cssSyntax.parse(cssText).value;\r\n\t\t\t\r\n\t\t\t// add the stylesheet into the object model\r\n\t\t\tif(typeof(i)!==\"undefined\") { cssCascade.stylesheets[i]=rules; } \r\n\t\t\telse { i=cssCascade.stylesheets.push(rules);}\r\n\t\t\t\r\n\t\t\t// make sure to monitor the required rules\r\n\t\t\tcssCascade.startMonitoringStylesheet(rules)\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// start monitoring a new stylesheet\r\n\t\t// (should usually not be used because stylesheets load automatically)\r\n\t\t//\r\n\t\tloadStyleSheetTag: function loadStyleSheetTag(stylesheet,i) {\r\n\t\t\t\r\n\t\t\tif(stylesheet.hasAttribute('data-css-polyfilled')) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif(stylesheet.tagName=='LINK') {\r\n\t\t\t\t\r\n\t\t\t\t// oh, no, we have to download it...\r\n\t\t\t\ttry {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// dummy value in-between\r\n\t\t\t\t\tcssCascade.stylesheets[i] = new cssSyntax.TokenList();\r\n\t\t\t\t\t\r\n\t\t\t\t\t//\r\n\t\t\t\t\tvar xhr = new XMLHttpRequest(); xhr.href = stylesheet.href;\r\n\t\t\t\t\txhr.open('GET',stylesheet.href,true); xhr.ruleIndex = i; \r\n\t\t\t\t\txhr.onreadystatechange = function() {\r\n\t\t\t\t\t\tif(this.readyState==4) { \r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// status 0 is a webkit bug for local files\r\n\t\t\t\t\t\t\tif(this.status==200||this.status==0) {\r\n\t\t\t\t\t\t\t\tcssCascade.loadStyleSheet(this.responseText,this.ruleIndex)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tcssConsole.log(\"css-cascade polyfill failled to load: \" + this.href);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t};\r\n\t\t\t\t\txhr.send();\r\n\t\t\t\t\t\r\n\t\t\t\t} catch(ex) {\r\n\t\t\t\t\tcssConsole.log(\"css-cascade polyfill failled to load: \" + stylesheet.href);\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// oh, cool, we just have to parse the content!\r\n\t\t\t\tcssCascade.loadStyleSheet(stylesheet.textContent,i);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// mark the stylesheet as ok\r\n\t\t\tstylesheet.setAttribute('data-css-polyfilled',true);\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// calling this function will load all currently existing stylesheets in the document\r\n\t\t// (should usually not be used because stylesheets load automatically)\r\n\t\t//\r\n\t\tselectorForStylesheets: \"style:not([data-no-css-polyfill]):not([data-css-polyfilled]), link[rel=stylesheet]:not([data-no-css-polyfill]):not([data-css-polyfilled])\",\r\n\t\tloadAllStyleSheets: function loadAllStyleSheets() {\r\n\t\t\t\r\n\t\t\t// for all stylesheets in the <head> tag...\r\n\t\t\tvar head = document.head || document.documentElement;\r\n\t\t\tvar stylesheets = head.querySelectorAll(cssCascade.selectorForStylesheets);\r\n\t\t\t\r\n\t\t\tvar intialLength = this.stylesheets.length;\r\n\t\t\tthis.stylesheets.length += stylesheets.length\r\n\t\t\t\r\n\t\t\t// for all of them...\r\n\t\t\tfor(var i = stylesheets.length; i--;) {\r\n\t\t\t\t\r\n\t\t\t\t// \r\n\t\t\t\t// load the stylesheet\r\n\t\t\t\t// \r\n\t\t\t\tvar stylesheet = stylesheets[i]; \r\n\t\t\t\tcssCascade.loadStyleSheetTag(stylesheet,intialLength+i)\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// this is where we store event handlers for monitored properties\r\n\t\t//\r\n\t\tmonitoredProperties: Object.create ? Object.create(null) : {},\r\n\t\tmonitoredPropertiesHandler: {\r\n\t\t\tonupdate: function(element, rule) {\r\n\t\t\t\t\r\n\t\t\t\t// we need to find all regexps that matches\r\n\t\t\t\tvar mps = cssCascade.monitoredProperties;\r\n\t\t\t\tvar decls = rule.getDeclarations();\r\n\t\t\t\tfor(var j=decls.length-1; j>=0; j--) {\r\n\t\t\t\t\tif(decls[j].type==\"DECLARATION\") {\r\n\t\t\t\t\t\tif(decls[j].name in mps) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// call all handlers waiting for this\r\n\t\t\t\t\t\t\tvar hs = mps[decls[j].name];\r\n\t\t\t\t\t\t\tfor(var hi=hs.length; hi--;) {\r\n\t\t\t\t\t\t\t\ths[hi].onupdate(element,rule);\r\n\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// don't call twice\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// add an handler to some properties (aka fire when their value *MAY* be affected)\r\n\t\t// REMARK: because this event does not promise the value changed, you may want to figure it out before relayouting\r\n\t\t//\r\n\t\tstartMonitoringProperties: function startMonitoringProperties(properties, handler) {\r\n\t\t\t\r\n\t\t\tfor(var i=properties.length; i--; ) {\r\n\t\t\t\tvar property = properties[i];\r\n\t\t\t\tvar handlers = (\r\n\t\t\t\t\tcssCascade.monitoredProperties[property]\r\n\t\t\t\t\t|| (cssCascade.monitoredProperties[property] = [])\r\n\t\t\t\t);\r\n\t\t\t\thandlers.push(handler)\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor(var s=0; s<cssCascade.stylesheets.length; s++) {\r\n\t\t\t\tvar currentStylesheet = cssCascade.stylesheets[s];\r\n\t\t\t\tcssCascade.startMonitoringStylesheet(currentStylesheet);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// calling this function will detect monitored rules in the stylesheet\r\n\t\t// (should usually not be used because stylesheets load automatically)\r\n\t\t//\r\n\t\tstartMonitoringStylesheet: function startMonitoringStylesheet(rules) {\r\n\t\t\tfor(var i=0; i<rules.length; i++) {\r\n\t\t\t\t\r\n\t\t\t\t// only consider style rules\r\n\t\t\t\tif(rules[i] instanceof cssSyntax.StyleRule) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// try to see if the current rule is worth monitoring\r\n\t\t\t\t\tif(rules[i].isMonitored) continue;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// for that, let's see if we can find a declaration we should watch\r\n\t\t\t\t\tvar decls = rules[i].getDeclarations();\r\n\t\t\t\t\tfor(var j=decls.length-1; j>=0; j--) {\r\n\t\t\t\t\t\tif(decls[j].type==\"DECLARATION\") {\r\n\t\t\t\t\t\t\tif(decls[j].name in cssCascade.monitoredProperties) {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// if we found some, start monitoring\r\n\t\t\t\t\t\t\t\tcssCascade.startMonitoringRule(rules[i]);\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else if(rules[i] instanceof cssSyntax.AtRule) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// handle @media\r\n\t\t\t\t\tif(rules[i].name == \"media\" && window.matchMedia) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tcssCascade.startMonitoringMedia(rules[i]);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// calling this function will detect media query updates and fire events accordingly\r\n\t\t// (should usually not be used because stylesheets load automatically)\r\n\t\t//\r\n\t\tstartMonitoringMedia: function startMonitoringMedia(atrule) {\r\n\t\t\ttry {\r\n\t\t\t\t\r\n\t\t\t\tvar media = window.matchMedia(atrule.prelude.toCSSString());\r\n\t\t\t\t\r\n\t\t\t\t// update all the rules when needed\r\n\t\t\t\tvar rules = atrule.toStylesheet().value;\r\n\t\t\t\tcssCascade.updateMedia(rules, !media.matches, false);\r\n\t\t\t\tmedia.addListener(\r\n\t\t\t\t\tfunction(newMedia) { cssCascade.updateMedia(rules, !newMedia.matches, true); }\r\n\t\t\t\t);\r\n\t\t\t\t\r\n\t\t\t\t// it seems I like taking risks...\r\n\t\t\t\tcssCascade.startMonitoringStylesheet(rules);\r\n\t\t\t\t\r\n\t\t\t} catch(ex) {\r\n\t\t\t\tsetImmediate(function() { throw ex; })\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// define what happens when a media query status changes\r\n\t\t//\r\n\t\tupdateMedia: function(rules,disabled,update) {\r\n\t\t\tfor(var i=rules.length; i--; ) {\r\n\t\t\t\trules[i].disabled = disabled;\r\n\t\t\t\t// TODO: should probably get handled by a setter on the rule...\r\n\t\t\t\tvar sr = rules[i].subRules;\r\n\t\t\t\tif(sr) {\r\n\t\t\t\t\tfor(var j=sr.length; j--; ) {\r\n\t\t\t\t\t\tsr[j].disabled = disabled;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// in case of update, all elements matching the selector went potentially updated...\r\n\t\t\tif(update) {\r\n\t\t\t\tfor(var i=rules.length; i--; ) {\r\n\t\t\t\t\tvar els = document.querySelectorAll(rules[i].selector.toCSSString());\r\n\t\t\t\t\tfor(var j=els.length; j--; ) {\r\n\t\t\t\t\t\tcssCascade.monitoredPropertiesHandler.onupdate(els[j],rules[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t// \r\n\t\t// splits a rule if it has multiple selectors\r\n\t\t// \r\n\t\tsplitRule: function splitRule(rule) {\r\n\t\t\t\r\n\t\t\t// create an array for all the subrules\r\n\t\t\tvar rules = [];\r\n\t\t\t\r\n\t\t\t// fill the array\r\n\t\t\tvar currentRule = new cssSyntax.StyleRule(); currentRule.disabled=rule.disabled;\r\n\t\t\tfor(var i=0; i<rule.selector.length; i++) {\r\n\t\t\t\tif(rule.selector[i] instanceof cssSyntax.DelimToken && rule.selector[i].value==\",\") {\r\n\t\t\t\t\tcurrentRule.value = rule.value; rules.push(currentRule);\r\n\t\t\t\t\tcurrentRule = new cssSyntax.StyleRule(); currentRule.disabled=rule.disabled;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tcurrentRule.selector.push(rule.selector[i])\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcurrentRule.value = rule.value; rules.push(currentRule);\r\n\t\t\t\r\n\t\t\t// save the result of the split as subrules\r\n\t\t\treturn rule.subRules = rules;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t// \r\n\t\t// ask the css-selector implementation to notify changes for the rules\r\n\t\t// \r\n\t\tstartMonitoringRule: function startMonitoringRule(rule) {\r\n\t\t\t\r\n\t\t\t// avoid monitoring rules twice\r\n\t\t\tif(!rule.isMonitored) { rule.isMonitored=true } else { return; }\r\n\t\t\t\r\n\t\t\t// split the rule if it has multiple selectors\r\n\t\t\tvar rules = rule.subRules || cssCascade.splitRule(rule);\r\n\t\t\t\r\n\t\t\t// monitor the rules\r\n\t\t\tfor(var i=0; i<rules.length; i++) {\r\n\t\t\t\trule = rules[i];\r\n\t\t\t\tquerySelectorLive(rule.selector.toCSSString(), {\r\n\t\t\t\t\tonadded: function(e) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// add the rule to the matching list of this element\r\n\t\t\t\t\t\t(e.myMatchedRules = e.myMatchedRules || []).unshift(rule); // TODO: does not respect priority order\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// generate an update event\r\n\t\t\t\t\t\tcssCascade.monitoredPropertiesHandler.onupdate(e, rule);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t},\r\n\t\t\t\t\tonremoved: function(e) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// remove the rule from the matching list of this element\r\n\t\t\t\t\t\tif(e.myMatchedRules) e.myMatchedRules.splice(e.myMatchedRules.indexOf(rule), 1);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// generate an update event\r\n\t\t\t\t\t\tcssCascade.monitoredPropertiesHandler.onupdate(e, rule);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// converts a css property name to a javascript name\r\n\t\t//\r\n\t\ttoCamelCase: function toCamelCase(variable) { \r\n\t\t\treturn variable.replace(\r\n\t\t\t\t/-([a-z])/g, \r\n\t\t\t\tfunction(str,letter) { \r\n\t\t\t\t\treturn letter.toUpperCase();\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// add some magic code to support properties on the style interface\r\n\t\t//\r\n\t\tpolyfillStyleInterface: function(cssPropertyName) {\r\n\t\t\t\r\n\t\t\tvar prop = {\r\n\t\t\t\t\r\n\t\t\t\tget: function() {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// check we know which element we work on\r\n\t\t\t\t\ttry { if(!this.parentElement) throw new Error(\"Please use the anHTMLElement.myStyle property to get polyfilled properties\") }\r\n\t\t\t\t\tcatch(ex) { setImmediate(function() { throw ex; }); return ''; }\r\n\t\t\t\t\t\r\n\t\t\t\t\ttry { \r\n\t\t\t\t\t\t// non-computed style: return the local style of the element\r\n\t\t\t\t\t\tthis.clip = (this.clip===undefined?'':this.clip);\r\n\t\t\t\t\t\treturn this.parentElement.getAttribute('data-style-'+cssPropertyName);\r\n\t\t\t\t\t} catch (ex) {\r\n\t\t\t\t\t\t// computed style: return the specified style of the element\r\n\t\t\t\t\t\tvar value = cssCascade.getSpecifiedStyle(this.parentElement, cssPropertyName, undefined, true);\r\n\t\t\t\t\t\treturn value && value.length>0 ? value.toCSSString() : '';\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t},\r\n\t\t\t\t\r\n\t\t\t\tset: function(v) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// check that the style is writable\r\n\t\t\t\t\tthis.clip = (this.clip===undefined?'':this.clip);\r\n\r\n\t\t\t\t\t// check we know which element we work on\r\n\t\t\t\t\ttry { if(!this.parentElement) throw new Error(\"Please use the anHTMLElement.myStyle property to set polyfilled properties\") }\r\n\t\t\t\t\tcatch(ex) { setImmediate(function() { throw ex; }); return; }\r\n\t\t\t\t\t\r\n\t\t\t\t\t// modify the local style of the element\r\n\t\t\t\t\tif(this.parentElement.getAttribute('data-style-'+cssPropertyName) != v) {\r\n\t\t\t\t\t\tthis.parentElement.setAttribute('data-style-'+cssPropertyName,v);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\tvar styleProtos = [];\r\n\t\t\ttry { styleProtos.push(Object.getPrototypeOf(document.documentElement.style) || CSSStyleDeclaration); } catch (ex) {}\r\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(getComputedStyle(document.documentElement))); } catch (ex) {}\r\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.currentStyle)); } catch (ex) {}\r\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.runtimeStyle)); } catch (ex) {}\r\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.specifiedStyle)); } catch (ex) {}\r\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.cascadedStyle)); } catch (ex) {}\r\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.usedStyle)); } catch (ex) {}\r\n\t\t\t\r\n\t\t\tfor(var i = styleProtos.length; i--;) {\r\n\t\t\t\tvar styleProto = styleProtos[i];\r\n\t\t\t\tObject.defineProperty(styleProto,cssPropertyName,prop);\r\n\t\t\t\tObject.defineProperty(styleProto,cssCascade.toCamelCase(cssPropertyName),prop);\r\n\t\t\t}\r\n\t\t\tcssCascade.startMonitoringRule(cssSyntax.parse('[style*=\"'+cssPropertyName+'\"]{'+cssPropertyName+':attr(style)}').value[0]);\r\n\t\t\tcssCascade.startMonitoringRule(cssSyntax.parse('[data-style-'+cssPropertyName+']{'+cssPropertyName+':attr(style)}').value[0]);\r\n\t\t\t\r\n\t\t\t// add to the list of polyfilled properties...\r\n\t\t\tcssCascade.getAllCSSProperties().push(cssPropertyName);\r\n\t\t\tcssCascade.computationUnsafeProperties[cssPropertyName] = true;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t};\r\n\r\n\t//\r\n\t// polyfill for browsers not support CSSStyleDeclaration.parentElement (all of them right now)\r\n\t//\r\n\tdomEvents.EventTarget.implementsIn(cssCascade);\r\n\tObject.defineProperty(Element.prototype,'myStyle',{\r\n\t\tget: function() {\r\n\t\t\tvar style = this.style; \r\n\t\t\tif(!style.parentElement) style.parentElement = this;\r\n\t\t\treturn style;\r\n\t\t}\r\n\t});\r\n\r\n\t//\r\n\t// load all stylesheets at the time the script is loaded\r\n\t// then do it again when all stylesheets are downloaded\r\n\t// and again if some style tag is added to the DOM\r\n\t//\r\n\tif(!(\"no_auto_stylesheet_detection\" in window)) {\r\n\t\t\r\n\t\tcssCascade.loadAllStyleSheets();\r\n\t\tdocument.addEventListener(\"DOMContentLoaded\", function() {\r\n\t\t\tcssCascade.loadAllStyleSheets();\r\n\t\t\tquerySelectorLive(\r\n\t\t\t\tcssCascade.selectorForStylesheets,\r\n\t\t\t\t{\r\n\t\t\t\t\tonadded: function(e) {\r\n\t\t\t\t\t\t// TODO: respect DOM order?\r\n\t\t\t\t\t\tcssCascade.loadStyleSheetTag(e);\r\n\t\t\t\t\t\tcssCascade.dispatchEvent('stylesheetadded');\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t})\r\n\t}\r\n\t\r\n\treturn cssCascade;\r\n\r\n})(window, document);\r\n\nrequire.define('src/core/css-cascade.js');","module.exports = (function(window, document) { \"use strict\"; \r\n\r\n\tvar cssSyntax = require('src/core/css-syntax.js');\r\n\tvar cssCascade = require('src/core/css-cascade.js');\r\n\t\r\n\tvar cssBreak = {\r\n\r\n\t\t//\r\n\t\t// returns true if an element is replaced \r\n\t\t// (can't be broken because considered as an image in css layout)\r\n\t\t// \r\n\t\tisReplacedElement: function isReplacedElement(element) {\r\n\t\t\tif(!(element instanceof Element)) return false;\r\n\t\t\tvar replacedElementTags = /^(SVG|MATH|IMG|VIDEO|PICTURE|OBJECT|EMBED|IFRAME|TEXTAREA|BUTTON|INPUT)$/; // TODO: more\r\n\t\t\treturn replacedElementTags.test(element.tagName);\r\n\t\t},\r\n\t\t\r\n\t\t// \r\n\t\t// returns true if an element has a scrollbar or act on overflowing content\r\n\t\t// \r\n\t\tisScrollable: function isScrollable(element, elementOverflow) {\r\n\t\t\tif(!(element instanceof Element)) return false;\r\n\t\t\tif(typeof(elementOverflow)==\"undefined\") elementOverflow = getComputedStyle(element).overflow;\r\n\t\t\t\r\n\t\t\treturn (\r\n\t\t\t\telementOverflow !== \"visible\"\r\n\t\t\t\t&& elementOverflow !== \"hidden\"\r\n\t\t\t);\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t// \r\n\t\t// returns true if the element is part of an inline flow\r\n\t\t// TextNodes definitely qualify, but also inline-block elements\r\n\t\t// \r\n\t\tisSingleLineOfTextComponent: function(element, elementStyle, elementDisplay, elementPosition, isReplaced) {\r\n\t\t\tif(!(element instanceof Element)) return true;\r\n\t\t\tif(typeof(elementStyle)==\"undefined\") elementStyle = getComputedStyle(element);\r\n\t\t\tif(typeof(elementDisplay)==\"undefined\") elementDisplay = elementStyle.display;\r\n\t\t\tif(typeof(elementPosition)==\"undefined\") elementPosition = elementStyle.position;\r\n\t\t\tif(typeof(isReplaced)==\"undefined\") isReplaced = this.isReplacedElement(element);\r\n\t\t\t\r\n\t\t\treturn (\r\n\t\t\t\telementDisplay === \"inline-block\"\r\n\t\t\t\t|| elementDisplay === \"inline-table\"\r\n\t\t\t\t|| elementDisplay === \"inline-flex\"\r\n\t\t\t\t|| elementDisplay === \"inline-grid\"\r\n\t\t\t\t// TODO: more\r\n\t\t\t) && (\r\n\t\t\t\telementPosition === \"static\"\r\n\t\t\t\t|| elementPosition === \"relative\"\r\n\t\t\t);\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t// \r\n\t\t// returns true if the element is part of an inline flow\r\n\t\t// TextNodes definitely qualify, but also inline-block elements\r\n\t\t// \r\n\t\thasAnyInlineFlow: function(element) {\r\n\t\t\t\r\n\t\t\tfunction countAsInline(element) {\r\n\t\t\t\tif(!(element instanceof Element)) return !(/^\\s*$/.test(element.nodeValue));\r\n\t\t\t\treturn !cssBreak.isOutOfFlowElement(element) && cssBreak.isSingleLineOfTextComponent(element);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// try to find any inline element\r\n\t\t\tvar current = element.firstChild;\r\n\t\t\twhile(current) {\r\n\t\t\t\tif(countAsInline(current)) return true;\r\n\t\t\t\tcurrent = current.nextSibling;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// no inline element\r\n\t\t\treturn false;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t// \r\n\t\t// returns true if the element breaks the inline flow\r\n\t\t// (the case of block elements, mostly)\r\n\t\t// \r\n\t\tisLineBreakingElement: function(element, elementStyle, elementDisplay, elementPosition) {\r\n\t\t\t\r\n\t\t\tif(!(element instanceof Element)) return false;\r\n\t\t\tif(typeof(elementStyle)==\"undefined\") elementStyle = getComputedStyle(element);\r\n\t\t\tif(typeof(elementDisplay)==\"undefined\") elementDisplay = elementStyle.display;\r\n\t\t\tif(typeof(elementPosition)==\"undefined\") elementPosition = elementStyle.position;\r\n\t\t\t\r\n\t\t\treturn (\r\n\t\t\t\t(\r\n\t\t\t\t\t// in-flow bock elements\r\n\t\t\t\t\t(elementDisplay === \"block\")\r\n\t\t\t\t\t&& !this.isOutOfFlowElement(element, elementStyle, elementDisplay, elementPosition)\r\n\t\t\t\t\t\r\n\t\t\t\t) || (\r\n\t\t\t\t\t\r\n\t\t\t\t\t// displayed <br> elements\r\n\t\t\t\t\telement.tagName===\"BR\" && elementDisplay!==\"none\"\r\n\t\t\t\t\t\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t},\r\n\t\t\r\n\t\t// \r\n\t\t// returns true if the element breaks the inline flow before him\r\n\t\t// (the case of block elements, mostly)\r\n\t\t// \r\n\t\tisLinePreBreakingElement: function(element, elementStyle, elementDisplay, elementPosition) {\r\n\t\t\tif(!(element instanceof Element)) return false;\r\n\r\n\t\t\tvar breakBefore = cssCascade.getSpecifiedStyle(element,'break-before').toCSSString();\r\n\t\t\treturn (\r\n\t\t\t\t(breakBefore==\"region\"||breakBefore==\"all\") \r\n\t\t\t\t|| cssBreak.isLineBreakingElement(element, elementStyle, elementDisplay, elementPosition)\r\n\t\t\t);\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t// \r\n\t\t// returns true if the element breaks the inline flow after him\r\n\t\t// (the case of block elements, mostly)\r\n\t\t// \r\n\t\tisLinePostBreakingElement: function(element, elementStyle, elementDisplay, elementPosition) {\r\n\t\t\tif(!(element instanceof Element)) return false;\r\n\t\t\t\r\n\t\t\tvar breakAfter = cssCascade.getSpecifiedStyle(element,'break-after').toCSSString();\r\n\t\t\treturn (\r\n\t\t\t\t(breakAfter==\"region\"||breakAfter==\"all\") \r\n\t\t\t\t|| cssBreak.isLineBreakingElement(element, elementStyle, elementDisplay, elementPosition)\r\n\t\t\t);\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t// \r\n\t\t// returns true if the element is outside any block/inline flow\r\n\t\t// (this the case of absolutely positioned elements, and floats)\r\n\t\t// \r\n\t\tisOutOfFlowElement: function(element, elementStyle, elementDisplay, elementPosition, elementFloat) {\r\n\t\t\tif(!(element instanceof Element)) return false;\r\n\t\t\tif(typeof(elementStyle)==\"undefined\") elementStyle = getComputedStyle(element);\r\n\t\t\tif(typeof(elementDisplay)==\"undefined\") elementDisplay = elementStyle.display;\r\n\t\t\tif(typeof(elementPosition)==\"undefined\") elementPosition = elementStyle.position; \r\n\t\t\tif(typeof(elementFloat)==\"undefined\") elementFloat = elementStyle.float || elementStyle.styleFloat || elementStyle.cssFloat;\r\n\t\t\t\r\n\t\t\treturn (\r\n\t\t\t\t\r\n\t\t\t\t// positioned elements are out of the flow\r\n\t\t\t\t(elementPosition===\"absolute\"||elementPosition===\"fixed\")\r\n\t\t\t\t\r\n\t\t\t\t// floated elements as well\r\n\t\t\t\t|| (elementFloat!==\"none\") \r\n\t\t\t\t\r\n\t\t\t\t// not sure but let's say hidden elements as well\r\n\t\t\t\t|| (elementDisplay===\"none\")\r\n\t\t\t\t\r\n\t\t\t);\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t// \r\n\t\t// returns true if two sibling elements are in the same text line\r\n\t\t// (this function is not perfect, work with it with care)\r\n\t\t// \r\n\t\tareInSameSingleLine: function areInSameSingleLine(element1, element2) {\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// look for obvious reasons why it wouldn't be the case\r\n\t\t\t//\r\n\t\t\t\r\n\t\t\t// if the element are not direct sibling, we must use their inner siblings as well\r\n\t\t\tif(element1.nextSibling != element2) { \r\n\t\t\t\tif(element2.nextSibling != element1) throw \"I gave up!\"; \r\n\t\t\t\tvar t = element1; element1=element2; element2=t;\r\n\t\t\t}\r\n\t\t\t \r\n\t\t\t// a block element is never on the same line as another element\r\n\t\t\tif(this.isLinePostBreakingElement(element1)) return false;\r\n\t\t\tif(this.isLinePreBreakingElement(element2)) return false;\r\n\t\t\t\r\n\t\t\t// if the previous element is out of flow, we may consider it as being part of the current line\r\n\t\t\tif(this.isOutOfFlowElement(element1)) return true;\r\n\t\t\t\r\n\t\t\t// if the current object is not a single line component, return false\r\n\t\t\tif(!this.isSingleLineOfTextComponent(element1)) return false;\r\n\t\t\t\r\n\t\t\t// \r\n\t\t\t// compute the in-flow bounding rect of the two elements\r\n\t\t\t// \r\n\t\t\tvar element1box = Node.getBoundingClientRect(element1);\r\n\t\t\tvar element2box = Node.getBoundingClientRect(element2);\r\n\t\t\tfunction shift(box,shiftX,shiftY) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\ttop: box.top+shiftY,\r\n\t\t\t\t\tbottom: box.bottom+shiftY,\r\n\t\t\t\t\tleft: box.left+shiftX,\r\n\t\t\t\t\tright: box.right+shiftX\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// we only need to shift elements\r\n\t\t\tif(element1 instanceof Element) {\r\n\t\t\t\tvar element1Style = getComputedStyle(element1);\r\n\t\t\t\telement1box = shift(element1box, parseFloat(element1Style.marginLeft), parseFloat(element1Style.marginTop))\r\n\t\t\t\tif(element1Style.position==\"relative\") {\r\n\t\t\t\t\telement1box = shift(element1box, parseFloat(element1Style.left), parseFloat(element1Style.top))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// we only need to shift elements\r\n\t\t\tif(element2 instanceof Element) {\r\n\t\t\t\tvar element2Style = getComputedStyle(element2);\r\n\t\t\t\telement2box = shift(element2box, parseFloat(element2Style.marginLeft), parseFloat(element2Style.marginTop))\r\n\t\t\t\tif(element2Style.position==\"relative\") {\r\n\t\t\t\t\telement2box = shift(element2box, parseFloat(element2Style.left), parseFloat(element2Style.top))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// order the nodes so that they are in left-to-right order\r\n\t\t\t// (this means invert their order in the case of right-to-left flow)\r\n\t\t\tvar firstElement = getComputedStyle(element1.parentNode).direction==\"rtl\" ? element2box : element1box;\r\n\t\t\tvar secondElement = getComputedStyle(element1.parentNode).direction==\"rtl\" ? element1box : element2box;\r\n\t\t\t\r\n\t\t\t// return true if both elements are have non-overlapping\r\n\t\t\t// margin- and position-corrected in-flow bounding rect\r\n\t\t\t// and if their relative position is the one of the current\r\n\t\t\t// flow (either rtl or ltr)\r\n\t\t\treturn firstElement.right <= secondElement.left;\r\n\t\t\t\r\n\t\t\t// TODO: what about left-to-right + right-aligned text?\r\n\t\t\t// I should probably takes care of vertical position in this case to solve ambiguities\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// returns true if the element has \"overflow: hidden\" set on it, and actually overflows\r\n\t\t//\r\n\t\tisHiddenOverflowing: function isHiddenOverflowing(element, elementOverflow) {\r\n\t\t\tif(!(element instanceof Element)) return false;\r\n\t\t\tif(typeof(elementOverflow)==\"undefined\") elementOverflow = getComputedStyle(element).display;\r\n\t\t\t\r\n\t\t\treturn (\r\n\t\t\t\telementOverflow == \"hidden\" \r\n\t\t\t\t&& element.offsetHeight != element.scrollHeight // trust me that works\r\n\t\t\t);\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// returns true if the element has a border-radius that impacts his layout\r\n\t\t//\r\n\t\thasBigRadius: function(element, elementStyle) {\r\n\t\t\tif(!(element instanceof Element)) return false;\r\n\t\t\tif(typeof(elementStyle)==\"undefined\") elementStyle = getComputedStyle(element);\r\n\r\n\t\t\t// if the browser supports radiuses {f### prefixes}\r\n\t\t\tif(\"borderTopLeftRadius\" in elementStyle) {\r\n\t\t\t\t\r\n\t\t\t\tvar tlRadius = parseFloat(elementStyle.borderTopLeftRadius);\r\n\t\t\t\tvar trRadius = parseFloat(elementStyle.borderTopRightRadius);\r\n\t\t\t\tvar blRadius = parseFloat(elementStyle.borderBottomLeftRadius);\r\n\t\t\t\tvar brRadius = parseFloat(elementStyle.borderBottomRightRadius);\r\n\t\t\t\t\r\n\t\t\t\t// tiny radiuses (<15px) are tolerated anyway\r\n\t\t\t\tif(tlRadius < 15 && trRadius < 15 && blRadius < 15 && brRadius < 15) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tvar tWidth = parseFloat(elementStyle.borderTopWidth);\r\n\t\t\t\tvar bWidth = parseFloat(elementStyle.borderBottomWidth);\r\n\t\t\t\tvar lWidth = parseFloat(elementStyle.borderLeftWidth);\r\n\t\t\t\tvar rWidth = parseFloat(elementStyle.borderRightWidth);\r\n\t\t\t\t\r\n\t\t\t\t// make sure the radius itself is contained into the border\r\n\t\t\t\t\r\n\t\t\t\tif(tlRadius > tWidth) return true;\r\n\t\t\t\tif(tlRadius > lWidth) return true;\r\n\t\t\t\t\r\n\t\t\t\tif(trRadius > tWidth) return true;\r\n\t\t\t\tif(trRadius > rWidth) return true;\r\n\t\t\t\t\r\n\t\t\t\tif(blRadius > bWidth) return true;\r\n\t\t\t\tif(blRadius > lWidth) return true;\r\n\t\t\t\t\r\n\t\t\t\tif(brRadius > bWidth) return true;\r\n\t\t\t\tif(brRadius > rWidth) return true;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// all conditions were met\r\n\t\t\treturn false;\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// return trus if the break-inside property is 'avoid' or 'avoid-region'\r\n\t\t//\r\n\t\tisBreakInsideAvoid: function isBreakInsideAvoid(element, elementStyle) {\r\n\t\t\tvar breakInside = cssCascade.getSpecifiedStyle(element, 'break-inside', undefined, true).toCSSString().trim().toLowerCase(); \r\n\t\t\treturn (breakInside == \"avoid\" || breakInside == \"avoid-region\");\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// returns true if the element is unbreakable according to the spec\r\n\t\t// (and some of the expected limitations of HTML/CSS)\r\n\t\t//\r\n\t\tisMonolithic: function isMonolithic(element) {\r\n\t\t\tif(!(element instanceof Element)) return false;\r\n\t\t\t\r\n\t\t\tvar elementStyle = getComputedStyle(element);\r\n\t\t\tvar elementOverflow = elementStyle.overflow;\r\n\t\t\tvar elementDisplay = elementStyle.display;\r\n\t\t\t\r\n\t\t\t// Some content is not fragmentable, for example:\r\n\t\t\t// - many types of replaced elements (such as images or video)\r\n\t\t\t\r\n\t\t\tvar isReplaced = this.isReplacedElement(element);\r\n\t\t\t\r\n\t\t\t// - scrollable elements\r\n\t\t\t\r\n\t\t\tvar isScrollable = this.isScrollable(element, elementOverflow);\r\n\t\t\t\r\n\t\t\t// - a single line of text content. \r\n\t\t\t\r\n\t\t\tvar isSingleLineOfText = this.isSingleLineOfTextComponent(element, elementStyle, elementDisplay, undefined, isReplaced);\r\n\t\t\t\r\n\t\t\t// Such content is considered monolithic: it contains no\r\n\t\t\t// possible break points. \r\n\t\t\t\r\n\t\t\t// In addition to any content which is not fragmentable, \r\n\t\t\t// UAs may consider as monolithic:\r\n\t\t\t// - any elements with ‘overflow’ set to ‘auto’ or ‘scroll’ \r\n\t\t\t// - any elements with ‘overflow: hidden’ and a non-‘auto’ logical height (and no specified maximum logical height).\r\n\t\t\t\r\n\t\t\tvar isHiddenOverflowing = this.isHiddenOverflowing(element, elementOverflow);\r\n\t\t\t\r\n\t\t\t// ADDITION TO THE SPEC:\r\n\t\t\t// I don't want to handle the case where \r\n\t\t\t// an element has a border-radius that is bigger\r\n\t\t\t// than the border-width to which it belongs\r\n\t\t\tvar hasBigRadius = this.hasBigRadius(element, elementStyle);\r\n\t\t\t\r\n\t\t\t// ADDITION TO THE SPEC:\r\n\t\t\t// Someone proposed to support \"break-inside: avoid\" here\r\n\t\t\tvar isBreakInsideAvoid = this.isBreakInsideAvoid(element, elementStyle);\r\n\t\t\t\r\n\t\t\t// all of them are monolithic\r\n\t\t\treturn isReplaced || isScrollable || isSingleLineOfText || isHiddenOverflowing || hasBigRadius || isBreakInsideAvoid;\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t// \r\n\t\t// returns true if \"r\" is a collapsed range located at a possible break point for \"region\"\r\n\t\t// (this function does all the magic for you, but you may want to avoid using it too much)\r\n\t\t// \r\n\t\tisPossibleBreakPoint: function isPossibleBreakPoint(r, region) {\r\n\t\t\t\r\n\t\t\t// r has to be a range, and be collapsed\r\n\t\t\tif(!(r instanceof Range)) return false;\r\n\t\t\tif(!(r.collapsed)) return false;\r\n\t\t\t\r\n\t\t\t// no ancestor up to the region has to be monolithic\r\n\t\t\tvar ancestor = r.startContainer;\r\n\t\t\twhile(ancestor && ancestor !== region) {\r\n\t\t\t\tif(cssBreak.isMonolithic(ancestor)) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tancestor = ancestor.parentNode;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// we also have to check that we're not between two single-line-of-text elements\r\n\t\t\t// that are actually on the same line (in which case you can't break)\r\n\t\t\tvar ancestor = r.startContainer; \r\n\t\t\tvar lastAncestor = r.startContainer.childNodes[r.startOffset];\r\n\t\t\twhile(ancestor && lastAncestor !== region) {\r\n\t\t\t\tif(lastAncestor && lastAncestor.previousSibling) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(this.areInSameSingleLine(lastAncestor, lastAncestor.previousSibling)) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tlastAncestor = ancestor;\r\n\t\t\t\tancestor = ancestor.parentNode;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// there are some very specific conditions for breaking\r\n\t\t\t// at the edge of an element:\r\n\t\t\t\r\n\t\t\tif(r.startOffset==0) {\r\n\t\t\t\t\r\n\t\t\t\t// Class 3 breaking point:\r\n\t\t\t\t// ========================\r\n\t\t\t\t// Between the content edge of a block container box \r\n\t\t\t\t// and the outer edges of its child content (margin \r\n\t\t\t\t// edges of block-level children or line box edges \r\n\t\t\t\t// for inline-level children) if there is a (non-zero)\r\n\t\t\t\t// gap between them.\r\n\t\t\t\t\r\n\t\t\t\tvar firstChild = r.startContainer.childNodes[0];\r\n\t\t\t\tif(firstChild) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar firstChildBox = (\r\n\t\t\t\t\t\tNode.getBoundingClientRect(firstChild)\r\n\t\t\t\t\t);\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar parentBox = (\r\n\t\t\t\t\t\tr.startContainer.getBoundingClientRect()\r\n\t\t\t\t\t);\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(firstChildBox.top == parentBox.top) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// all conditions are met!\r\n\t\t\treturn true;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t};\r\n\t\r\n\treturn cssBreak;\r\n\t\r\n})(window, document);\nrequire.define('src/core/css-break.js');","\"use strict\";\r\n\r\n//\r\n// start by polyfilling caretRangeFromPoint\r\n//\r\n\r\nif(!document.caretRangeFromPoint) {\r\n    if (document.caretPositionFromPoint) {\r\n        document.caretRangeFromPoint = function caretRangeFromPoint(x,y) {\r\n            var r = document.createRange();\r\n            var p = document.caretPositionFromPoint(x,y); \r\n            if(p.offsetNode) {\r\n                r.setStart(p.offsetNode, p.offset);\r\n                r.setEnd(p.offsetNode, p.offset);\r\n            }\r\n            return r;\r\n        }\r\n    } else if((document.body||document.createElement('body')).createTextRange) {\r\n        \r\n        //\r\n        // we may want to convert TextRange to Range\r\n        //\r\n        \r\n        var TextRangeUtils = {\r\n            convertToDOMRange: function (textRange, document) {\r\n                var adoptBoundary = function(domRange, textRangeInner, bStart) {\r\n                    // iterate backwards through parent element to find anchor location\r\n                    var cursorNode = document.createElement('a'), cursor = textRangeInner.duplicate();\r\n                    cursor.collapse(bStart);\r\n                    var parent = cursor.parentElement();\r\n                    do {\r\n                            parent.insertBefore(cursorNode, cursorNode.previousSibling);\r\n                            cursor.moveToElementText(cursorNode);\r\n                    } while (cursor.compareEndPoints(bStart ? 'StartToStart' : 'StartToEnd', textRangeInner) > 0 && cursorNode.previousSibling);\r\n                    \r\n                    // when we exceed or meet the cursor, we've found the node\r\n                    if (cursor.compareEndPoints(bStart ? 'StartToStart' : 'StartToEnd', textRangeInner) == -1 && cursorNode.nextSibling) {\r\n                            // data node\r\n                            cursor.setEndPoint(bStart ? 'EndToStart' : 'EndToEnd', textRangeInner);\r\n                            domRange[bStart ? 'setStart' : 'setEnd'](cursorNode.nextSibling, cursor.text.length);\r\n                    } else {\r\n                            // element\r\n                            domRange[bStart ? 'setStartBefore' : 'setEndBefore'](cursorNode);\r\n                    }\r\n                    cursorNode.parentNode.removeChild(cursorNode);\r\n                }\r\n                \r\n                // validate arguments\r\n                if(!document) { document=window.document; }\r\n                \r\n                // return a DOM range\r\n                var domRange = document.createRange();\r\n                adoptBoundary(domRange, textRange, true);\r\n                adoptBoundary(domRange, textRange, false);\r\n                return domRange;\r\n            },\r\n\r\n            convertFromDOMRange: function (domRange) {\r\n                var adoptEndPoint = function(textRange, domRangeInner, bStart) {\r\n                    // find anchor node and offset\r\n                    var container = domRangeInner[bStart ? 'startContainer' : 'endContainer'];\r\n                    var offset = domRangeInner[bStart ? 'startOffset' : 'endOffset'], textOffset = 0;\r\n                    var anchorNode = DOMUtils.isDataNode(container) ? container : container.childNodes[offset];\r\n                    var anchorParent = DOMUtils.isDataNode(container) ? container.parentNode : container;\r\n                    // visible data nodes need a text offset\r\n                    if (container.nodeType == 3 || container.nodeType == 4)\r\n                        textOffset = offset;\r\n                    \r\n                    // create a cursor element node to position range (since we can't select text nodes)\r\n                    var cursorNode = domRangeInner._document.createElement('a');\r\n                    anchorParent.insertBefore(cursorNode, anchorNode);\r\n                    var cursor = domRangeInner._document.body.createTextRange();\r\n                    cursor.moveToElementText(cursorNode);\r\n                    cursorNode.parentNode.removeChild(cursorNode);\r\n                    // move range\r\n                    textRange.setEndPoint(bStart ? 'StartToStart' : 'EndToStart', cursor);\r\n                    textRange[bStart ? 'moveStart' : 'moveEnd']('character', textOffset);\r\n                }\r\n               \r\n                // return an IE text range\r\n                var textRange = domRange._document.body.createTextRange();\r\n                adoptEndPoint(textRange, domRange, true);\r\n                adoptEndPoint(textRange, domRange, false);\r\n                return textRange;\r\n            }\r\n        };\r\n\r\n        \r\n        document.caretRangeFromPoint = function caretRangeFromPoint(x,y) {\r\n            \r\n            // the accepted number of vertical backtracking, in CSS pixels\r\n            var IYDepth = 40;\r\n            \r\n            // try to create a text range at the specified location\r\n            var r = document.body.createTextRange();\r\n            for(var iy=IYDepth; iy; iy=iy-4) {\r\n                var ix = x; if(true) {\r\n                    try {\r\n                        r.moveToPoint(ix,iy+y-IYDepth); \r\n                        return TextRangeUtils.convertToDOMRange(r);\r\n                    } catch(ex) {}\r\n                }\r\n            }\r\n            \r\n            // if that fails, return the location just after the element located there\r\n            try {\r\n                \r\n                var elem = document.elementFromPoint(x-1,y-1);\r\n                var r = document.createRange();\r\n                r.setStartAfter(elem);\r\n                return r;\r\n                \r\n            } catch(ex) {\r\n                \r\n                return null;\r\n                \r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n///\r\n/// helper function for moving ranges char by char\r\n///\r\n\r\nRange.prototype.myMoveOneCharLeft = function() {\r\n    var r = this;\r\n    \r\n    // move to the previous cursor location\r\n    if(r.endOffset > 0) {\r\n        \r\n        // if we can enter into the previous sibling\r\n        var previousSibling = r.endContainer.childNodes[r.endOffset-1];\r\n        if(previousSibling && previousSibling.lastChild) {\r\n            \r\n            // enter the previous sibling from its end\r\n            r.setEndAfter(previousSibling.lastChild);\r\n            \r\n        } else if(previousSibling && previousSibling.nodeType==previousSibling.TEXT_NODE) { // todo: lookup value\r\n            \r\n            // enter the previous text node from its end\r\n            r.setEnd(previousSibling, previousSibling.nodeValue.length);\r\n            \r\n        } else {\r\n            \r\n            // else move before that element\r\n            r.setEnd(r.endContainer, r.endOffset-1);\r\n            \r\n        }\r\n        \r\n    } else {\r\n        r.setEndBefore(r.endContainer);\r\n    }\r\n    \r\n}\r\n\r\nRange.prototype.myMoveOneCharRight = function() {\r\n    var r = this;\r\n    \r\n    // move to the previous cursor location\r\n    var max = (r.startContainer.nodeType==r.startContainer.TEXT_NODE ? r.startContainer.nodeValue.length : r.startContainer.childNodes.length)\r\n    if(r.startOffset < max) {\r\n        \r\n        // if we can enter into the next sibling\r\n        var nextSibling = r.endContainer.childNodes[r.endOffset];\r\n        if(nextSibling && nextSibling.firstChild) {\r\n            \r\n            // enter the next sibling from its start\r\n            r.setStartBefore(nextSibling.firstChild);\r\n            \r\n        } else if(nextSibling && nextSibling.nodeType==nextSibling.TEXT_NODE && nextSibling.nodeValue!='') { // todo: lookup value\r\n            \r\n            // enter the next text node from its start\r\n            r.setStart(nextSibling, 0);\r\n            \r\n        } else {\r\n            \r\n            // else move before that element\r\n            r.setStart(r.startContainer, r.startOffset+1);\r\n            \r\n        }\r\n        \r\n    } else {\r\n        r.setStartAfter(r.endContainer);\r\n    }\r\n    \r\n    // shouldn't be needed but who knows...\r\n    r.setEnd(r.startContainer, r.startOffset);\r\n    \r\n}\r\n\r\n\r\n///\r\n/// This functions is optimized to not yield inside a word in a text node\r\n///\r\nRange.prototype.myMoveTowardRight = function() {\r\n    var r = this;\r\n    \r\n    // move to the previous cursor location\r\n    var isTextNode = r.startContainer.nodeType==r.startContainer.TEXT_NODE;\r\n    var max = (isTextNode ? r.startContainer.nodeValue.length : r.startContainer.childNodes.length)\r\n    if(r.startOffset < max) {\r\n        \r\n        // if we can enter into the next sibling\r\n        var nextSibling = r.endContainer.childNodes[r.endOffset];\r\n        if(nextSibling && nextSibling.firstChild) {\r\n            \r\n            // enter the next sibling from its start\r\n            r.setStartBefore(nextSibling.firstChild);\r\n            \r\n        } else if(nextSibling && nextSibling.nodeType==nextSibling.TEXT_NODE && nextSibling.nodeValue!='') { // todo: lookup value\r\n            \r\n            // enter the next text node from its start\r\n            r.setStart(nextSibling, 0);\r\n            \r\n        } else if(isTextNode) {\r\n            \r\n            // move to the next non a-zA-Z symbol\r\n            var currentText = r.startContainer.nodeValue;\r\n            var currentOffset = r.startOffset;\r\n            var currentLetter = currentText[currentOffset++];\r\n            while(currentOffset < max && /^\\w$/.test(currentLetter)) {\r\n                currentLetter = currentText[currentOffset++];\r\n            }\r\n            r.setStart(r.startContainer, currentOffset);\r\n            \r\n        } else {\r\n            \r\n            // else move after that element\r\n            r.setStart(r.startContainer, r.startOffset+1);\r\n            \r\n        }\r\n        \r\n    } else {\r\n        r.setStartAfter(r.endContainer);\r\n    }\r\n    \r\n    // shouldn't be needed but who knows...\r\n    r.setEnd(r.startContainer, r.startOffset);\r\n    \r\n}\r\n\r\n\r\nRange.prototype.myMoveEndOneCharLeft = function() {\r\n    var r = this;\r\n    \r\n    // move to the previous cursor location\r\n    if(r.endOffset > 0) {\r\n        \r\n        // if we can enter into the previous sibling\r\n        var previousSibling = r.endContainer.childNodes[r.endOffset-1];\r\n        if(previousSibling && previousSibling.lastChild) {\r\n            \r\n            // enter the previous sibling from its end\r\n            r.setEndAfter(previousSibling.lastChild);\r\n            \r\n        } else if(previousSibling && previousSibling.nodeType==previousSibling.TEXT_NODE) { // todo: lookup value\r\n            \r\n            // enter the previous text node from its end\r\n            r.setEnd(previousSibling, previousSibling.nodeValue.length);\r\n            \r\n        } else {\r\n            \r\n            // else move before that element\r\n            r.setEnd(r.endContainer, r.endOffset-1);\r\n            \r\n        }\r\n        \r\n    } else {\r\n        r.setEndBefore(r.endContainer);\r\n    }\r\n    \r\n}\r\n\r\nRange.prototype.myMoveEndOneCharRight = function() {\r\n    var r = this;\r\n    \r\n    // move to the previous cursor location\r\n    var max = (r.endContainer.nodeType==r.endContainer.TEXT_NODE ? r.endContainer.nodeValue.length : r.endContainer.childNodes.length)\r\n    if(r.endOffset < max) {\r\n        \r\n        // if we can enter into the next sibling\r\n        var nextSibling = r.endContainer.childNodes[r.endOffset];\r\n        if(nextSibling && nextSibling.firstChild) {\r\n            \r\n            // enter the next sibling from its start\r\n            r.setEndBefore(nextSibling.firstChild);\r\n            \r\n        } else if(nextSibling && nextSibling.nodeType==nextSibling.TEXT_NODE) { // todo: lookup value\r\n            \r\n            // enter the next text node from its start\r\n            r.setEnd(nextSibling, 0);\r\n            \r\n        } else {\r\n            \r\n            // else move before that element\r\n            r.setEnd(r.endContainer, r.endOffset+1);\r\n            \r\n        }\r\n        \r\n    } else {\r\n        r.setEndAfter(r.endContainer);\r\n    }\r\n    \r\n}\r\n\r\n//\r\n// Get the *real* bounding client rect of the range\r\n// { therefore we need to fix some browser bugs... }\r\n//\r\nRange.prototype.myGetSelectionRect = function() {\r\n    \r\n    // get the browser's claimed rect\r\n    var rect = this.getBoundingClientRect();\r\n\t\r\n\t// HACK FOR ANDROID BROWSER AND OLD WEBKIT\r\n\tif(!rect) { \r\n\t\trect={top:0,right:0,bottom:0,left:0,width:0,height:0}; \r\n\t}\r\n    \r\n    // if the value seems wrong... (some browsers don't like collapsed selections)\r\n    if(this.collapsed && rect.top===0 && rect.bottom===0) {\r\n        \r\n        // select one char and infer location\r\n        var clone = this.cloneRange(); var collapseToLeft=false; clone.collapse(false); \r\n        \r\n        // the case where no char before is tricky...\r\n        if(clone.startOffset==0) {\r\n            \r\n            // let's move on char to the right\r\n            clone.myMoveTowardRight();\r\n            collapseToLeft=true;\r\n\r\n            // note: some browsers don't like selections\r\n            // that spans multiple containers, so we will\r\n            // iterate this process until we have one true\r\n            // char selected\r\n            clone.setStart(clone.endContainer, 0); \r\n            \r\n        } else {\r\n            \r\n            // else, just select the char before\r\n            clone.setStart(this.startContainer, this.startOffset-1);\r\n            collapseToLeft=false;\r\n            \r\n        }\r\n        \r\n        // get some real rect\r\n        var rect = clone.myGetSelectionRect();\r\n        \r\n        // compute final value\r\n        if(collapseToLeft) {\r\n            return {\r\n                \r\n                left: rect.left,\r\n                right: rect.left,\r\n                width: 0,\r\n                \r\n                top: rect.top,\r\n                bottom: rect.bottom,\r\n                height: rect.height\r\n                \r\n            }\r\n        } else {\r\n            return {\r\n                \r\n                left: rect.right,\r\n                right: rect.right,\r\n                width: 0,\r\n                \r\n                top: rect.top,\r\n                bottom: rect.bottom,\r\n                height: rect.height\r\n                \r\n            }\r\n        }\r\n        \r\n    } else {\r\n        return rect;\r\n    }\r\n    \r\n}\r\n\r\n// not sure it's needed but still\r\nif(!window.Element) window.Element=window.HTMLElement;\r\nif(!window.Node) window.Node = {};\r\n\r\n// make getBCR working on text nodes & stuff\r\nNode.getBoundingClientRect = function getBoundingClientRect(element) {\r\n    if (element.getBoundingClientRect) {\r\n        \r\n        var rect = element.getBoundingClientRect();\r\n        \r\n    } else {\r\n        \r\n        var range = document.createRange();\r\n        range.selectNode(element);\r\n        \r\n        var rect = range.getBoundingClientRect();\r\n        \r\n    }\r\n\t\r\n\t// HACK FOR ANDROID BROWSER AND OLD WEBKIT\r\n\tif(!rect) { \r\n\t\trect={top:0,right:0,bottom:0,left:0,width:0,height:0}; \r\n\t}\r\n\t\r\n\treturn rect;\r\n};\r\n\r\n\r\n// make getCR working on text nodes & stuff\r\nNode.getClientRects = function getClientRects(firstChild) {\r\n    if (firstChild.getBoundingClientRect) {\r\n        \r\n        return firstChild.getClientRects();\r\n        \r\n    } else {\r\n        \r\n        var range = document.createRange();\r\n        range.selectNode(firstChild);\r\n        \r\n        return range.getClientRects();\r\n        \r\n    }\r\n};\r\n\r\n// fix for IE (contains fails for text nodes...)\r\nNode.contains = function contains(parentNode,node) {\r\n    if(node.nodeType != 1) {\r\n        if(!node.parentNode) return false;\r\n        return node.parentNode==parentNode || parentNode.contains(node.parentNode);\r\n    } else {\r\n        return parentNode.contains(node);\r\n    }\r\n}\r\n\r\n//\r\n// get the bounding rect of the selection, including the bottom padding/marging of the previous element if required\r\n// { this is a special version for breaking algorithms that do not want to miss the previous element real size }\r\n//\r\nRange.prototype.myGetExtensionRect = function() {\r\n    \r\n    // this function returns the selection rect\r\n    // but does take care of taking in account \r\n    // the bottom-{padding/border} of the previous\r\n    // sibling element, to detect overflow points\r\n    // more accurately\r\n    \r\n    var rect = this.myGetSelectionRect();\r\n    var previousSibling = this.endContainer.childNodes[this.endOffset-1];\r\n    if(previousSibling) {\r\n        \r\n        // correct with the new take\r\n        var prevSibRect = Node.getBoundingClientRect(previousSibling);\r\n        var adjustedBottom = Math.max(rect.bottom,prevSibRect.bottom);\r\n        if(adjustedBottom == rect.bottom) return rect;\r\n        return {\r\n            \r\n            left: rect.left,\r\n            right: rect.right,\r\n            width: rect.width,\r\n            \r\n            top: rect.top,\r\n            bottom: adjustedBottom,\r\n            height: adjustedBottom - rect.top\r\n            \r\n        };\r\n        \r\n    } else if(rect.bottom==0 && this.endContainer.nodeType === 3) {\r\n        \r\n        // note that if we are in a text node, \r\n        // we may want to cover all the previous\r\n        // text in the node to avoid whitespace\r\n        // related bugs\r\n        \r\n        var onlyWhiteSpaceBefore = /^(\\s|\\n)*$/.test(this.endContainer.nodeValue.substr(0,this.endOffset));\r\n        if(onlyWhiteSpaceBefore) {\r\n            \r\n            // if we are in the fucking whitespace land, return first line\r\n            var prevSibRect = Node.getClientRects(this.endContainer)[0];\r\n            return prevSibRect;\r\n            \r\n        } else {\r\n            \r\n            // otherwhise, let's rely on previous chars\r\n            var auxiliaryRange = this.cloneRange();\r\n            auxiliaryRange.setStart(this.endContainer,0);\r\n            \r\n            // correct with the new take\r\n            var prevSibRect = auxiliaryRange.getBoundingClientRect();\r\n            var adjustedBottom = Math.max(rect.bottom,prevSibRect.bottom);\r\n            return {\r\n                \r\n                left: rect.left,\r\n                right: rect.right,\r\n                width: rect.width,\r\n                \r\n                top: rect.top,\r\n                bottom: adjustedBottom,\r\n                height: adjustedBottom - rect.top\r\n                \r\n            };\r\n            \r\n        }\r\n        \r\n    } else {\r\n        \r\n        return rect;\r\n        \r\n    }\r\n}\nrequire.define('src/css-regions/lib/range-extensions.js');","//\r\n// this module holds the big-picture actions of the polyfill\r\n//\r\nmodule.exports = (function(window, document) { \"use strict\";\r\n\t\r\n\tvar domEvents = require('src/core/dom-events.js');\r\n\tvar cssSyntax = require('src/core/css-syntax.js');\r\n\tvar cssCascade = require('src/core/css-cascade.js');\r\n\tvar cssBreak = require('src/core/css-break.js');\r\n\r\n\tvar cssRegionsHelpers = window.cssRegionsHelpers = {\r\n\t\t\r\n\t\t//\r\n\t\t// returns the previous sibling of the element\r\n\t\t// or the previous sibling of its nearest ancestor that has one\r\n\t\t//\r\n\t\tgetAllLevelPreviousSibling: function(e, region) {\r\n\t\t\tif(!e || e==region) return null;\r\n\t\t\t\r\n\t\t\t// find the nearest ancestor that has a previous sibling\r\n\t\t\twhile(!e.previousSibling) {\r\n\t\t\t\t\r\n\t\t\t\t// but bubble to the next avail ancestor\r\n\t\t\t\te = e.parentNode;\r\n\t\t\t\t\r\n\t\t\t\t// dont get over the bar\r\n\t\t\t\tif(!e || e==region) return null;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// return that sibling\r\n\t\t\treturn e.previousSibling;\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// prepares the element to become a css region\r\n\t\t//\r\n\t\tmarkNodesAsRegion: function(nodes,fast) {\r\n\t\t\tnodes.forEach(function(node) {\r\n\t\t\t\tnode.regionOverset = 'empty';\r\n\t\t\t\tnode.setAttribute('data-css-region',node.cssRegionsLastFlowFromName);\r\n\t\t\t\tcssRegionsHelpers.hideTextNodesFromFragmentSource([node]);\r\n\t\t\t\tnode.cssRegionsWrapper = node.cssRegionsWrapper || node.appendChild(document.createElement(\"cssregion\"));\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// prepares the element to return to its normal css life\r\n\t\t//\r\n\t\tunmarkNodesAsRegion: function(nodes,fast) {\r\n\t\t\tnodes.forEach(function(node) {\r\n\t\t\t\t\r\n\t\t\t\t// restore regionOverset to its natural value\r\n\t\t\t\tnode.regionOverset = 'fit';\r\n\t\t\t\t\r\n\t\t\t\t// remove the current <cssregion> tag\r\n\t\t\t\ttry { node.cssRegionsWrapper && node.removeChild(node.cssRegionsWrapper); } \r\n\t\t\t\tcatch(ex) { setImmediate(function() { throw ex })}; \r\n\t\t\t\tnode.cssRegionsWrapper = undefined;\r\n\t\t\t\tdelete node.cssRegionsWrapper;\r\n\t\t\t\t\r\n\t\t\t\t// restore top-level texts that may have been hidden\r\n\t\t\t\tcssRegionsHelpers.unhideTextNodesFromFragmentSource([node]);\r\n\t\t\t\t\r\n\t\t\t\t// unmark as a region\r\n\t\t\t\tnode.removeAttribute('data-css-region');\r\n\t\t\t});\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// prepares the element for cloning (mainly give them an ID)\r\n\t\t//\r\n\t\tfragmentSourceIndex: 0,\r\n\t\tmarkNodesAsFragmentSource: function(nodes,ignoreRoot) {\r\n\t\t\t\r\n\t\t\tfunction visit(node,k) {\r\n\t\t\t\tvar child, next;\r\n\t\t\t\tswitch (node.nodeType) {\r\n\t\t\t\t\tcase 1: // Element node\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif(typeof(k)==\"undefined\" || !ignoreRoot) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// mark as fragment source\r\n\t\t\t\t\t\t\tvar id = node.getAttributeNode('data-css-regions-fragment-source');\r\n\t\t\t\t\t\t\tif(!id) { node.setAttribute('data-css-regions-fragment-source', cssRegionsHelpers.fragmentSourceIndex++); }\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tnode.setAttribute('data-css-regions-cloning', true);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// expand list values\r\n\t\t\t\t\t\tif(node.tagName=='OL') cssRegionsHelpers.expandListValues(node);\r\n\t\t\t\t\t\tif(typeof(k)!=\"undefined\" && node.tagName==\"LI\") cssRegionsHelpers.expandListValues(node.parentNode);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tcase 9: // Document node\r\n\t\t\t\t\tcase 11: // Document fragment node\r\n\t\t\t\t\t\tchild = node.firstChild;\r\n\t\t\t\t\t\twhile (child) {\r\n\t\t\t\t\t\t\tnext = child.nextSibling;\r\n\t\t\t\t\t\t\tvisit(child);\r\n\t\t\t\t\t\t\tchild = next;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tnodes.forEach(visit);\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// computes the \"value\" attribute of every LI element out there\r\n\t\t//\r\n\t\texpandListValues: function(OL) {\r\n\t\t\tif(OL.getAttribute(\"data-css-li-value-expanded\")) return;\r\n\t\t\tOL.setAttribute('data-css-li-value-expanded', true);\r\n\t\t\t\r\n\t\t\tif(OL.hasAttribute(\"reversed\")) {\r\n\t\t\t\t\r\n\t\t\t\tvar currentValue = OL.getAttribute(\"start\") ? parseInt(OL.getAttribute(\"start\")) : OL.childElementCount;\r\n\t\t\t\tvar increment = -1;\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\tvar currentValue = OL.getAttribute(\"start\") ? parseInt(OL.getAttribute(\"start\")) : 1;\r\n\t\t\t\tvar increment = +1;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar LI = OL.firstElementChild; var LIV = null;\r\n\t\t\twhile(LI) {\r\n\t\t\t\tif(LI.tagName===\"LI\") {\r\n\t\t\t\t\tif(LIV=LI.getAttributeNode(\"value\")) {\r\n\t\t\t\t\t\tcurrentValue = parseInt(LIV.nodeValue);\r\n\t\t\t\t\t\tLI.setAttribute('data-css-old-value', currentValue)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tLI.setAttribute(\"value\", currentValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcurrentValue = currentValue + increment;\r\n\t\t\t\t}\r\n\t\t\t\tLI = LI.nextElementSibling;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// reverts to automatic computation of the value of LI elements\r\n\t\t//\r\n\t\tunexpandListValues: function(OL) {\r\n\t\t\tif(!OL.hasAttribute('data-css-li-value-expanded')) return;\r\n\t\t\tOL.removeAttribute('data-css-li-value-expanded')\r\n\t\t\tvar LI = OL.firstElementChild; var LIV = null;\r\n\t\t\twhile(LI) {\r\n\t\t\t\tif(LI.tagName===\"LI\") {\r\n\t\t\t\t\tif(LIV=LI.getAttributeNode(\"data-css-old-value\")) {\r\n\t\t\t\t\t\tLI.removeAttributeNode(LIV);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tLI.removeAttribute('value');\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tLI = LI.nextElementSibling;\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// makes empty text nodes which cannot get \"display: none\" applied to them\r\n\t\t//\r\n\t\tlistOfTextNodesForIE: [],\r\n\t\thideTextNodesFromFragmentSource: function(nodes) {\r\n\t\t\t\r\n\t\t\tfunction visit(node,k) {\r\n\t\t\t\tvar child, next;\r\n\t\t\t\tswitch (node.nodeType) {\r\n\t\t\t\t\tcase 3: // Text node\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif(!node.parentNode.getAttribute('data-css-regions-fragment-source')) {\r\n\t\t\t\t\t\t\t// we have to remove their content the hard way...\r\n\t\t\t\t\t\t\tnode.cssRegionsSavedNodeValue = node.nodeValue;\r\n\t\t\t\t\t\t\tnode.nodeValue = \"\";\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// HACK: OTHERWISE IE WILL GC THE TEXTNODE AND RETURNS YOU\r\n\t\t\t\t\t\t\t// A FRESH TEXTNODE THE NEXT TIME WHERE YOUR EXPANDO\r\n\t\t\t\t\t\t\t// IS NOWHERE TO BE SEEN!\r\n\t\t\t\t\t\t\tif(navigator.userAgent.indexOf('MSIE')>0 || navigator.userAgent.indexOf(\"Trident\")>0) {\r\n\t\t\t\t\t\t\t\tif(cssRegionsHelpers.listOfTextNodesForIE.indexOf(node)==-1) {\r\n\t\t\t\t\t\t\t\t\tcssRegionsHelpers.listOfTextNodesForIE.push(node);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tcase 1: // Element node\r\n\t\t\t\t\t\tif(node.hasAttribute('data-css-regions-cloning')) {\r\n\t\t\t\t\t\t\tnode.removeAttribute('data-css-regions-cloning');\r\n\t\t\t\t\t\t\tnode.setAttribute('data-css-regions-cloned', true);\r\n\t\t\t\t\t\t\tif(node.currentStyle) node.currentStyle.display.toString(); // IEFIX FOR BAD STYLE RECALC\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(typeof(k)==\"undefined\") return;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tcase 9: // Document node\r\n\t\t\t\t\tcase 11: // Document fragment node                    \r\n\t\t\t\t\t\tchild = node.firstChild;\r\n\t\t\t\t\t\twhile (child) {\r\n\t\t\t\t\t\t\tnext = child.nextSibling;\r\n\t\t\t\t\t\t\tvisit(child);\r\n\t\t\t\t\t\t\tchild = next;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tnodes.forEach(visit);\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// makes emptied text nodes visible again\r\n\t\t//\r\n\t\tunhideTextNodesFromFragmentSource: function(nodes) {\r\n\t\t\t\r\n\t\t\tfunction visit(node) {\r\n\t\t\t\tvar child, next;\r\n\t\t\t\tswitch (node.nodeType) {\r\n\t\t\t\t\tcase 3: // Text node\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// we have to remove their content the hard way...\r\n\t\t\t\t\t\tif(\"cssRegionsSavedNodeValue\" in node) {\r\n\t\t\t\t\t\t\tnode.nodeValue = node.cssRegionsSavedNodeValue;\r\n\t\t\t\t\t\t\tdelete node.cssRegionsSavedNodeValue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tcase 1: // Element node\r\n\t\t\t\t\t\tif(typeof(k)==\"undefined\") return;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tcase 9: // Document node\r\n\t\t\t\t\tcase 11: // Document fragment node                    \r\n\t\t\t\t\t\tchild = node.firstChild;\r\n\t\t\t\t\t\twhile (child) {\r\n\t\t\t\t\t\t\tnext = child.nextSibling;\r\n\t\t\t\t\t\t\tvisit(child);\r\n\t\t\t\t\t\t\tchild = next;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tnodes.forEach(visit);\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// prepares the content elements to return to ther normal css life\r\n\t\t//\r\n\t\tunmarkNodesAsFragmentSource: function(nodes) {\r\n\t\t\t\r\n\t\t\tfunction visit(node,k) {\r\n\t\t\t\tvar child, next;\r\n\t\t\t\tswitch (node.nodeType) {\r\n\t\t\t\t\tcase 3: // Text node\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// we have to reinstall their content the hard way...\r\n\t\t\t\t\t\tif(\"cssRegionsSavedNodeValue\" in node) {\r\n\t\t\t\t\t\t\tnode.nodeValue = node.cssRegionsSavedNodeValue;\r\n\t\t\t\t\t\t\tdelete node.cssRegionsSavedNodeValue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 1: // Element node\r\n\t\t\t\t\t\tnode.removeAttribute('data-css-regions-cloned');\r\n\t\t\t\t\t\tnode.removeAttribute('data-css-regions-fragment-source');\r\n\t\t\t\t\t\tif(node.currentStyle) node.currentStyle.display.toString(); // IEFIX FOR BAD STYLE RECALC\r\n\t\t\t\t\t\tif(node.tagName==\"OL\") cssRegionsHelpers.unexpandListValues(node);\r\n\t\t\t\t\t\tif(typeof(k)!=\"undefined\" && node.tagName==\"LI\") cssRegionsHelpers.unexpandListValues(node.parentNode);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tcase 9: // Document node\r\n\t\t\t\t\tcase 11: // Document fragment node\r\n\t\t\t\t\t\tchild = node.firstChild;\r\n\t\t\t\t\t\twhile (child) {\r\n\t\t\t\t\t\t\tnext = child.nextSibling;\r\n\t\t\t\t\t\t\tvisit(child);\r\n\t\t\t\t\t\t\tchild = next;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tnodes.forEach(visit);\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// marks cloned content as fragment instead of as fragment source (basically)\r\n\t\t//\r\n\t\ttransformFragmentSourceToFragments: function(nodes) {\r\n\t\t\t\r\n\t\t\tfunction visit(node) {\r\n\t\t\t\tvar child, next;\r\n\t\t\t\tswitch (node.nodeType) {\r\n\t\t\t\t\tcase 1: // Element node\r\n\t\t\t\t\t\tvar id = node.getAttribute('data-css-regions-fragment-source');\r\n\t\t\t\t\t\tnode.removeAttribute('data-css-regions-fragment-source');\r\n\t\t\t\t\t\tnode.removeAttribute('data-css-regions-cloning');\r\n\t\t\t\t\t\tnode.removeAttribute('data-css-regions-cloned');\r\n\t\t\t\t\t\tnode.setAttribute('data-css-regions-fragment-of', id);\r\n\t\t\t\t\t\tif(node.id) node.id += \"--fragment\";\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tcase 9: // Document node\r\n\t\t\t\t\tcase 11: // Document fragment node\r\n\t\t\t\t\t\tchild = node.firstChild;\r\n\t\t\t\t\t\twhile (child) {\r\n\t\t\t\t\t\t\tnext = child.nextSibling;\r\n\t\t\t\t\t\t\tvisit(child);\r\n\t\t\t\t\t\t\tchild = next;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tnodes.forEach(visit);\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// removes some invisible text nodes from the tree\r\n\t\t// (useful if you don't want to face browser bugs when dealing with them)\r\n\t\t//\r\n\t\tembedTrailingWhiteSpaceNodes: function(fragment) {\r\n\t\t\t\r\n\t\t\tvar onlyWhiteSpace = /^\\s*$/;\r\n\t\t\tfunction visit(node) {\r\n\t\t\t\tvar child, next;\r\n\t\t\t\tswitch (node.nodeType) {\r\n\t\t\t\t\tcase 3: // Text node\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// we only remove nodes at the edges\r\n\t\t\t\t\t\tif (!node.previousSibling) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// we only remove nodes if their parent doesn't preserve whitespace\r\n\t\t\t\t\t\t\tif (getComputedStyle(node.parentNode).whiteSpace.substring(0,3)!==\"pre\") {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// only remove pure whitespace nodes\r\n\t\t\t\t\t\t\t\tif (onlyWhiteSpace.test(node.nodeValue)) {\r\n\t\t\t\t\t\t\t\t\tnode.parentNode.setAttribute('data-whitespace-before',node.nodeValue);\r\n\t\t\t\t\t\t\t\t\tnode.parentNode.removeChild(node);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// we only remove nodes at the edges\r\n\t\t\t\t\t\tif (!node.nextSibling) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// we only remove nodes if their parent doesn't preserve whitespace\r\n\t\t\t\t\t\t\tif (getComputedStyle(node.parentNode).whiteSpace.substring(0,3)!==\"pre\") {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// only remove pure whitespace nodes\r\n\t\t\t\t\t\t\t\tif (onlyWhiteSpace.test(node.nodeValue)) {\r\n\t\t\t\t\t\t\t\t\tnode.parentNode.setAttribute('data-whitespace-after',node.nodeValue);\r\n\t\t\t\t\t\t\t\t\tnode.parentNode.removeChild(node);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 1: // Element node\r\n\t\t\t\t\tcase 9: // Document node\r\n\t\t\t\t\tcase 11: // Document fragment node\r\n\t\t\t\t\t\tchild = node.firstChild;\r\n\t\t\t\t\t\twhile (child) {\r\n\t\t\t\t\t\t\tnext = child.nextSibling;\r\n\t\t\t\t\t\t\tvisit(child);\r\n\t\t\t\t\t\t\tchild = next;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvisit(fragment);\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// recover the previously removed invisible text nodes\r\n\t\t//\r\n\t\tunembedTrailingWhiteSpaceNodes: function(fragment) {\r\n\t\t\t\r\n\t\t\tvar onlyWhiteSpace = /^\\s*$/;\r\n\t\t\tfunction visit(node) {\r\n\t\t\t\tvar child, next;\r\n\t\t\t\tswitch (node.nodeType) {\r\n\t\t\t\t\tcase 1: // Element node\r\n\t\t\t\t\t\tvar txt = \"\";\r\n\t\t\t\t\t\tif(txt = node.getAttribute('data-whitespace-before')) {\r\n\t\t\t\t\t\t\tif(node.getAttribute('data-starting-fragment')=='' && node.getAttribute('data-special-starting-fragment','')) {\r\n\t\t\t\t\t\t\t\tnode.insertBefore(document.createTextNode(txt),node.firstChild);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnode.removeAttribute('data-whitespace-before')\r\n\t\t\t\t\t\tif(txt = node.getAttribute('data-whitespace-after')) {\r\n\t\t\t\t\t\t\tif(node.getAttribute('data-continued-fragment')=='' && node.getAttribute('data-special-continued-fragment','')) {\r\n\t\t\t\t\t\t\t\tnode.insertAfter(document.createTextNode(txt),node.lastChild);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnode.removeAttribute('data-whitespace-after')\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tcase 9: // Document node\r\n\t\t\t\t\tcase 11: // Document fragment node\r\n\t\t\t\t\t\tchild = node.firstChild;\r\n\t\t\t\t\t\twhile (child) {\r\n\t\t\t\t\t\t\tnext = child.nextSibling;\r\n\t\t\t\t\t\t\tvisit(child);\r\n\t\t\t\t\t\t\tchild = next;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvisit(fragment);\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t///\r\n\t\t/// walk the two trees the same way, and copy all the styles\r\n\t\t/// BEWARE: if the DOMs are different, funny things will happen\r\n\t\t/// NOTE: this function will also remove elements put in another flow\r\n\t\t///\r\n\t\tcopyStyle: function(root1, root2) {\r\n\t\t\t\r\n\t\t\tfunction visit(node1, node2, isRoot) {\r\n\t\t\t\tvar child1, next1, child2, next2;\r\n\t\t\t\tswitch (node1.nodeType) {\r\n\t\t\t\t\tcase 1: // Element node\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// firstly, setup a cache of all css properties on the element\r\n\t\t\t\t\t\tvar matchedRules = (node1.currentStyle && !window.opera) ? undefined : cssCascade.findAllMatchingRules(node1)\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// and compute the value of all css properties\r\n\t\t\t\t\t\tvar properties = cssCascade.allCSSProperties || cssCascade.getAllCSSProperties();\r\n\t\t\t\t\t\tfor(var p=properties.length; p--; ) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// if the property is computation-safe, use the computed value\r\n\t\t\t\t\t\t\tif(!(properties[p] in cssCascade.computationUnsafeProperties) && properties[p][0]!='-') {\r\n\t\t\t\t\t\t\t\tvar style = getComputedStyle(node1).getPropertyValue(properties[p]);\r\n\t\t\t\t\t\t\t\tvar defaultStyle = cssCascade.getDefaultStyleForTag(node1.tagName).getPropertyValue(properties[p]);\r\n\t\t\t\t\t\t\t\tif(style != defaultStyle) node2.style.setProperty(properties[p], style)\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// otherwise, get the element's specified value\r\n\t\t\t\t\t\t\tvar cssValue = cssCascade.getSpecifiedStyle(node1, properties[p], matchedRules);\r\n\t\t\t\t\t\t\tif(cssValue && cssValue.length) {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// if we have a specified value, let's use it\r\n\t\t\t\t\t\t\t\tnode2.style.setProperty(properties[p], cssValue.toCSSString());\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t} else if(isRoot && node1.parentNode && properties[p][0] != '-') {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// NOTE: the root will be detached from its parent\r\n\t\t\t\t\t\t\t\t// Therefore, we have to inherit styles from it (oh no!)\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// TODO: create a list of inherited properties\r\n\t\t\t\t\t\t\t\tif(!(properties[p] in cssCascade.inheritingProperties)) continue;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// if the property is computation-safe, use the computed value\r\n\t\t\t\t\t\t\t\tif((properties[p]==\"font-size\") || (!(properties[p] in cssCascade.computationUnsafeProperties) && properties[p][0]!='-')) {\r\n\t\t\t\t\t\t\t\t\tvar style = getComputedStyle(node1).getPropertyValue(properties[p]);\r\n\t\t\t\t\t\t\t\t\tnode2.style.setProperty(properties[p], style);\r\n\t\t\t\t\t\t\t\t\t//var parentStyle = style; try { parentStyle = getComputedStyle(node1.parentNode).getPropertyValue(properties[p]) } catch(ex){}\r\n\t\t\t\t\t\t\t\t\t//var defaultStyle = cssCascade.getDefaultStyleForTag(node1.tagName).getPropertyValue(properties[p]);\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t//if(style === parentStyle) {\r\n\t\t\t\t\t\t\t\t\t//  node2.style.setProperty(properties[p], style)\r\n\t\t\t\t\t\t\t\t\t//}\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// otherwise, get the parent's specified value\r\n\t\t\t\t\t\t\t\tvar cssValue = cssCascade.getSpecifiedStyle(node1, properties[p], matchedRules);\r\n\t\t\t\t\t\t\t\tif(cssValue && cssValue.length) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// if we have a specified value, let's use it\r\n\t\t\t\t\t\t\t\t\tnode2.style.setProperty(properties[p], cssValue.toCSSString());\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// now, let's work on ::after and ::before\r\n\t\t\t\t\t\tvar importPseudo = function(node1,node2,pseudo) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t//\r\n\t\t\t\t\t\t\t// we'll need to use getSpecifiedStyle here as the pseudo thing is slow\r\n\t\t\t\t\t\t\t//\r\n\t\t\t\t\t\t\tvar mayExist = !!cssCascade.findAllMatchingRulesWithPseudo(node1,pseudo.substr(1)).length;\r\n\t\t\t\t\t\t\tif(!mayExist) return;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tvar pseudoStyle = getComputedStyle(node1,pseudo);\r\n\t\t\t\t\t\t\tif(pseudoStyle.content!='none'){\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// let's create a stylesheet for the element\r\n\t\t\t\t\t\t\t\tvar stylesheet = document.createElement('style');\r\n\t\t\t\t\t\t\t\tstylesheet.setAttribute('data-no-css-polyfill',true);\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// compute the value of all css properties\r\n\t\t\t\t\t\t\t\tvar node2style = \"\";\r\n\t\t\t\t\t\t\t\tvar properties = cssCascade.allCSSProperties || cssCascade.getAllCSSProperties();\r\n\t\t\t\t\t\t\t\tfor(var p=properties.length; p--; ) {\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t// we always use the computed value, because we don't have better\r\n\t\t\t\t\t\t\t\t\tvar style = pseudoStyle.getPropertyValue(properties[p]);\r\n\t\t\t\t\t\t\t\t\tnode2style += properties[p]+\":\"+style+\";\";\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tstylesheet.textContent = (\r\n\t\t\t\t\t\t\t\t\t'[data-css-regions-fragment-of=\"' + node1.getAttribute('data-css-regions-fragment-source') + '\"]' \r\n\t\t\t\t\t\t\t\t\t+':not([data-css-regions-starting-fragment]):not([data-css-regions-special-starting-fragment])'\r\n\t\t\t\t\t\t\t\t\t+':'+pseudo+'{'\r\n\t\t\t\t\t\t\t\t\t+node2style\r\n\t\t\t\t\t\t\t\t\t+\"}\"\r\n\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tnode2.parentNode.insertBefore(stylesheet, node2);\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\timportPseudo(node1,node2,\":before\");\r\n\t\t\t\t\t\timportPseudo(node1,node2,\":after\");\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// retarget events\r\n\t\t\t\t\t\tcssRegionsHelpers.retargetEvents(node1,node2);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\r\n\t\t\t\t\tcase 9: // Document node\r\n\t\t\t\t\tcase 11: // Document fragment node\r\n\t\t\t\t\t\tchild1 = node1.firstChild;\r\n\t\t\t\t\t\tchild2 = node2.firstChild;\r\n\t\t\t\t\t\twhile (child1) {\r\n\t\t\t\t\t\t\tnext1 = child1.nextSibling;\r\n\t\t\t\t\t\t\tnext2 = child2.nextSibling;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// decide between process style or hide\r\n\t\t\t\t\t\t\tif(child1.cssRegionsLastFlowIntoName && child1.cssRegionsLastFlowIntoType===\"element\") {\r\n\t\t\t\t\t\t\t\tnode2.removeChild(child2);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tvisit(child1, child2);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tchild1 = next1;\r\n\t\t\t\t\t\t\tchild2 = next2;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvisit(root1, root2, true);\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// make sure the most critical events still fire in the fragment source\r\n\t\t// even if the browser initially fire them on the fragments\r\n\t\t//\r\n\t\tretargetEvents: function retargetEvents(node1,node2) {\r\n\t\t\t\r\n\t\t\tvar retargetEvent = \"cssRegionsHelpers.retargetEvent(this,event)\";\r\n\t\t\tnode2.setAttribute(\"onclick\", retargetEvent);\r\n\t\t\tnode2.setAttribute(\"ondblclick\", retargetEvent);\r\n\t\t\tnode2.setAttribute(\"onmousedown\", retargetEvent);\r\n\t\t\tnode2.setAttribute(\"onmouseup\", retargetEvent);\r\n\t\t\tnode2.setAttribute(\"onmousein\", retargetEvent);\r\n\t\t\tnode2.setAttribute(\"onmouseout\", retargetEvent);\r\n\t\t\tnode2.setAttribute(\"onmouseenter\", retargetEvent);\r\n\t\t\tnode2.setAttribute(\"onmouseleave\", retargetEvent);\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t//\r\n\t\t// single hub for event retargeting operations.\r\n\t\t//\r\n\t\tretargetEvent: function retargeEvent(node2,e) {\r\n\t\t\t\r\n\t\t\t// get the node we should fire the event on\r\n\t\t\tvar node1 = (\r\n\t\t\t\t(node2.cssRegionsFragmentSource) ||\r\n\t\t\t\t(node2.cssRegionsFragmentSource=document.querySelector('[data-css-regions-fragment-source=\"' + node2.getAttribute('data-css-regions-fragment-of') + '\"]'))\r\n\t\t\t);\r\n\t\t\t\r\n\t\t\tif(node1) {\r\n\t\t\t\r\n\t\t\t\t// dispatch the event on the real node\r\n\t\t\t\tvar ne = domEvents.cloneEvent(e);\r\n\t\t\t\tnode1.dispatchEvent(ne);\r\n\t\t\t\t\r\n\t\t\t\t// prevent the event to fire on the region\r\n\t\t\t\te.stopImmediatePropagation ? e.stopImmediatePropagation() : e.stopPropagation();\r\n\t\t\t\t\r\n\t\t\t\t// make sure to cancel the event if required\r\n\t\t\t\tif(ne.isDefaultPrevented || ne.defaultPrevented) { e.preventDefault(); return false; }\r\n\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t};\r\n\t\r\n\treturn cssRegionsHelpers;\r\n\t\r\n})(window, document);\nrequire.define('src/css-regions/lib/helpers.js');","//\r\n// this module holds the front-facing features of the polyfill\r\n//\r\nmodule.exports = (function(window, document, cssRegions) { \"use strict\";\r\n\r\n\tvar domEvents = require('src/core/dom-events.js');\r\n\tvar cssSyntax = require('src/core/css-syntax.js');\r\n\tvar cssCascade = require('src/core/css-cascade.js');\r\n\tvar cssBreak = require('src/core/css-break.js');\r\n\tvar cssRegionsHelpers = require('src/css-regions/lib/helpers.js');\r\n\tvar ES = require('src/core/dom-experimental-event-streams.js');\r\n\r\n\t// \r\n\t// this class contains flow-relative data field\r\n\t// \r\n\tcssRegions.Flow = function NamedFlow(name) {\r\n\t\t\r\n\t\t// TODO: force immediate relayout if someone ask the overset properties\r\n\t\t// and the layout has been deemed wrong (still isn't a proof of correctness but okay)\r\n\t\t\r\n\t\t// define the flow name\r\n\t\tthis.name = name; Object.defineProperty(this, \"name\", {get: function() { return name; }});\r\n\t\t\r\n\t\t// define the overset status\r\n\t\tthis.overset = false;\r\n\t\t\r\n\t\t// define the first empty region\r\n\t\tthis.firstEmptyRegionIndex = -1;\r\n\t\t\r\n\t\t// elements poured into the flow\r\n\t\tthis.content = []; this.lastContent = [];\r\n\t\t\r\n\t\t// elements that consume this flow\r\n\t\tthis.regions = []; this.lastRegions = [];\r\n\t\t\r\n\t\t// event handlers\r\n\t\tthis.eventListeners = {\r\n\t\t\t\"regionfragmentchange\": [],\r\n\t\t\t\"regionoversetchange\": [],\r\n\t\t};\r\n\t\t\r\n\t\t// this function is used to work with dom event streams\r\n\t\tvar This=this; This.update = function(stream) {\r\n\t\t\tstream.schedule(This.update); This.relayout();\r\n\t\t};\r\n\t\t\r\n\t\t// register to style changes already\r\n\t\tThis.lastStylesheetAdded = 0;\r\n\t\tcssCascade.addEventListener('stylesheetadded', function() {\r\n\t\t\tif(This.lastStylesheetAdded - Date() > 100) {\r\n\t\t\t\tThis.lastStylesheetAdded = +Date();\r\n\t\t\t\tThis.relayout();\r\n\t\t\t} else {\r\n\t\t\t\tcssConsole.warn(\"Please don't add stylesheets as a response to region events. Operation cancelled.\")\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\t// a small counter to avoid enter retry loops\r\n\t\tThis.failedLayoutCount = 0;\r\n\t\t\r\n\t\t// some other fields\r\n\t\tThis.lastEventRAF = 0;\r\n\t\tThis.restartLayout = false;\r\n\t}\r\n\t\t\r\n\tcssRegions.Flow.prototype.removeFromContent = function(element) {\r\n\t\t\r\n\t\t// clean up stuff\r\n\t\tthis.removeEventListenersOf(element);\r\n\t\t\r\n\t\t// remove reference\r\n\t\tvar index = this.content.indexOf(element);\r\n\t\tif(index>=0) { this.content.splice(index,1); }\r\n\t\t\r\n\t};\r\n\r\n\tcssRegions.Flow.prototype.removeFromRegions = function(element) {\r\n\t\t\r\n\t\t// clean up stuff\r\n\t\tthis.removeEventListenersOf(element);\r\n\t\t\r\n\t\t// remove reference\r\n\t\tvar index = this.regions.indexOf(element);\r\n\t\tif(index>=0) { this.regions.splice(index,1); }\r\n\t\t\r\n\t};\r\n\r\n\tcssRegions.Flow.prototype.addToContent = function(element) {\r\n\t\t\r\n\t\t// handle trivial cases real quick\r\n\t\tvar content = this.content; \r\n\t\tif(content.length==0 || content[content.length-1].nextSibling === element) {\r\n\t\t\tcontent.push(element);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif(content[0].previousSibling === element) {\r\n\t\t\tcontent.unshift(element);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\t// walk the tree to find an element inside the content chain\r\n\t\tvar currentNodeIndex = -1;\r\n\t\tvar treeWalker = document.createTreeWalker(\r\n\t\t\tdocument.documentElement,\r\n\t\t\tNodeFilter.SHOW_ELEMENT,\r\n\t\t\tfunction(node) { \r\n\t\t\t\treturn (currentNodeIndex = content.indexOf(node)) >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP; \r\n\t\t\t},\r\n\t\t\tfalse\r\n\t\t); \r\n\t\t\r\n\t\t// which by the way has to be after the considered element\r\n\t\ttreeWalker.currentNode = element;\r\n\t\t\r\n\t\t// if we find such node\r\n\t\tif(treeWalker.nextNode()) {\r\n\t\t\t\r\n\t\t\t// insert the element at his current location\r\n\t\t\tcontent.splice(currentNodeIndex,0,element);\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\t\r\n\t\t\t// add the new element to the end of the array\r\n\t\t\tcontent.push(element);\r\n\t\t\t\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tcssRegions.Flow.prototype.addToRegions = function(element) {\r\n\t\t\r\n\t\t// walk the tree to find an element inside the region chain\r\n\t\tvar regions = this.regions;\r\n\t\tvar treeWalker = document.createTreeWalker(\r\n\t\t\tdocument.documentElement,\r\n\t\t\tNodeFilter.SHOW_ELEMENT,\r\n\t\t\tfunction(node) { \r\n\t\t\t\treturn regions.indexOf(node) >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT; \r\n\t\t\t},\r\n\t\t\tfalse\r\n\t\t);\r\n\t\t\r\n\t\t// which by the way has to be after the considered element\r\n\t\ttreeWalker.currentNode = element;\r\n\t\t\r\n\t\t// if we find such node\r\n\t\tif(treeWalker.nextNode()) {\r\n\t\t\t\r\n\t\t\t// insert the element at his current location\r\n\t\t\tregions.splice(this.regions.indexOf(treeWalker.currentNode),0,element);\r\n\t\t\t\r\n\t\t} else {\r\n\t\t\t\r\n\t\t\t// add the new element to the end of the array\r\n\t\t\tregions.push(element);\r\n\t\t}\r\n\t\t\r\n\t};\r\n\r\n\tcssRegions.Flow.prototype.generateContentFragment = function() {\r\n\t\tvar fragment = document.createDocumentFragment(); var This=this;\r\n\r\n\t\t// add copies of all due content\r\n\t\tfor(var i=0; i<this.content.length; i++) {\r\n\t\t\tvar element = this.content[i];\r\n\t\t\t\r\n\t\t\t// \r\n\t\t\t// STEP 1: IDENTIFY FRAGMENT SOURCES AS SUCH\r\n\t\t\t//\r\n\t\t\tcssRegionsHelpers.markNodesAsFragmentSource([element], element.cssRegionsLastFlowIntoType==\"content\");\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// STEP 2: CLONE THE FRAGMENT SOURCES\r\n\t\t\t// \r\n\t\t\t\r\n\t\t\t// depending on the requested behavior\r\n\t\t\tif(element.cssRegionsLastFlowIntoType==\"element\") {\r\n\t\t\t\t\r\n\t\t\t\t\t// add the element\r\n\t\t\t\t\tvar el = element;\r\n\t\t\t\t\tvar elClone = el.cloneNode(true);\r\n\t\t\t\t\tvar elToInsert = elClone; if(elToInsert.tagName==\"LI\") {\r\n\t\t\t\t\t\telToInsert = document.createElement(el.parentNode.tagName);\r\n\t\t\t\t\t\telToInsert.style.margin=\"0\";\r\n\t\t\t\t\t\telToInsert.style.padding=\"0\";\r\n\t\t\t\t\t\telToInsert.appendChild(elClone);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfragment.appendChild(elToInsert);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// clone the style\r\n\t\t\t\t\tcssRegionsHelpers.copyStyle(el, elClone);\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// add current children\r\n\t\t\t\tvar el = element.firstChild; while(el) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// add the element\r\n\t\t\t\t\tvar elClone = el.cloneNode(true);\r\n\t\t\t\t\tvar elToInsert = elClone; if(elToInsert.tagName==\"LI\") {\r\n\t\t\t\t\t\telToInsert = document.createElement(el.parentNode.tagName);\r\n\t\t\t\t\t\telToInsert.style.margin=\"0\";\r\n\t\t\t\t\t\telToInsert.style.padding=\"0\";\r\n\t\t\t\t\t\telToInsert.appendChild(elClone);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfragment.appendChild(elToInsert);\r\n\t\t\t\t\t\r\n\t\t\t\t\t// clone the style\r\n\t\t\t\t\tcssRegionsHelpers.copyStyle(el, elClone);\r\n\t\t\t\t\t\r\n\t\t\t\t\tel = el.nextSibling;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t//\r\n\t\t// STEP 3: HIDE TEXT NODES IN FRAGMENT SOURCES\r\n\t\t//\r\n\t\tcssRegionsHelpers.hideTextNodesFromFragmentSource(this.content);\r\n\t\t\r\n\t\t//\r\n\t\t// STEP 4: CONVERT CLONED FRAGMENT SOURCES INTO TRUE FRAGMENTS\r\n\t\t//\r\n\t\tcssRegionsHelpers.transformFragmentSourceToFragments(\r\n\t\t\tArray.prototype.slice.call(fragment.childNodes,0)\r\n\t\t)\r\n\t\t\r\n\t\t\r\n\t\t//\r\n\t\t// CLONED CONTENT IS READY!\r\n\t\t//\r\n\t\treturn fragment;\r\n\t}\r\n\r\n\tcssRegions.Flow.prototype.relayout = function() {\r\n\t\tvar This = this;\r\n\t\t\r\n\t\t// prevent previous relayouts from eventing\r\n\t\tcancelAnimationFrame(This.lastEventRAF);\r\n\t\t\r\n\t\t// batch relayout queries\r\n\t\tif(This.relayoutScheduled) { return; }\r\n\t\tif(This.relayoutInProgress) { This.restartLayout=true; return; }\r\n\t\tThis.relayoutScheduled = true;\r\n\t\trequestAnimationFrame(function() { This._relayout() });\r\n\t\t\r\n\t}\r\n\r\n\tcssRegions.Flow.prototype._relayout = function(data){\r\n\t\tvar This=this;\r\n\t\t\r\n\t\ttry {\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// note: it is recommended to look at the beautiful \r\n\t\t\t// drawings I made before attempting to understand\r\n\t\t\t// this stuff. If you don't have them, ask me.\r\n\t\t\t//\r\n\t\t\tcssConsole.log(\"starting a new relayout for \"+This.name);\r\n\t\t\tThis.relayoutInProgress=true; This.relayoutScheduled=false;\r\n\t\t\tThis.lastRelayout = +new Date();\r\n\t\t\t//debugger;\r\n\t\t\t\r\n\t\t\t// NOTE: we recover the scroll position in case the browser mess it up\r\n\t\t\tvar docElmScrollTop = data && data.docElmScrollTop ? data.docElmScrollTop : document.documentElement.scrollTop;\r\n\t\t\tvar docBdyScrollTop = data && data.docBdyScrollTop ? data.docBdyScrollTop : document.body.scrollTop;\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// STEP 1: REMOVE PREVIOUS EVENT LISTENERS\r\n\t\t\t//\r\n\t\t\t\r\n\t\t\t// remove the listeners from everything\r\n\t\t\tThis.removeEventListenersOf(This.lastRegions);\r\n\t\t\tThis.removeEventListenersOf(This.lastContent);\r\n\t\t\tcancelAnimationFrame(This.lastEventRAF);\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// STEP 2: RESTORE CONTENT/REGIONS TO A CLEAN STATE\r\n\t\t\t//\r\n\t\t\t\r\n\t\t\t// detect elements being removed of the document\r\n\t\t\tThis.regions = This.regions.filter(function(e) { return document.documentElement.contains(e); })\r\n\t\t\tThis.content = This.content.filter(function(e) { return document.documentElement.contains(e); })\r\n\t\t\t\r\n\t\t\t// cleanup previous layout\r\n\t\t\tcssRegionsHelpers.unmarkNodesAsRegion(This.lastRegions); This.lastRegions = This.regions.slice(0);\r\n\t\t\tcssRegionsHelpers.unmarkNodesAsFragmentSource(This.lastContent); This.lastContent = This.content.slice(0);\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// STEP 3: EMPTY ALL REGIONS\r\n\t\t\t// ADD WRAPPER FOR FLOW CONTENT\r\n\t\t\t// PREPARE FOR CONTENT CLONING\r\n\t\t\t//\r\n\t\t\t\r\n\t\t\t// empty all the regions\r\n\t\t\tcssRegionsHelpers.markNodesAsRegion(This.regions);\r\n\t\t\t\r\n\t\t\t// create a fresh list of the regions\r\n\t\t\tvar regionStack = This.regions.slice(0).reverse();\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// STEP 4: CLONE THE CONTENT\r\n\t\t\t// ADD METADATA TO CLONED CONTENT\r\n\t\t\t// HIDE FLOW CONTENT AT INITIAL POSITION\r\n\t\t\t//\r\n\t\t\t\r\n\t\t\t// create a fresh list of the content\r\n\t\t\t// compute the style of all source elements\r\n\t\t\t// generate stylesheets for those rules\r\n\t\t\tvar contentFragment = This.generateContentFragment();\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// STEP 5: POUR CONTENT INTO THE REGIONS\r\n\t\t\t//\r\n\t\t\t\r\n\t\t\t// layout this stuff\r\n\t\t\tcssRegions.layoutContent(regionStack, contentFragment, {\r\n\t\t\t\tonprogress: function(continueLayout) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// NOTE: we recover the scroll position in case the browser mess it up\r\n\t\t\t\t\tdocument.documentElement.scrollTop = docElmScrollTop;\r\n\t\t\t\t\tdocument.body.scrollTop = docBdyScrollTop;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// NOTE: if the current layout goes nowhere, start a new one already\r\n\t\t\t\t\tif(This.restartLayout) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tThis.relayoutInProgress = false;\r\n\t\t\t\t\t\tThis.failedLayoutCount = 0;\r\n\t\t\t\t\t\tThis.restartLayout = false;\r\n\t\t\t\t\t\tThis._relayout({\r\n\t\t\t\t\t\t\tdocElmScrollTop: docElmScrollTop,\r\n\t\t\t\t\t\t\tdocBdyScrollTop: docBdyScrollTop\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tsetImmediate(continueLayout);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t},\r\n\t\t\t\tondone: function onLayoutDone(overset) {\r\n\t\t\t\t\r\n\t\t\t\t\tThis.overset = overset;\r\n\t\t\t\t\tThis.firstEmptyRegionIndex = This.regions.length-1; while(This.regions[This.firstEmptyRegionIndex]) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t\t// tell whether the region is empty\r\n\t\t\t\t\t\tvar isEmpty = false;\r\n\t\t\t\t\t\tisEmpty = isEmpty || !This.regions[This.firstEmptyRegionIndex].cssRegionsWrapper;\r\n\t\t\t\t\t\tisEmpty = isEmpty || !This.regions[This.firstEmptyRegionIndex].cssRegionsWrapper.firstChild;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// if the region is not empty\r\n\t\t\t\t\t\tif(!isEmpty) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// the first empty region if the next one, if it exists\r\n\t\t\t\t\t\t\tif((++This.firstEmptyRegionIndex)==This.regions.length) {\r\n\t\t\t\t\t\t\t\tThis.firstEmptyRegionIndex = -1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t \r\n\t\t\t\t\t\t\t// else, let's try the previous region\r\n\t\t\t\t\t\t\tThis.firstEmptyRegionIndex--; \r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t//\r\n\t\t\t\t\t// STEP 6: REGISTER TO UPDATE EVENTS\r\n\t\t\t\t\t//\r\n\t\t\t\t\t\r\n\t\t\t\t\t// make sure regions update are taken in consideration\r\n\t\t\t\t\tif(window.MutationObserver) {\r\n\t\t\t\t\t\tThis.addEventListenersTo(This.content);\r\n\t\t\t\t\t\tThis.addEventListenersTo(This.regions);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// the other browsers don't get this as acurately\r\n\t\t\t\t\t\t// but that shouldn't be that of an issue for 99% of the cases\r\n\t\t\t\t\t\tsetImmediate(function() {\r\n\t\t\t\t\t\t\tThis.addEventListenersTo(This.content);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t//\r\n\t\t\t\t\t// STEP 7: FIRE SOME EVENTS\r\n\t\t\t\t\t//\r\n\t\t\t\t\tif(This.regions.length > 0 && !This.restartLayout) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// before doing anything, let's check our stuff is consistent\r\n\t\t\t\t\t\tvar isBuggy = false;\r\n\t\t\t\t\t\tisBuggy = isBuggy || This.regions.some(function(e) { return !document.documentElement.contains(e); })\r\n\t\t\t\t\t\tisBuggy = isBuggy || This.content.some(function(e) { return !document.documentElement.contains(e); })\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif(isBuggy) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// if we found any bug, we will need to restart a layout\r\n\t\t\t\t\t\t\tcssConsole.warn(\"Buggy css regions layout: the page changed; we need to restart.\");\r\n\t\t\t\t\t\t\tThis.restartLayout = true; \r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// if it was okay, let's fire some event\r\n\t\t\t\t\t\t\tThis.lastEventRAF = requestAnimationFrame(function() {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// TODO: only fire when necessary but...\r\n\t\t\t\t\t\t\t\tThis.dispatchEvent('regionfragmentchange');\r\n\t\t\t\t\t\t\t\tThis.dispatchEvent('regionoversetchange');\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\t\r\n\t\t\t\t\t// NOTE: we recover the scroll position in case the browser mess it up\r\n\t\t\t\t\tdocument.documentElement.scrollTop = docElmScrollTop;\r\n\t\t\t\t\tdocument.body.scrollTop = docBdyScrollTop;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// mark layout has being done\r\n\t\t\t\t\tThis.relayoutInProgress = false;\r\n\t\t\t\t\tThis.failedLayoutCount = 0;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// restart a layout if a request was queued during the current one\r\n\t\t\t\t\tif(This.restartLayout) {\r\n\t\t\t\t\t\tThis.restartLayout = false;\r\n\t\t\t\t\t\tThis.relayout();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t\r\n\t\t} catch(ex) {\r\n\t\t\t\r\n\t\t\t// sometimes IE fails for no valid reason \r\n\t\t\t// (other than the page is still loading)\r\n\t\t\tsetImmediate(function() { throw ex; });\r\n\t\t\t\r\n\t\t\t// but we cannot accept to fail, so we need to try again\r\n\t\t\t// until we finish a complete layout pass...\r\n\t\t\tThis.failedLayoutCount++;\r\n\t\t\tif(This.failedLayoutCount<7) {requestAnimationFrame(function() { This._relayout() });}\r\n\t\t\telse {This.failedLayoutCount=0; This.relayoutScheduled=false; This.relayoutInProgress=false; This.restartLayout=false; }\r\n\t\t\t\r\n\t\t}\r\n\t}\r\n\r\n\tcssRegions.Flow.prototype.relayoutIfSizeChanged = function() {\r\n\t\t\r\n\t\t// go through all regions\r\n\t\t// and see if any did change of size\r\n\t\tvar rs = this.regions;     \r\n\t\tfor(var i=rs.length; i--; ) {\r\n\t\t\tif(\r\n\t\t\t\trs[i].offsetHeight !== rs[i].cssRegionsLastOffsetHeight\r\n\t\t\t\t|| rs[i].offsetWidth !== rs[i].cssRegionsLastOffsetWidth\r\n\t\t\t) {\r\n\t\t\t\tthis.relayout(); return;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n\tcssRegions.Flow.prototype.addEventListenersTo = function(nodes) {\r\n\t\tvar This=this; if(nodes instanceof Element) { nodes=[nodes] }\r\n\t\t\r\n\t\tnodes.forEach(function(element) {\r\n\t\t\tif(!element.cssRegionsEventStream) {\r\n\t\t\t\telement.cssRegionsEventStream = new ES.DOMUpdateEventStream({target: element});\r\n\t\t\t\telement.cssRegionsEventStream.schedule(This.update);\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t}\r\n\r\n\tcssRegions.Flow.prototype.removeEventListenersOf = function(nodes) {\r\n\t\tvar This=this; if(nodes instanceof Element) { nodes=[nodes] }\r\n\t\t\r\n\t\tnodes.forEach(function(element) {\r\n\t\t\tif(element.cssRegionsEventStream) {\r\n\t\t\t\telement.cssRegionsEventStream.dispose();\r\n\t\t\t\tdelete element.cssRegionsEventStream;\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t}\r\n\r\n\t// alias\r\n\tcssRegions.NamedFlow = cssRegions.Flow;\r\n\r\n\t// return a disconnected array of the content of a NamedFlow\r\n\tcssRegions.NamedFlow.prototype.getContent = function getContent() {\r\n\t\treturn this.content.slice(0)\r\n\t}\r\n\r\n\t// return a disconnected array of the regions of a NamedFlow\r\n\tcssRegions.NamedFlow.prototype.getRegions = function getRegions() {\r\n\t\treturn this.regions.slice(0)\r\n\t}\r\n\r\n\tcssRegions.NamedFlow.prototype.getRegionsByContent = function getRegionsByContent(node) {\r\n\t\tvar regions = [];\r\n\t\tvar fragments = document.querySelectorAll('[data-css-regions-fragment-of=\"'+node.getAttribute('data-css-regions-fragment-source')+'\"]');\r\n\t\tfor (var i=0; i<fragments.length; i++) {\r\n\t\t\t\r\n\t\t\tvar current=fragments[i]; do {\r\n\t\t\t\t\r\n\t\t\t\tif(current.getAttribute('data-css-region')) {\r\n\t\t\t\t\tregions.push(current); break;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} while(current=current.parentNode);\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\treturn regions;\r\n\t}\r\n\r\n\tdomEvents.EventTarget.implementsIn(cssRegions.Flow);\r\n\r\n\t//\r\n\t// this class is a collection of named flows (not an array, sadly)\r\n\t//\r\n\tcssRegions.NamedFlowCollection = function NamedFlowCollection() {\r\n\t\t\r\n\t\tthis.length = 0;\r\n\t\t\r\n\t}\r\n\r\n\tcssRegions.NamedFlowCollection.prototype.namedItem = function(k) {\r\n\t\treturn cssRegions.flows[k] || (cssRegions.flows[k]=new cssRegions.Flow(k));\r\n\t}\r\n\r\n\r\n\t//\r\n\t// this helper creates the required methods on top of the DOM {ie: public exports}\r\n\t//\r\n\tcssRegions.enablePolyfillObjectModel = function() {\r\n\t\t\r\n\t\t//\r\n\t\t// DOCUMENT INTERFACE\r\n\t\t//\r\n\t\t\r\n\t\t//\r\n\t\t// returns a static list of active named flows\r\n\t\t//\r\n\t\tdocument.getNamedFlows = function() {\r\n\t\t\t\t\r\n\t\t\tvar c = new cssRegions.NamedFlowCollection(); var flows = cssRegions.flows;\r\n\t\t\tfor(var flowName in cssRegions.flows) {\r\n\t\t\t\t\r\n\t\t\t\tif(Object.prototype.hasOwnProperty.call(flows, flowName)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// only active flows can be included\r\n\t\t\t\t\tif(flows[flowName].content.length!=0 || flows[flowName].regions.length!=0) {\r\n\t\t\t\t\t\tc[c.length++] = c[flowName] = flows[flowName];\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\treturn c;\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t//\r\n\t\t// returns a live object for any named flow\r\n\t\t//\r\n\t\tdocument.getNamedFlow = function(flowName) {\r\n\t\t\t\t\r\n\t\t\tvar flows = cssRegions.flows;\r\n\t\t\treturn (flows[flowName] || (flows[flowName]=new cssRegions.NamedFlow(flowName)));\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t//\r\n\t\t// ELEMENT INTERFACE\r\n\t\t//    \r\n\t\tObject.defineProperties(\r\n\t\t\tElement.prototype,\r\n\t\t\t{\r\n\t\t\t\t\"regionOverset\": {\r\n\t\t\t\t\tget: function() {\r\n\t\t\t\t\t\treturn this._regionOverset || 'fit';\r\n\t\t\t\t\t},\r\n\t\t\t\t\tset: function(value) {\r\n\t\t\t\t\t\tthis._regionOverset = value;\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t\"getRegionFlowRanges\": {\r\n\t\t\t\t\tvalue: function getRegionFlowRanges() {\r\n\t\t\t\t\t\treturn null; // TODO: can we implement that? I think we can't (properly).\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\t\"getComputedRegionStyle\": {\r\n\t\t\t\t\tvalue: function getComputedRegionStyle(element,pseudo) {\r\n\t\t\t\t\t\t// TODO: only works while we don't relayout\r\n\t\t\t\t\t\t// TODO: only works properly for elements actually in the region\r\n\t\t\t\t\t\tvar fragment = document.querySelector('[data-css-regions-fragment-of=\"'+element.getAttribute('data-css-regions-fragment-source')+'\"]');\r\n\t\t\t\t\t\tif(pseudo) {\r\n\t\t\t\t\t\t\treturn getComputedStyle(fragment||element, pseudo);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\treturn getComputedStyle(fragment||element);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t)\r\n\t\t\r\n\t\t\r\n\t\t//\r\n\t\t// CSSStyleDeclaration interface\r\n\t\t//\r\n\t\tcssCascade.polyfillStyleInterface('flow-into');\r\n\t\tcssCascade.polyfillStyleInterface('flow-from');\r\n\t\tcssCascade.polyfillStyleInterface('region-fragment');\r\n\t\tcssCascade.polyfillStyleInterface('break-before');\r\n\t\tcssCascade.polyfillStyleInterface('break-after');\r\n\r\n\t}\r\n\r\n\t// load the polyfill immediately if not especially told otherwise\r\n\tif(!(\"cssRegionsManualTrigger\" in window)) { cssRegions.enablePolyfill(); }\r\n\t\r\n});\nrequire.define('src/css-regions/lib/objectmodel.js');","//\r\n// this module holds the big-picture actions of the polyfill\r\n//\r\nmodule.exports = (function(window, document) { \"use strict\";\r\n\r\n\tvar domEvents = require('src/core/dom-events.js');\r\n\tvar cssSyntax = require('src/core/css-syntax.js');\r\n\tvar cssCascade = require('src/core/css-cascade.js');\r\n\tvar cssBreak = require('src/core/css-break.js');\r\n\t\r\n\trequire('src/css-regions/lib/range-extensions.js');\r\n\tvar cssRegionsHelpers = require('src/css-regions/lib/helpers.js');\r\n\tvar enableObjectModel = require('src/css-regions/lib/objectmodel.js');\r\n\t\r\n\tvar CSS_STYLE = \"cssregion,[data-css-region]>*,[data-css-regions-fragment-source]:not([data-css-regions-cloning]),[data-css-regions-fragment-source][data-css-regions-cloned]{display:none!important}[data-css-region]>cssregion:last-of-type{display:inline!important}[data-css-region]{content:normal!important}[data-css-special-continued-fragment]{counter-reset:none!important;counter-increment:none!important;margin-bottom:0!important;border-bottom-left-radius:0!important;border-bottom-right-radius:0!important}[data-css-continued-fragment]{counter-reset:none!important;counter-increment:none!important;margin-bottom:0!important;padding-bottom:0!important;border-bottom:none!important;border-bottom-left-radius:0!important;border-bottom-right-radius:0!important}[data-css-continued-fragment]::after{content:none!important;display:none!important}[data-css-special-starting-fragment]{text-indent:0!important;margin-top:0!important}[data-css-starting-fragment]{text-indent:0!important;margin-top:0!important;padding-top:0!important;border-top:none!important;border-top-left-radius:0!important;border-top-right-radius:0!important}[data-css-starting-fragment]::before{content:none!important;display:none!important}[data-css-continued-block-fragment][data-css-continued-fragment]:not(:empty)::after{content:''!important;display:inline-block!important;width:100%!important;height:0!important;font-size:0!important;line-height:0!important;margin:0!important;padding:0!important;border:0!important}\";\r\n\r\n\tvar cssRegions = {\r\n\t\t\r\n\t\t//\r\n\t\t// this function is at the heart of the region polyfill\r\n\t\t// it will iteratively fill a list of regions until no\r\n\t\t// content or no region is left\r\n\t\t//\r\n\t\t// the before-overflow size of a region is determined by\r\n\t\t// adding all content to it and comparing his offsetHeight\r\n\t\t// and his scrollHeight\r\n\t\t//\r\n\t\t// when this is done, we use dom ranges to detect the point\r\n\t\t// where the content exceed this box and we split the fragment\r\n\t\t// at that point.\r\n\t\t//\r\n\t\t// when splitting inside an element, the borders, paddings and\r\n\t\t// generated content must be tied to the right fragments which\r\n\t\t// require some code\r\n\t\t//\r\n\t\t// this functions returns whether some content was still remaining\r\n\t\t// when the flow when the last region was filled. please not this\r\n\t\t// can only happen if this last region has \"region-fragment\" set\r\n\t\t// to break, otherwhise all the content will automatically overflow\r\n\t\t// this last region.\r\n\t\t//\r\n\t\tlayoutContent: function(regions, remainingContent, callback, startTime) {\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// this function will iteratively fill all the regions\r\n\t\t\t// when we reach the last region, we return the overset status\r\n\t\t\t//\r\n\t\t\t\r\n\t\t\t// validate args\r\n\t\t\tif(!regions) return callback.ondone(!!remainingContent.hasChildNodes());\r\n\t\t\tif(!regions.length) return callback.ondone(!!remainingContent.hasChildNodes());\r\n\t\t\tif(!startTime) startTime = Date.now();\r\n\t\t\t\r\n\t\t\t// get the next region\r\n\t\t\tvar region = regions.pop();\r\n\t\t\t  \r\n\t\t\t// NOTE: while we don't monitor that, and it can therefore become inaccurate\r\n\t\t\t// I'm going to follow the spec and refuse to mark as region inline/none elements]\r\n\t\t\twhile(true) {\r\n\t\t\t\tvar regionDisplay = getComputedStyle(region).display;\r\n\t\t\t\tif(regionDisplay == \"none\" || regionDisplay.indexOf(\"inline\") !== -1) {\r\n\t\t\t\t\tif(region = regions.pop()) { continue } else { return callback.ondone(!!remainingContent.hasChildNodes()) };\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// the polyfill actually use a <cssregion> wrapper\r\n\t\t\t// we need to link this wrapper and the actual region\r\n\t\t\tif(region.cssRegionsWrapper) {\r\n\t\t\t\tregion.cssRegionsWrapper.cssRegionHost = region;\r\n\t\t\t\tregion = region.cssRegionsWrapper;\r\n\t\t\t} else {\r\n\t\t\t\tregion.cssRegionHost = region;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// empty the region\r\n\t\t\tregion.innerHTML = '';\r\n\t\t\t\r\n\t\t\t// avoid doing the layout of empty regions\r\n\t\t\tif(!remainingContent.hasChildNodes()) {\r\n\t\t\t\t\r\n\t\t\t\tregion.cssRegionHost.cssRegionsLastOffsetHeight = region.cssRegionHost.offsetHeight;\r\n\t\t\t\tregion.cssRegionHost.cssRegionsLastOffsetWidth = region.cssRegionHost.offsetWidth;\r\n\t\t\t\t\r\n\t\t\t\tregion.cssRegionHost.regionOverset = 'empty';\r\n\t\t\t\t\r\n\t\t\t\tvar dummyCallback = { ondone:function(){}, onprogress:function(f){f()} };\r\n\t\t\t\tcssRegions.layoutContent(regions, remainingContent, dummyCallback, startTime);\r\n\t\t\t\t\r\n\t\t\t\treturn callback.ondone(false);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// append the remaining content to the region\r\n\t\t\tregion.appendChild(remainingContent);\r\n\t\t\t\r\n\t\t\t// check if we have more regions to process\r\n\t\t\tif(regions.length !== 0) {\r\n\t\t\t\t\r\n\t\t\t\treturn this.layoutContentInNextRegionsWhenReady(region, regions, remainingContent, callback, startTime);\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\treturn this.layoutContentInLastRegionWhenReady(region, regions, remainingContent, callback, startTime);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tlayoutContentInNextRegionsWhenReady: function(region, regions, remainingContent, callback, startTime) {\r\n\t\t\t\t\t\r\n\t\t\t// delays until all images are loaded\r\n\t\t\tvar imgs = region.getElementsByTagName('img');\r\n\t\t\tfor(var imgs_index=imgs.length; imgs_index--; ) {\r\n\t\t\t\tif(!imgs[imgs_index].complete && !imgs[imgs_index].hasAttribute('height')) {\r\n\t\t\t\t\treturn setTimeout(\r\n\t\t\t\t\t\tfunction() {\r\n\t\t\t\t\t\t\tthis.layoutContentInNextRegionsWhenReady(region, regions, remainingContent, callback, startTime+32);\r\n\t\t\t\t\t\t}.bind(this), \r\n\t\t\t\t\t\t16\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// check if there was an overflow or some break-before/after instruction\r\n\t\t\tvar regionDidOverflow = region.cssRegionHost.scrollHeight != region.cssRegionHost.offsetHeight;\r\n\t\t\tvar shouldSegmentContent = regionDidOverflow;\r\n\t\t\tif(!shouldSegmentContent) {\r\n\t\t\t\tvar first = region.firstElementChild;\r\n\t\t\t\tvar last = region.lastElementChild;\r\n\t\t\t\tvar current = first;\r\n\t\t\t\twhile(current) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(current != first) {\r\n\t\t\t\t\t\tif(/(region|all|always)/i.test(cssCascade.getSpecifiedStyle(current,'break-before',undefined,true).toCSSString())) {\r\n\t\t\t\t\t\t\tshouldSegmentContent = true; break;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(current != last) {\r\n\t\t\t\t\t\tif(/(region|all|always)/i.test(cssCascade.getSpecifiedStyle(current,'break-after',undefined,true).toCSSString())) {\r\n\t\t\t\t\t\t\tcurrent = current.nextElementSibling;\r\n\t\t\t\t\t\t\tshouldSegmentContent = true; break;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcurrent = current.nextElementSibling;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\tif(shouldSegmentContent) {\r\n\t\t\t\t\r\n\t\t\t\t// the remaining content is what was overflowing\r\n\t\t\t\tremainingContent = this.extractOverflowingContent(region);\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// there's nothing more to insert\r\n\t\t\t\tremainingContent = document.createDocumentFragment();\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// if any content didn't fit\r\n\t\t\tif(remainingContent.hasChildNodes()) {\r\n\t\t\t\tregion.cssRegionHost.regionOverset = 'overset';\r\n\t\t\t} else {\r\n\t\t\t\tregion.cssRegionHost.regionOverset = 'fit';\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// update flags\r\n\t\t\tregion.cssRegionHost.cssRegionsLastOffsetHeight = region.cssRegionHost.offsetHeight;\r\n\t\t\tregion.cssRegionHost.cssRegionsLastOffsetWidth = region.cssRegionHost.offsetWidth;\r\n\t\t\t\r\n\t\t\t// layout the next regions\r\n\t\t\t// WE LET THE NEXT REGION DECIDE WHAT TO RETURN\r\n\t\t\tif(startTime+200 > Date.now()) {\r\n\t\t\t\t\r\n\t\t\t\treturn cssRegions.layoutContent(regions, remainingContent, callback, startTime);\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\treturn callback.onprogress(function() {\r\n\t\t\t\t\tcssRegions.layoutContent(regions, remainingContent, callback);\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\tlayoutContentInLastRegionWhenReady: function(region, regions, remainingContent, callback, startTime) {\r\n\t\t\t\r\n\t\t\t// delays until all images are loaded\r\n\t\t\tvar imgs = region.getElementsByTagName('img');\r\n\t\t\tfor(var imgs_index=imgs.length; imgs_index--; ) {\r\n\t\t\t\tif(!imgs[imgs_index].complete && !imgs[imgs_index].hasAttribute('height')) {\r\n\t\t\t\t\treturn setTimeout(\r\n\t\t\t\t\t\tfunction() {\r\n\t\t\t\t\t\t\tthis.layoutContentInLastRegionWhenReady(region, regions, remainingContent, callback, startTime+32);\r\n\t\t\t\t\t\t}.bind(this), \r\n\t\t\t\t\t\t32\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// support region-fragment: break\r\n\t\t\tif(cssCascade.getSpecifiedStyle(region.cssRegionHost,\"region-fragment\",undefined,true).toCSSString().trim().toLowerCase()==\"break\") {\r\n\t\t\t\t\r\n\t\t\t\t// WE RETURN TRUE IF WE DID OVERFLOW\r\n\t\t\t\tvar didOverflow = (this.extractOverflowingContent(region).hasChildNodes());\r\n\t\t\t\t\r\n\t\t\t\t// update flags\r\n\t\t\t\tregion.cssRegionHost.cssRegionsLastOffsetHeight = region.cssRegionHost.offsetHeight;\r\n\t\t\t\tregion.cssRegionHost.cssRegionsLastOffsetWidth = region.cssRegionHost.offsetWidth;\r\n\t\t\t\t\r\n\t\t\t\treturn callback.ondone(didOverflow);\r\n\t\t\t\t\r\n\t\t\t} else {\r\n\t\t\t\t\r\n\t\t\t\t// update flags\r\n\t\t\t\tregion.cssRegionHost.cssRegionsLastOffsetHeight = region.cssRegionHost.offsetHeight;\r\n\t\t\t\tregion.cssRegionHost.cssRegionsLastOffsetWidth = region.cssRegionHost.offsetWidth;\r\n\t\t\t\t\r\n\t\t\t\t// WE RETURN FALSE IF WE DIDN'T OVERFLOW\r\n\t\t\t\treturn callback.ondone(region.cssRegionHost.offsetHeight != region.cssRegionHost.scrollHeight);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t\r\n\t\t//\r\n\t\t// this function returns a document fragment containing the content\r\n\t\t// that didn't fit in a particular <cssregion> element.\r\n\t\t//\r\n\t\t// in the simplest cases, we can just use hit-targeting to get very\r\n\t\t// close the the natural breaking point. for mostly textual flows,\r\n\t\t// this works perfectly, for the others, we may need some tweaks.\r\n\t\t//\r\n\t\t// there's a code detecting whether this hit-target optimization\r\n\t\t// did possibly fail, in which case we return to a setup where we\r\n\t\t// start from scratch.\r\n\t\t//\r\n\t\textractOverflowingContent: function(region, dontOptimize) {\r\n\t\t\t\r\n\t\t\t// make sure empty nodes don't make our life more difficult\r\n\t\t\tcssRegionsHelpers.embedTrailingWhiteSpaceNodes(region);\r\n\t\t\t\r\n\t\t\t// get the region layout\r\n\t\t\tvar sizingH = region.cssRegionHost.offsetHeight; // avail size (max-height)\r\n\t\t\tvar sizingW = region.cssRegionHost.offsetWidth; // avail size (max-width)\r\n\t\t\tvar pos = region.cssRegionHost.getBoundingClientRect(); // avail size?\r\n\t\t\tpos = {top: pos.top, bottom: pos.bottom, left: pos.left, right: pos.right};\r\n\t\t\t\r\n\t\t\t// substract from the bottom any border/padding of the region\r\n\t\t\tvar lostHeight = parseInt(getComputedStyle(region.cssRegionHost).paddingBottom);\r\n\t\t\tlostHeight += parseInt(getComputedStyle(region.cssRegionHost).borderBottomWidth);\r\n\t\t\tpos.bottom -= lostHeight; sizingH -= lostHeight;\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// note: let's use hit targeting to find a dom range\r\n\t\t\t// which is close to the location where we will need to\r\n\t\t\t// break the content into fragments\r\n\t\t\t// \r\n\t\t\t\r\n\t\t\t// get the caret range for the bottom-right of that location\r\n\t\t\ttry {\r\n\t\t\t\tvar r = dontOptimize ? document.createRange() : document.caretRangeFromPoint(\r\n\t\t\t\t\tpos.left + sizingW - 1,\r\n\t\t\t\t\tpos.top + sizingH - 1\r\n\t\t\t\t);\r\n\t\t\t} catch (ex) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tcssConsole.error(ex.message);\r\n\t\t\t\t\tcssConsole.dir(ex);\r\n\t\t\t\t} catch (ex) {}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// helper for logging info\r\n\t\t\t/*cssConsole.log(\"extracting overflow\")\r\n\t\t\tcssConsole.log(pos.bottom)*/\r\n\t\t\tvar debug = function() {\r\n\t\t\t\t/*cssConsole.dir({\r\n\t\t\t\t\tstartContainer: r.startContainer,\r\n\t\t\t\t\tstartOffset: r.startOffset,\r\n\t\t\t\t\tbrowserBCR: r.getBoundingClientRect(),\r\n\t\t\t\t\tcomputedBCR: rect\r\n\t\t\t\t});*/\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar fixNullRect = function() {\r\n\t\t\t\tif(rect.bottom==0 && rect.top==0 && rect.left==0 && rect.right==0) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar scrollTop = -(document.documentElement.scrollTop || document.body.scrollTop);\r\n\t\t\t\t\tvar scrollLeft = -(document.documentElement.scrollLeft || document.body.scrollLeft);\r\n\t\t\t\t\t\r\n\t\t\t\t\trect = {\r\n\t\t\t\t\t\twidth: 0,\r\n\t\t\t\t\t\theigth: 0,\r\n\t\t\t\t\t\ttop: scrollTop,\r\n\t\t\t\t\t\tbottom: scrollTop,\r\n\t\t\t\t\t\tleft: scrollLeft,\r\n\t\t\t\t\t\tright: scrollLeft\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// if the caret is outside the region\r\n\t\t\tif(!r || (region !== r.endContainer && !Node.contains(region,r.endContainer))) {\r\n\t\t\t\t\r\n\t\t\t\t// if the caret is after the region wrapper but inside the host...\r\n\t\t\t\tif(r && r.endContainer === region.cssRegionHost && r.endOffset==r.endContainer.childNodes.length) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// move back at the end of the region, actually\r\n\t\t\t\t\tr.setStart(region, region.childNodes.length);\r\n\t\t\t\t\tr.setEnd(region, region.childNodes.length);\r\n\t\t\t\t\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// move back into the region\r\n\t\t\t\t\tr = r || document.createRange();\r\n\t\t\t\t\tr.setStart(region, 0);\r\n\t\t\t\t\tr.setEnd(region, 0);\r\n\t\t\t\t\tdontOptimize=true;\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// start finding the natural breaking point\r\n\t\t\tdo {\r\n\t\t\t\t\r\n\t\t\t\t// store the current selection rect for fast access\r\n\t\t\t\tvar rect = r.myGetExtensionRect(); fixNullRect();\r\n\t\t\t\tdebug();\r\n\t\t\t\t\r\n\t\t\t\t//\r\n\t\t\t\t// note: maybe the text is right-to-left\r\n\t\t\t\t// in this case, we can go further than the caret\r\n\t\t\t\t//\r\n\t\t\t\t\r\n\t\t\t\t// move the end point char by char until it's completely in the region\r\n\t\t\t\twhile(!(r.endContainer==region && r.endOffset==r.endContainer.childNodes.length) && rect.bottom<=pos.top+sizingH) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tdebug();\r\n\t\t\t\t\t\r\n\t\t\t\t\t// look if we can optimize by moving fast forward\r\n\t\t\t\t\tvar nextSibling = r.endContainer.childNodes[r.endOffset];\r\n\t\t\t\t\tvar nextSiblingRect = !nextSibling || Node.getBoundingClientRect(nextSibling);\r\n\t\t\t\t\tif(nextSibling && nextSiblingRect.bottom<=pos.top+sizingH) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// if yes, move element by element\r\n\t\t\t\t\t\tr.setStartAfter(nextSibling)\r\n\t\t\t\t\t\tr.setEndAfter(nextSibling)\r\n\t\t\t\t\t\trect = nextSiblingRect\r\n\t\t\t\t\t\tfixNullRect()\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// otherwise, go char-by-char\r\n\t\t\t\t\t\tr.myMoveTowardRight(); rect = r.myGetExtensionRect(); fixNullRect();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t//\r\n\t\t\t\t// note: maybe the text is one line too big\r\n\t\t\t\t// in this case, we have to backtrack a little\r\n\t\t\t\t//\r\n\t\t\t\t\r\n\t\t\t\t// move the end point char by char until it's completely in the region\r\n\t\t\t\twhile(!(r.endContainer==region && r.endOffset==0) && rect.bottom>pos.top+sizingH) {\r\n\t\t\t\t\tdebug(); r.myMoveOneCharLeft(); rect = r.myGetExtensionRect(); fixNullRect();\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tdebug()\r\n\t\t\t\t\r\n\t\t\t\t//\r\n\t\t\t\t// note: if we optimized via hit-testing, this may be wrong\r\n\t\t\t\t// if next condition does not hold, we're fine. \r\n\t\t\t\t// otherwhise we must restart without optimization...\r\n\t\t\t\t//\r\n\t\t\t\t\r\n\t\t\t\t// if the selected content is possibly off-target\r\n\t\t\t\tvar optimizationFailled = false; if(!dontOptimize) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tvar current = r.endContainer;\r\n\t\t\t\t\twhile(current = cssRegionsHelpers.getAllLevelPreviousSibling(current, region)) {\r\n\t\t\t\t\t\tif(Node.getBoundingClientRect(current).bottom > pos.top + sizingH) {\r\n\t\t\t\t\t\t\tr.setStart(region,0);\r\n\t\t\t\t\t\t\tr.setEnd(region,0);\r\n\t\t\t\t\t\t\toptimizationFailled=true;\r\n\t\t\t\t\t\t\tdontOptimize=true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} while(optimizationFailled) \r\n\t\t\t\r\n\t\t\t// \r\n\t\t\t// note: we should not break the content inside monolithic content\r\n\t\t\t// if we do, we need to change the selection to avoid that\r\n\t\t\t// \r\n\t\t\t\r\n\t\t\t// move the selection before the monolithic ancestors\r\n\t\t\tvar current = r.endContainer;\r\n\t\t\twhile(current !== region) {\r\n\t\t\t\tif(cssBreak.isMonolithic(current)) {\r\n\t\t\t\t\tr.setEndBefore(current);\r\n\t\t\t\t}\r\n\t\t\t\tcurrent = current.parentNode;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// if the selection is not in the region anymore, add the whole region\r\n\t\t\tif(!r || (region !== r.endContainer && !Node.contains(region,r.endContainer))) {\r\n\t\t\t\tcssConsole.dir(r.cloneRange()); debugger;\r\n\t\t\t\tr.setStart(region,region.childNodes.length);\r\n\t\t\t\tr.setEnd(region,region.childNodes.length);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// \r\n\t\t\t// note: we don't want to break inside a line.\r\n\t\t\t// backtrack to end of previous line...\r\n\t\t\t// \r\n\t\t\tvar first = r.startContainer.childNodes[r.startOffset], current = first; \r\n\t\t\tif(cssBreak.hasAnyInlineFlow(r.startContainer)) {\r\n\t\t\t\twhile((current) && (current = current.previousSibling)) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(cssBreak.areInSameSingleLine(current,first)) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// optimization: first and current are on the same line\r\n\t\t\t\t\t\t// so if next and current are not the same line, it will still be\r\n\t\t\t\t\t\t// the same line the \"first\" element is in\r\n\t\t\t\t\t\tfirst = current;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif(current instanceof Element) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// we don't want to break inside text lines\r\n\t\t\t\t\t\t\tr.setEndBefore(current);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// get last line via client rects\r\n\t\t\t\t\t\t\tvar lines = Node.getClientRects(current);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// if the text node did wrap into multiple lines\r\n\t\t\t\t\t\t\tif(lines.length>1) {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// move back from the end until we get into previous line\r\n\t\t\t\t\t\t\t\tvar previousLineBottom = lines[lines.length-2].bottom;\r\n\t\t\t\t\t\t\t\tr.setEnd(current, current.nodeValue.length);\r\n\t\t\t\t\t\t\t\twhile(rect.bottom>previousLineBottom) {\r\n\t\t\t\t\t\t\t\t\tr.myMoveOneCharLeft(); rect = r.myGetExtensionRect(); fixNullRect();\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// make sure we didn't exit the text node by mistake\r\n\t\t\t\t\t\t\t\tif(r.endContainer!==current) {\r\n\t\t\t\t\t\t\t\t\t// if we did, there's something wrong about the text node\r\n\t\t\t\t\t\t\t\t\t// but we can consider the text node as an element instead\r\n\t\t\t\t\t\t\t\t\tr.setEndBefore(current); // debugger; \r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t// we can consider the text node as an element\r\n\t\t\t\t\t\t\t\tr.setEndBefore(current);\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// if the two elements are not on the same line, \r\n\t\t\t\t\t\t// then we just found a line break!\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// if the selection is not in the region anymore, add the whole region\r\n\t\t\tif(!r || (region !== r.endContainer && !Node.contains(region,r.endContainer))) {\r\n\t\t\t\tcssConsole.dir(r.cloneRange()); debugger;\r\n\t\t\t\tr.setStart(region,region.childNodes.length);\r\n\t\t\t\tr.setEnd(region,region.childNodes.length);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t// \r\n\t\t\t// note: the css-break spec says that a region should not be emtpy\r\n\t\t\t// \r\n\t\t\t\r\n\t\t\t// if we end up with nothing being selected, add the first block anyway\r\n\t\t\tif(r.endContainer===region && r.endOffset===0 && r.endOffset!==region.childNodes.length) {\r\n\t\t\t\t\r\n\t\t\t\t// find the first allowed break point\r\n\t\t\t\tdo {\r\n\t\t\t\t\t\r\n\t\t\t\t\t//cssConsole.dir(r.cloneRange()); \r\n\t\t\t\t\t\r\n\t\t\t\t\t// move the position char-by-char\r\n\t\t\t\t\tr.myMoveTowardRight(); \r\n\t\t\t\t\t\r\n\t\t\t\t\t// but skip long islands of monolithic elements\r\n\t\t\t\t\t// since we know we cannot break inside them anyway\r\n\t\t\t\t\tvar current = r.endContainer;\r\n\t\t\t\t\twhile(current && current !== region) {\r\n\t\t\t\t\t\tif(cssBreak.isMonolithic(current)) {\r\n\t\t\t\t\t\t\tr.setStartAfter(current);\r\n\t\t\t\t\t\t\tr.setEndAfter(current);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcurrent = current.parentNode;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t// do that until we reach a possible break point, or the end of the element\r\n\t\t\t\twhile(!cssBreak.isPossibleBreakPoint(r,region) && !(r.endContainer===region && r.endOffset===region.childNodes.length))\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// if the selection is not in the region anymore, add the whole region\r\n\t\t\tif(!r || region !== r.endContainer && !Node.contains(region,r.endContainer)) {\r\n\t\t\t\tcssConsole.dir(r.cloneRange()); debugger;\r\n\t\t\t\tr.setStart(region,region.childNodes.length);\r\n\t\t\t\tr.setEnd(region,region.childNodes.length);\r\n\t\t\t}\r\n\t\t\t\t\r\n\t\t\t// now, let's try to find a break-before/break-after element before the splitting point\r\n\t\t\tvar current = r.endContainer; if(current.hasChildNodes()) { if(r.endOffset>0) { current=current.childNodes[r.endOffset-1] } };\r\n\t\t\tvar first = r.endContainer.firstChild;\r\n\t\t\tdo {\r\n\t\t\t\tif(current.style) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(current != first) {\r\n\t\t\t\t\t\tif(/(region|all|always)/i.test(cssCascade.getSpecifiedStyle(current,'break-before',undefined,true).toCSSString())) {\r\n\t\t\t\t\t\t\tr.setStartBefore(current);\r\n\t\t\t\t\t\t\tr.setEndBefore(current);\r\n\t\t\t\t\t\t\tdontOptimize=true; // no algo involved in breaking, after all\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(current !== region) {\r\n\t\t\t\t\t\tif(/(region|all|always)/i.test(cssCascade.getSpecifiedStyle(current,'break-after',undefined,true).toCSSString())) {\r\n\t\t\t\t\t\t\tr.setStartAfter(current);\r\n\t\t\t\t\t\t\tr.setEndAfter(current);\r\n\t\t\t\t\t\t\tdontOptimize=true; // no algo involved in breaking, after all\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t} while(current = cssRegionsHelpers.getAllLevelPreviousSibling(current, region));\r\n\t\t\t\r\n\t\t\t// we're almost done! now, let's collect the ancestors to make some splitting postprocessing\r\n\t\t\tvar current = r.endContainer; var allAncestors=[];\r\n\t\t\tif(current.nodeType !== current.ELEMENT_NODE) current=current.parentNode;\r\n\t\t\twhile(current !== region) {\r\n\t\t\t\tallAncestors.push(current);\r\n\t\t\t\tcurrent = current.parentNode;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// note: if we're about to split after the last child of\r\n\t\t\t// an element which has bottom-{padding/border/margin}, \r\n\t\t\t// we need to figure how how much of that p/b/m we can\r\n\t\t\t// actually keep in the first fragment\r\n\t\t\t// \r\n\t\t\t// TODO: avoid top & bottom p/b/m cuttings to use the \r\n\t\t\t// same variables names, it's ugly\r\n\t\t\t//\r\n\t\t\t\r\n\t\t\t// split bottom-{margin/border/padding} correctly\r\n\t\t\tif(r.endOffset == r.endContainer.childNodes.length && r.endContainer !== region) {\r\n\t\t\t\t\r\n\t\t\t\t// compute how much of the bottom border can actually fit\r\n\t\t\t\tvar box = r.endContainer.getBoundingClientRect();\r\n\t\t\t\tvar excessHeight = box.bottom - (pos.top + sizingH);\r\n\t\t\t\tvar endContainerStyle = getComputedStyle(r.endContainer);\r\n\t\t\t\tvar availBorderHeight = parseFloat(endContainerStyle.borderBottomWidth);\r\n\t\t\t\tvar availPaddingHeight = parseFloat(endContainerStyle.paddingBottom);\r\n\t\t\t\t\r\n\t\t\t\t// start by cutting into the border\r\n\t\t\t\tvar borderCut = excessHeight;\r\n\t\t\t\tif(excessHeight > availBorderHeight) {\r\n\t\t\t\t\tborderCut = availBorderHeight;\r\n\t\t\t\t\texcessHeight -= borderCut;\r\n\t\t\t\t\t\r\n\t\t\t\t\t// continue by cutting into the padding\r\n\t\t\t\t\tvar paddingCut = excessHeight;\r\n\t\t\t\t\tif(paddingCut > availPaddingHeight) {\r\n\t\t\t\t\t\tpaddingCut = availPaddingHeight;\r\n\t\t\t\t\t\texcessHeight -= paddingCut;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\texcessHeight = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\texcessHeight = 0;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t// we don't cut borders with radiuses\r\n\t\t\t\t// TODO: accept to cut the content not affected by the radius\r\n\t\t\t\tif(typeof(borderCut)===\"number\" && borderCut!==0) {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// check the presence of a radius:\r\n\t\t\t\t\tvar hasBottomRadius = (\r\n\t\t\t\t\t\tparseInt(endContainerStyle.borderBottomLeftRadius)>0\r\n\t\t\t\t\t\t|| parseInt(endContainerStyle.borderBottomRightRadius)>0\r\n\t\t\t\t\t);\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(hasBottomRadius) {\r\n\t\t\t\t\t\t// break before the whole border:\r\n\t\t\t\t\t\tborderCut = availBorderHeight;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t// split top-{margin/border/padding} correctly\r\n\t\t\tif(r.endOffset == 0 && r.endContainer !== region) {\r\n\t\t\t\t\r\n\t\t\t\t// note: the only possibility here is that we \r\n\t\t\t\t// did split after a padding or a border.\r\n\t\t\t\t// \r\n\t\t\t\t// it can only happen if the border/padding is \r\n\t\t\t\t// too big to fit the region but is actually \r\n\t\t\t\t// the first break we could find!\r\n\t\t\t\t\r\n\t\t\t\t// compute how much of the top border can actually fit\r\n\t\t\t\tvar box = r.endContainer.getBoundingClientRect();\r\n\t\t\t\tvar availHeight = (pos.top + sizingH) - pos.top;\r\n\t\t\t\tvar endContainerStyle = getComputedStyle(r.endContainer);\r\n\t\t\t\tvar availBorderHeight = parseFloat(endContainerStyle.borderTopWidth);\r\n\t\t\t\tvar availPaddingHeight = parseFloat(endContainerStyle.paddingTop);\r\n\t\t\t\tvar excessHeight = availBorderHeight + availPaddingHeight - availHeight;\r\n\t\t\t\t\r\n\t\t\t\tif(excessHeight > 0) {\r\n\t\t\t\t\r\n\t\t\t\t\t// start by cutting into the padding\r\n\t\t\t\t\tvar topPaddingCut = excessHeight;\r\n\t\t\t\t\tif(excessHeight > availPaddingHeight) {\r\n\t\t\t\t\t\ttopPaddingCut = availPaddingHeight;\r\n\t\t\t\t\t\texcessHeight -= topPaddingCut;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// continue by cutting into the border\r\n\t\t\t\t\t\tvar topBorderCut = excessHeight;\r\n\t\t\t\t\t\tif(topBorderCut > availBorderHeight) {\r\n\t\t\t\t\t\t\ttopBorderCut = availBorderHeight;\r\n\t\t\t\t\t\t\texcessHeight -= topBorderCut;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\texcessHeight = 0;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\texcessHeight = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// remove bottom-{pbm} from all ancestors involved in the cut\r\n\t\t\tfor(var i=allAncestors.length-1; i>=0; i--) {\r\n\t\t\t\tallAncestors[i].setAttribute('data-css-continued-fragment',true);\r\n\t\t\t\tif(getComputedStyle(allAncestors[i]).display.indexOf('block')>=0) {\r\n\t\t\t\t\tallAncestors[i].setAttribute('data-css-continued-block-fragment',true);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(typeof(borderCut)===\"number\") {\r\n\t\t\t\tallAncestors[0].removeAttribute('data-css-continued-fragment');\r\n\t\t\t\tallAncestors[0].setAttribute('data-css-special-continued-fragment',true);\r\n\t\t\t\tallAncestors[0].style.borderBottomWidth = (availBorderHeight-borderCut)+'px';\r\n\t\t\t}\r\n\t\t\tif(typeof(paddingCut)===\"number\") {\r\n\t\t\t\tallAncestors[0].removeAttribute('data-css-continued-fragment');\r\n\t\t\t\tallAncestors[0].setAttribute('data-css-special-continued-fragment',true);\r\n\t\t\t\tallAncestors[0].style.paddingBottom = (availPaddingHeight-paddingCut)+'px';\r\n\t\t\t}\r\n\t\t\tif(typeof(topBorderCut)===\"number\") {\r\n\t\t\t\tallAncestors[0].removeAttribute('data-css-continued-fragment');\r\n\t\t\t\tallAncestors[0].setAttribute('data-css-continued-fragment',true);\r\n\t\t\t\tallAncestors[0].style.borderTopWidth = (availBorderHeight-topBorderCut)+'px';\r\n\t\t\t}\r\n\t\t\tif(typeof(topPaddingCut)===\"number\") {\r\n\t\t\t\tallAncestors[0].removeAttribute('data-css-continued-fragment');\r\n\t\t\t\tallAncestors[0].setAttribute('data-css-special-continued-fragment',true);\r\n\t\t\t\tallAncestors[0].style.paddingTop = (availPaddingHeight-topPaddingCut)+'px';\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// note: at this point we have a collapsed range \r\n\t\t\t// located at the split point\r\n\t\t\t//\r\n\t\t\t\r\n\t\t\t// select the overflowing content\r\n\t\t\tr.setEnd(region, region.childNodes.length);\r\n\t\t\t\r\n\t\t\t// extract it from the current region\r\n\t\t\tvar overflowingContent = r.extractContents();\r\n\t\t\t\r\n\t\t\t// remove trailing whitespace from the cut element\r\n\t\t\tvar tmp = allAncestors[0];\r\n\t\t\tif(tmp && (tmp=tmp.lastChild) && !tmp.tagName && tmp.nodeValue) {\r\n\t\t\t\tvar nodeValue = tmp.nodeValue.replace(/(\\s|\\r|\\n)*$/,'');\r\n\t\t\t\tif(nodeValue) {\r\n\t\t\t\t\t// if the last cut was just after a &shy; (soft hyphen), we need to append a dash\r\n\t\t\t\t\tif(/\\u00AD$/.test(nodeValue)) {\r\n\t\t\t\t\t\tnodeValue = nodeValue.replace(/\\u00AD$/, '-');\r\n\t\t\t\t\t} else if(overflowingContent && overflowingContent.textContent[0] == '\\u00AD') {\r\n\t\t\t\t\t\tnodeValue = nodeValue + '-';\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttmp.nodeValue = nodeValue;\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttmp.parentNode.removeChild(tmp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// \r\n\t\t\t// note: now we have to cancel out the artifacts of\r\n\t\t\t// the fragments cloning algorithm...\r\n\t\t\t//\r\n\t\t\t\r\n\t\t\t// do not forget to remove any top p/b/m on cut elements\r\n\t\t\tvar newFragments = overflowingContent.querySelectorAll(\"[data-css-continued-fragment]\");\r\n\t\t\tfor(var i=newFragments.length; i--;) { // TODO: optimize by using while loop and a simple matchesSelector.\r\n\t\t\t\tnewFragments[i].removeAttribute('data-css-continued-fragment')\r\n\t\t\t\tnewFragments[i].setAttribute('data-css-starting-fragment',true);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// deduct any already-used bottom p/b/m\r\n\t\t\tvar specialNewFragment = overflowingContent.querySelector('[data-css-special-continued-fragment]');\r\n\t\t\tif(specialNewFragment) {\r\n\t\t\t\tspecialNewFragment.removeAttribute('data-css-special-continued-fragment')\r\n\t\t\t\tspecialNewFragment.setAttribute('data-css-starting-fragment',true);\r\n\t\t\t\t\r\n\t\t\t\tif(typeof(borderCut)===\"number\") {\r\n\t\t\t\t\tspecialNewFragment.style.borderBottomWidth = (borderCut)+'px';\r\n\t\t\t\t}\r\n\t\t\t\tif(typeof(paddingCut)===\"number\") {\r\n\t\t\t\t\tspecialNewFragment.style.paddingBottom = (paddingCut);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tspecialNewFragment.style.paddingBottom = '0px';\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif(typeof(topBorderCut)===\"number\") {\r\n\t\t\t\t\tspecialNewFragment.removeAttribute('data-css-starting-fragment')\r\n\t\t\t\t\tspecialNewFragment.setAttribute('data-css-special-starting-fragment',true);\r\n\t\t\t\t\tspecialNewFragment.style.borderTopWidth = (topBorderCut)+'px';\r\n\t\t\t\t}\r\n\t\t\t\tif(typeof(topPaddingCut)===\"number\") {\r\n\t\t\t\t\tspecialNewFragment.removeAttribute('data-css-starting-fragment')\r\n\t\t\t\t\tspecialNewFragment.setAttribute('data-css-special-starting-fragment',true);\r\n\t\t\t\t\tspecialNewFragment.style.paddingTop = (topPaddingCut)+'px';\r\n\t\t\t\t\tspecialNewFragment.style.paddingBottom = '0px';\r\n\t\t\t\t\tspecialNewFragment.style.borderBottomWidth = '0px';\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} else if(typeof(borderCut)===\"number\") {\r\n\t\t\t\t\r\n\t\t\t\t// hum... there's an element missing here... {never happens anymore}\r\n\t\t\t\ttry { throw new Error() }\r\n\t\t\t\tcatch(ex) { setImmediate(function() { throw ex; }) }\r\n\t\t\t\t\r\n\t\t\t} else if(typeof(topPaddingCut)===\"number\") {\r\n\t\t\t\t\r\n\t\t\t\t// hum... there's an element missing here... {never happens anymore}\r\n\t\t\t\ttry { throw new Error() }\r\n\t\t\t\tcatch(ex) { setImmediate(function() { throw ex; }) }\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t// make sure empty nodes are reintroduced\r\n\t\t\tcssRegionsHelpers.unembedTrailingWhiteSpaceNodes(region);\r\n\t\t\tcssRegionsHelpers.unembedTrailingWhiteSpaceNodes(overflowingContent);\r\n\t\t\t\r\n\t\t\t// we're ready to return our result!\r\n\t\t\treturn overflowingContent;\r\n\t\t\t\r\n\t\t},\r\n\t\t\t\r\n\t\tenablePolyfill: function enablePolyfill() {\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// [0] insert necessary css\r\n\t\t\t//\r\n\t\t\tvar s = document.createElement('style');\r\n\t\t\ts.setAttribute(\"data-css-no-polyfill\", true);\r\n\t\t\ts.textContent = CSS_STYLE;\r\n\t\t\tvar head = document.head || document.getElementsByTagName('head')[0];\r\n\t\t\thead.appendChild(s);\r\n\t\t\t\r\n\t\t\t// \r\n\t\t\t// [1] when any update happens:\r\n\t\t\t// construct new content and region flow pairs\r\n\t\t\t// restart the region layout algorithm for the modified pairs\r\n\t\t\t// \r\n\t\t\tcssCascade.startMonitoringProperties(\r\n\t\t\t\t[\"flow-into\",\"flow-from\",\"region-fragment\"], \r\n\t\t\t\t{\r\n\t\t\t\t\tonupdate: function onupdate(element, rule) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// let's just ignore fragments\r\n\t\t\t\t\t\tif(element.getAttributeNode('data-css-regions-fragment-of')) return;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// log some message in the console for debug\r\n\t\t\t\t\t\tcssConsole.dir({message:\"onupdate\",element:element,selector:rule.selector.toCSSString(),rule:rule});\r\n\t\t\t\t\t\tvar temp = null;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t// compute the value of region properties\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\tvar flowInto = (\r\n\t\t\t\t\t\t\tcssCascade.getSpecifiedStyle(element, \"flow-into\")\r\n\t\t\t\t\t\t\t.filter(function(t) { return t instanceof cssSyntax.IdentifierToken })\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar flowIntoName = flowInto[0] ? flowInto[0].toCSSString().toLowerCase() : \"\";\r\n\t\t\t\t\t\tif(flowIntoName==\"none\"||flowIntoName==\"initial\"||flowIntoName==\"inherit\"||flowIntoName==\"default\") {flowIntoName=\"\"}\r\n\t\t\t\t\t\tvar flowIntoType = flowInto[1] ? flowInto[1].toCSSString().toLowerCase() : \"\"; \r\n\t\t\t\t\t\tif(flowIntoType!=\"content\") {flowIntoType=\"element\"}\r\n\t\t\t\t\t\tvar flowInto = flowIntoName ? flowIntoName + \" \" + flowIntoType : \"\";\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar flowFrom = (\r\n\t\t\t\t\t\t\tcssCascade.getSpecifiedStyle(element, \"flow-from\")\r\n\t\t\t\t\t\t\t.filter(function(t) { return t instanceof cssSyntax.IdentifierToken })\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar flowFromName = flowFrom[0] ? flowFrom[0].toCSSString().toLowerCase() : \"\"; \r\n\t\t\t\t\t\tif(flowFromName==\"none\"||flowFromName==\"initial\"||flowFromName==\"inherit\"||flowFromName==\"default\") {flowFromName=\"\"}\r\n\t\t\t\t\t\tvar flowFrom = flowFromName;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\t// if the value of any property did change...\r\n\t\t\t\t\t\t//\r\n\t\t\t\t\t\tif(element.cssRegionsLastFlowInto != flowInto || element.cssRegionsLastFlowFrom != flowFrom) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// remove the element from previous regions\r\n\t\t\t\t\t\t\tvar regionOverset = element.regionOverset;\r\n\t\t\t\t\t\t\tvar lastFlowFrom = (cssRegions.flows[element.cssRegionsLastFlowFromName]);\r\n\t\t\t\t\t\t\tvar lastFlowInto = (cssRegions.flows[element.cssRegionsLastFlowIntoName]);\r\n\t\t\t\t\t\t\tlastFlowFrom && lastFlowFrom.removeFromRegions(element);\r\n\t\t\t\t\t\t\tlastFlowInto && lastFlowInto.removeFromContent(element);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// relayout those regions \r\n\t\t\t\t\t\t\t// (it's async so it will wait for us\r\n\t\t\t\t\t\t\t// to add the element back if needed)\r\n\t\t\t\t\t\t\tlastFlowFrom && regionOverset!='empty' && lastFlowFrom.relayout();\r\n\t\t\t\t\t\t\tlastFlowInto && lastFlowInto.relayout();\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// save some property values for later\r\n\t\t\t\t\t\t\telement.cssRegionsLastFlowInto = flowInto;\r\n\t\t\t\t\t\t\telement.cssRegionsLastFlowFrom = flowFrom;\r\n\t\t\t\t\t\t\telement.cssRegionsLastFlowIntoName = flowIntoName;\r\n\t\t\t\t\t\t\telement.cssRegionsLastFlowFromName = flowFromName;\r\n\t\t\t\t\t\t\telement.cssRegionsLastFlowIntoType = flowIntoType;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// add the element to new regions\r\n\t\t\t\t\t\t\t// and relayout those regions, if deemed necessary\r\n\t\t\t\t\t\t\tif(flowFromName) {\r\n\t\t\t\t\t\t\t\tvar lastFlowFrom = (cssRegions.flows[flowFromName] = cssRegions.flows[flowFromName] || new cssRegions.Flow(flowFromName));\r\n\t\t\t\t\t\t\t\tlastFlowFrom && lastFlowFrom.addToRegions(element);\r\n\t\t\t\t\t\t\t\tlastFlowFrom && lastFlowFrom.relayout();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif(flowIntoName) {\r\n\t\t\t\t\t\t\t\tvar lastFlowInto = (cssRegions.flows[flowIntoName] = cssRegions.flows[flowIntoName] || new cssRegions.Flow(flowIntoName));\r\n\t\t\t\t\t\t\t\tlastFlowInto && lastFlowInto.addToContent(element);\r\n\t\t\t\t\t\t\t\tlastFlowInto && lastFlowInto.relayout();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t\tcssCascade.startMonitoringProperties(\r\n\t\t\t\t[\"break-before\",\"break-after\"], \r\n\t\t\t\t{onupdate:function(element){\r\n\t\t\t\t\t\r\n\t\t\t\t\t// avoid fragments triggering update loops\r\n\t\t\t\t\tif(element.getAttribute('data-css-regions-fragment-of')){return;}\r\n\t\t\t\t\t\r\n\t\t\t\t\t// update parent regions\r\n\t\t\t\t\twhile(element) {\r\n\t\t\t\t\t\tif(element.cssRegionsLastFlowIntoName) {\r\n\t\t\t\t\t\t\tcssRegions.flows[element.cssRegionsLastFlowIntoName].relayout();\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telement=element.parentNode;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}}\r\n\t\t\t);\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// [2] perform the OM exports\r\n\t\t\t//\r\n\t\t\tcssRegions.enablePolyfillObjectModel();\r\n\t\t\t\r\n\t\t\t//\r\n\t\t\t// [3] make sure to update the region layout when all images loaded\r\n\t\t\t//\r\n\t\t\twindow.addEventListener(\"load\", \r\n\t\t\t\tfunction() { \r\n\t\t\t\t\tvar flows = document.getNamedFlows();\r\n\t\t\t\t\tfor(var i=0; i<flows.length; i++) {\r\n\t\t\t\t\t\tflows[i].relayout();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t\t\r\n\t\t\t// \r\n\t\t\t// [4] make sure we react to window resizes\r\n\t\t\t//\r\n\t\t\t//\r\n\t\t\tvar lastWindowResize = 0;\r\n\t\t\tvar relayoutModifiedFlows = function() {\r\n\t\t\t\t\r\n\t\t\t\t// specify the function did run\r\n\t\t\t\trelayoutModifiedFlows.timeout = 0;\r\n\t\t\t\t\r\n\t\t\t\t// rerun the layout\r\n\t\t\t\tvar flows = document.getNamedFlows();\r\n\t\t\t\tfor(var i=0; i<flows.length; i++) {\r\n\t\t\t\t\tif(flows[i].lastRelayout > lastWindowResize) continue;\r\n\t\t\t\t\tif(flows[i].relayoutInProgress) {\r\n\t\t\t\t\t\tflows[i].relayout();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tflows[i].relayoutIfSizeChanged();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tvar hasOngoingLayouts = function() {\r\n\t\t\t\t\r\n\t\t\t\tvar flows = document.getNamedFlows();\r\n\t\t\t\tfor(var i=0; i<flows.length; i++) {\r\n\t\t\t\t\tif(flows[i].lastRelayout > lastWindowResize) continue;\r\n\t\t\t\t\tif(flows[i].relayoutInProgress) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\treturn false;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tvar restartOngoingLayouts = function() {\r\n\t\t\t\t\r\n\t\t\t\tvar flows = document.getNamedFlows();\r\n\t\t\t\tfor(var i=0; i<flows.length; i++) {\r\n\t\t\t\t\tif(flows[i].lastRelayout > lastWindowResize) continue;\r\n\t\t\t\t\tif(flows[i].relayoutInProgress) {\r\n\t\t\t\t\t\tflows[i].relayout();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\twindow.addEventListener(\"resize\",\r\n\t\t\t\tfunction() {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// update the last layout flag\r\n\t\t\t\t\tlastWindowResize = +new Date();\r\n\t\t\t\t\t\r\n\t\t\t\t\t// if we aren't planning a resfresh already\r\n\t\t\t\t\tif(!relayoutModifiedFlows.timeout) { \r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// if we are already busy\r\n\t\t\t\t\t\tif(hasOngoingLayouts()) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// restart all layouts now\r\n\t\t\t\t\t\t\tsetTimeout(restartOngoingLayouts, 16);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// wait half a second before restarting them from now\r\n\t\t\t\t\t\t\trelayoutModifiedFlows.timeout = setTimeout(relayoutModifiedFlows, 500);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// debounce by running the resize code every 200ms\r\n\t\t\t\t\t\t\trelayoutModifiedFlows.timeout = setTimeout(relayoutModifiedFlows, 200);\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t\t\r\n\t\t},\r\n\t\t\r\n\t\t// this dictionary is supposed to contains all the currently existing flows\r\n\t\tflows: Object.create ? Object.create(null) : {}\r\n\t\t\r\n\t};\r\n\t\r\n\tenableObjectModel(window, document, cssRegions);\r\n\t\r\n\treturn cssRegions;\r\n})(window, document);\r\n\nrequire.define('src/css-regions/polyfill.js');","//require('core:polyfill-dom-matchMedia');\r\n//require('core:polyfill-dom-classList');\r\n//require('css-grid:polyfill');\r\nrequire('src/css-regions/polyfill.js');\nrequire.define('src/requirements.js');"]}