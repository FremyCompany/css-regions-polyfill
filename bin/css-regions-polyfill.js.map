{"version":3,"sources":["../src/core/polyfill-dom-console.js","../src/core/dom-events.js","../src/core/css-syntax.js","../src/core/polyfill-dom-requestAnimationFrame.js","../src/core/dom-experimental-event-streams.js","../src/core/dom-query-selector-live.js","../src/core/css-cascade.js","../src/core/css-break.js","../src/css-regions/lib/range-extensions.js","../src/css-regions/lib/helpers.js","../src/css-regions/lib/objectmodel.js","../src/css-regions/polyfill.js","../src/requirements.js"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mD;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;ACxzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iE;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6D;;;;ACnXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sD;;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;AC9yBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;AC9aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0D;;;;ACjgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iD;;;;AC3mBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qD;;;;AChoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8C;;;;AC3+BA;AACA;AACA;AACA;AACA,sC","file":"css-regions-polyfill.js","sourcesContent":["!(function(window, document) { \"use strict\";\n\n\t//\n\t// some code for console polyfilling\n\t//\n\tif(!window.console) {\n\t\t\t\n\t\twindow.console = {\n\t\t\tbacklog: '',\n\t\t\t\n\t\t\tlog: function(x) { this.backlog+=x+'\\n'; if(window.debug) alert(x); },\n\t\t\t\n\t\t\tdir: function(x) { try { \n\t\t\t\t\n\t\t\t\tvar elm = function(e) {\n\t\t\t\t\tif(e.innerHTML) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttagName: e.tagName,\n\t\t\t\t\t\t\tclassName: e.className,\n\t\t\t\t\t\t\tid: e.id,\n\t\t\t\t\t\t\tinnerHTML: e.innerHTML.substr(0,100)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tnodeName: e.nodeName,\n\t\t\t\t\t\t\tnodeValue: e.nodeValue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tvar jsonify = function(o) {\n\t\t\t\t\tvar seen=[];\n\t\t\t\t\tvar jso=JSON.stringify(o, function(k,v){\n\t\t\t\t\t\tif (typeof v =='object') {\n\t\t\t\t\t\t\tif ( !seen.indexOf(v) ) { return '__cycle__'; }\n\t\t\t\t\t\t\tif ( v instanceof window.Node) { return elm(v); }\n\t\t\t\t\t\t\tseen.push(v);\n\t\t\t\t\t\t} return v;\n\t\t\t\t\t});\n\t\t\t\t\treturn jso;\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tthis.log(jsonify(x)); \n\t\t\t\t\n\t\t\t} catch(ex) { this.log(x) } },\n\t\t\t\n\t\t\twarn: function(x) { this.log(x) },\n\t\t\t\n\t\t\terror: function(x) { this.log(\"ERROR:\"); this.log(x); }\n\t\t\t\n\t\t};\n\t\t\n\t\tif(!window.onerror) {\n\t\t\twindow.onerror = function() {\n\t\t\t\tconsole.log([].slice.call(arguments,0).join(\"\\n\"))\n\t\t\t};\n\t\t}\n\t\t\n\t}\n\n\t//\n\t// this special console is used as a proxy emulating the CSS console of browsers\n\t//\n\twindow.cssConsole = {\n\t\tenabled: (!!window.debug), warnEnabled: (true),\n\t\tlog: function(x) { if(this.enabled) console.log(x) },\n\t\tdir: function(x) { if(this.enabled) console.dir(x) },\n\t\twarn: function(x) { if(this.warnEnabled) console.warn(x) },\n\t\terror: function(x) { console.error(x); }\n\t}\n\n})(window, document);\nrequire.define('src/core/polyfill-dom-console.js');","module.exports = (function(window, document) { \"use strict\";\n\n\trequire('src/core/polyfill-dom-console.js');\n\n\t//\n\t// some other basic om code\n\t//\n\tvar domEvents = {\n\t\t\n\t\t//\n\t\t// the following functions are about event cloning\n\t\t//\n\t\tcloneMouseEvent: function cloneMouseEvent(e) {\n\t\t\tvar evt = document.createEvent(\"MouseEvent\");\n\t\t\tevt.initMouseEvent( \n\t\t\t\te.type, \n\t\t\t\te.canBubble||e.bubbles, \n\t\t\t\te.cancelable, \n\t\t\t\te.view, \n\t\t\t\te.detail, \n\t\t\t\te.screenX, \n\t\t\t\te.screenY, \n\t\t\t\te.clientX, \n\t\t\t\te.clientY, \n\t\t\t\te.ctrlKey, \n\t\t\t\te.altKey, \n\t\t\t\te.shiftKey, \n\t\t\t\te.metaKey, \n\t\t\t\te.button, \n\t\t\t\te.relatedTarget\n\t\t\t);\n\t\t\treturn evt;\n\t\t},\n\t\t\n\t\tcloneKeyboardEvent: function cloneKeyboardEvent(e) {\n\t\t\t// TODO: this doesn't work cross-browser...\n\t\t\t// see https://gist.github.com/termi/4654819/ for the huge code\n\t\t\treturn domEvents.cloneCustomEvent(e);\n\t\t},\n\t\t\n\t\tcloneCustomEvent: function cloneCustomEvent(e) {\n\t\t\tvar ne = document.createEvent(\"CustomEvent\");\n\t\t\tne.initCustomEvent(e.type, e.canBubble||e.bubbles, e.cancelable, \"detail\" in e ? e.detail : e);\n\t\t\tfor(var prop in e) {\n\t\t\t\ttry {\n\t\t\t\t\tif(e[prop] != ne[prop] && e[prop] != e.target) {\n\t\t\t\t\t\ttry { ne[prop] = e[prop]; }\n\t\t\t\t\t\tcatch (ex) { Object.defineProperty(ne,prop,{get:function() { return e[prop]} }) }\n\t\t\t\t\t}\n\t\t\t\t} catch(ex) {}\n\t\t\t}\n\t\t\treturn ne;\n\t\t},\n\t\t\n\t\tcloneEvent: function cloneEvent(e) {\n\t\t\t\n\t\t\tif(e instanceof MouseEvent) {\n\t\t\t\treturn domEvents.cloneMouseEvent(e);\n\t\t\t} else if(e instanceof KeyboardEvent) {\n\t\t\t\treturn domEvents.cloneKeyboardEvent(e);\n\t\t\t} else {\n\t\t\t\treturn domEvents.cloneCustomEvent(e);\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// allows you to drop event support to any class easily\n\t\t//\n\t\tEventTarget: {\n\t\t\timplementsIn: function(eventClass, static_class) {\n\t\t\t\t\n\t\t\t\tif(!static_class && typeof(eventClass)==\"function\") eventClass=eventClass.prototype;\n\t\t\t\t\n\t\t\t\teventClass.dispatchEvent = domEvents.EventTarget.prototype.dispatchEvent;\n\t\t\t\teventClass.addEventListener = domEvents.EventTarget.prototype.addEventListener;\n\t\t\t\teventClass.removeEventListener = domEvents.EventTarget.prototype.removeEventListener;\n\t\t\t\t\n\t\t\t},\n\t\t\tprototype: {}\n\t\t}\n\t\t\n\t};\n\n\tdomEvents.EventTarget.prototype.addEventListener = function(eventType,f) {\n\t\tif(!this.eventListeners) this.eventListeners=[];\n\t\t\n\t\tvar ls = (this.eventListeners[eventType] || (this.eventListeners[eventType]=[]));\n\t\tif(ls.indexOf(f)==-1) {\n\t\t\tls.push(f);\n\t\t}\n\t\t\n\t}\n\n\tdomEvents.EventTarget.prototype.removeEventListener = function(eventType,f) {\n\t\tif(!this.eventListeners) this.eventListeners=[];\n\n\t\tvar ls = (this.eventListeners[eventType] || (this.eventListeners[eventType]=[])), i;\n\t\tif((i=ls.indexOf(f))!==-1) {\n\t\t\tls.splice(i,1);\n\t\t}\n\t\t\n\t}\n\n\tdomEvents.EventTarget.prototype.dispatchEvent = function(event_or_type) {\n\t\tif(!this.eventListeners) this.eventListeners=[];\n\t\t\n\t\t// abort quickly when no listener has been set up\n\t\tif(typeof(event_or_type) == \"string\") {\n\t\t\tif(!this.eventListeners[event_or_type] || this.eventListeners[event_or_type].length==0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif(!this.eventListeners[event_or_type.type] || this.eventListeners[event_or_type.type].length==0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// convert the event\n\t\tvar event = event_or_type;\n\t\tfunction setUpPropertyForwarding(e,ee,key) {\n\t\t\tObject.defineProperty(ee,key,{\n\t\t\t\tget:function() {\n\t\t\t\t\tvar v = e[key]; \n\t\t\t\t\tif(typeof(v)==\"function\") {\n\t\t\t\t\t\treturn v.bind(e);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn v;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tset:function(v) {\n\t\t\t\t\te[key] = v;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tfunction setUpTarget(e,v) {\n\t\t\ttry { Object.defineProperty(e,\"target\",{get:function() {return v}}); }\n\t\t\tcatch(ex) {}\n\t\t\tfinally {\n\t\t\t\t\n\t\t\t\tif(e.target !== v) {\n\t\t\t\t\t\n\t\t\t\t\tvar ee = Object.create(Object.getPrototypeOf(e));\n\t\t\t\t\tee = setUpTarget(ee,v);\n\t\t\t\t\tfor(var key in e) {\n\t\t\t\t\t\tif(key != \"target\") setUpPropertyForwarding(e,ee,key);\n\t\t\t\t\t}\n\t\t\t\t\treturn ee;\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\treturn e;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t// try to set the target\n\t\tif(typeof(event)==\"object\") {\n\t\t\ttry { event=setUpTarget(event,this); } catch(ex) {}\n\t\t\t\n\t\t} else if(typeof(event)==\"string\") {\n\t\t\tevent = document.createEvent(\"CustomEvent\");\n\t\t\tevent.initCustomEvent(event_or_type, /*canBubble:*/ true, /*cancelable:*/ false, /*detail:*/this);\n\t\t\ttry { event=setUpTarget(event,this); } catch(ex) {}\n\t\t\t\n\t\t} else {\n\t\t\tthrow new Error(\"dispatchEvent expect an Event object or a string containing the event type\");\n\t\t}\n\t\t\n\t\t// call all listeners\n\t\tvar ls = (this.eventListeners[event.type] || (this.eventListeners[event.type]=[]));\n\t\tfor(var i=ls.length; i--;) {\n\t\t\ttry { \n\t\t\t\tls[i](event);\n\t\t\t} catch(ex) {\n\t\t\t\tsetImmediate(function() { throw ex; });\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn event.isDefaultPrevented;\n\t}\n\t\n\treturn domEvents;\n\t\n})(window, document);\n\nrequire.define('src/core/dom-events.js');","//\n// note: this file is based on Tab Atkins's CSS Parser\n// please include him (@tabatkins) if you open any issue for this file\n// \nmodule.exports = (function(window, document) { \"use strict\";\n\n// \n// exports\n//\nvar cssSyntax = { \n\ttokenize: function(string) {/*filled later*/}, \n\tparse: function(tokens) {/*filled later*/}\n};\n\n//\n// css tokenizer\n//\n\n// Add support for token lists (superclass of array)\nfunction TokenList() {\n\tvar array = []; \n\tarray.toCSSString=TokenListToCSSString;\n\treturn array;\n}\nfunction TokenListToCSSString(sep) {\n\tif(sep) {\n\t\treturn this.map(function(o) { return o.toCSSString(); }).join(sep);\n\t} else {\n\t\treturn this.asCSSString || (this.asCSSString = (\n\t\t\tthis.map(function(o) { return o.toCSSString(); }).join(\"/**/\")\n\t\t\t\t.replace(/( +\\/\\*\\*\\/ *| * | *\\/\\*\\*\\/ +)/g,\" \")\n\t\t\t\t.replace(/( +\\/\\*\\*\\/ *| * | *\\/\\*\\*\\/ +)/g,\" \")\n\t\t\t\t.replace(/(\\!|\\:|\\;|\\@|\\.|\\,|\\*|\\=|\\&|\\\\|\\/|\\<|\\>|\\[|\\{|\\(|\\]|\\}|\\)|\\|)\\/\\*\\*\\//g,\"$1\")\n\t\t\t\t.replace(/\\/\\*\\*\\/(\\!|\\:|\\;|\\@|\\.|\\,|\\*|\\=|\\&|\\\\|\\/|\\<|\\>|\\[|\\{|\\(|\\]|\\}|\\)|\\|)/g,\"$1\")\n\t\t));\n\t}\n}\ncssSyntax.TokenList = TokenList;\ncssSyntax.TokenListToCSSString = TokenListToCSSString;\n\nfunction between(num, first, last) { return num >= first && num <= last; }\nfunction digit(code) { return between(code, 0x30,0x39); }\nfunction hexdigit(code) { return digit(code) || between(code, 0x41,0x46) || between(code, 0x61,0x66); }\nfunction uppercaseletter(code) { return between(code, 0x41,0x5a); }\nfunction lowercaseletter(code) { return between(code, 0x61,0x7a); }\nfunction letter(code) { return uppercaseletter(code) || lowercaseletter(code); }\nfunction nonascii(code) { return code >= 0x80; }\nfunction namestartchar(code) { return letter(code) || nonascii(code) || code == 0x5f; }\nfunction namechar(code) { return namestartchar(code) || digit(code) || code == 0x2d; }\nfunction nonprintable(code) { return between(code, 0,8) || code == 0xb || between(code, 0xe,0x1f) || code == 0x7f; }\nfunction newline(code) { return code == 0xa; }\nfunction whitespace(code) { return newline(code) || code == 9 || code == 0x20; }\nfunction badescape(code) { return newline(code) || isNaN(code); }\n\nvar maximumallowedcodepoint = 0x10ffff;\n\nfunction InvalidCharacterError(message) {\n\tthis.message = message;\n};\nInvalidCharacterError.prototype = new Error;\nInvalidCharacterError.prototype.name = 'InvalidCharacterError';\n\nfunction preprocess(str) {\n\t// Turn a string into an array of code points,\n\t// following the preprocessing cleanup rules.\n\tvar codepoints = [];\n\tfor(var i = 0; i < str.length; i++) {\n\t\tvar code = str.charCodeAt(i);\n\t\tif(code == 0xd && str.charCodeAt(i+1) == 0xa) {\n\t\t\tcode = 0xa; i++;\n\t\t}\n\t\tif(code == 0xd || code == 0xc) code = 0xa;\n\t\tif(code == 0x0) code = 0xfffd;\n\t\tif(between(code, 0xd800, 0xdbff) && between(str.charCodeAt(i+1), 0xdc00, 0xdfff)) {\n\t\t\t// Decode a surrogate pair into an astral codepoint.\n\t\t\tvar lead = code - 0xd800;\n\t\t\tvar trail = str.charCodeAt(i+1) - 0xdc00;\n\t\t\tcode = Math.pow(2, 21) + lead * Math.pow(2, 10) + trail;\n\t\t}\n\t\tcodepoints.push(code);\n\t}\n\treturn codepoints;\n}\n\nfunction stringFromCode(code) {\n\tif(code <= 0xffff) return String.fromCharCode(code);\n\t// Otherwise, encode astral char as surrogate pair.\n\tcode -= Math.pow(2, 21);\n\tvar lead = Math.floor(code/Math.pow(2, 10)) + 0xd800;\n\tvar trail = code % Math.pow(2, 10); + 0xdc00;\n\treturn String.fromCharCode(lead) + String.fromCharCode(trail);\n}\n\nfunction tokenize(str) {\n\tstr = preprocess(str);\n\tvar i = -1;\n\tvar tokens = new TokenList();\n\tvar code;\n\n\t// Line number information.\n\tvar line = 0;\n\tvar column = 0;\n\t// The only use of lastLineLength is in reconsume().\n\tvar lastLineLength = 0;\n\tvar incrLineno = function() {\n\t\tline += 1;\n\t\tlastLineLength = column;\n\t\tcolumn = 0;\n\t};\n\tvar locStart = {line:line, column:column};\n\n\tvar codepoint = function(i) {\n\t\tif(i >= str.length) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn str[i];\n\t}\n\tvar next = function(num) {\n\t\tif(num === undefined) { num = 1; }\n\t\tif(num > 3) { throw \"Spec Error: no more than three codepoints of lookahead.\"; }\n\t\treturn codepoint(i+num);\n\t};\n\tvar consume = function(num) {\n\t\tif(num === undefined)\n\t\t\tnum = 1;\n\t\ti += num;\n\t\tcode = codepoint(i);\n\t\tif(newline(code)) incrLineno();\n\t\telse column += num;\n\t\t//console.log('Consume '+i+' '+String.fromCharCode(code) + ' 0x' + code.toString(16));\n\t\treturn true;\n\t};\n\tvar reconsume = function() {\n\t\ti -= 1;\n\t\tif (newline(code)) {\n\t\t\tline -= 1;\n\t\t\tcolumn = lastLineLength;\n\t\t} else {\n\t\t\tcolumn -= 1;\n\t\t}\n\t\tlocStart.line = line;\n\t\tlocStart.column = column;\n\t\treturn true;\n\t};\n\tvar eof = function(codepoint) {\n\t\tif(codepoint === undefined) codepoint = code;\n\t\treturn codepoint == -1;\n\t};\n\tvar donothing = function() {};\n\tvar tokenizeerror = function() { console.log(\"Parse error at index \" + i + \", processing codepoint 0x\" + code.toString(16) + \".\");return true; };\n\n\tvar consumeAToken = function() {\n\t\tconsumeComments();\n\t\tconsume();\n\t\tif(whitespace(code)) {\n\t\t\twhile(whitespace(next())) consume();\n\t\t\treturn new WhitespaceToken;\n\t\t}\n\t\telse if(code == 0x22) return consumeAStringToken();\n\t\telse if(code == 0x23) {\n\t\t\tif(namechar(next()) || areAValidEscape(next(1), next(2))) {\n\t\t\t\tvar token = new HashToken();\n\t\t\t\tif(wouldStartAnIdentifier(next(1), next(2), next(3))) token.type = \"id\";\n\t\t\t\ttoken.value = consumeAName();\n\t\t\t\treturn token;\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x24) {\n\t\t\tif(next() == 0x3d) {\n\t\t\t\tconsume();\n\t\t\t\treturn new SuffixMatchToken();\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x27) return consumeAStringToken();\n\t\telse if(code == 0x28) return new OpenParenToken();\n\t\telse if(code == 0x29) return new CloseParenToken();\n\t\telse if(code == 0x2a) {\n\t\t\tif(next() == 0x3d) {\n\t\t\t\tconsume();\n\t\t\t\treturn new SubstringMatchToken();\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x2b) {\n\t\t\tif(startsWithANumber()) {\n\t\t\t\treconsume();\n\t\t\t\treturn consumeANumericToken();\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x2c) return new CommaToken();\n\t\telse if(code == 0x2d) {\n\t\t\tif(startsWithANumber()) {\n\t\t\t\treconsume();\n\t\t\t\treturn consumeANumericToken();\n\t\t\t} else if(next(1) == 0x2d && next(2) == 0x3e) {\n\t\t\t\tconsume(2);\n\t\t\t\treturn new CDCToken();\n\t\t\t} else if(startsWithAnIdentifier()) {\n\t\t\t\treconsume();\n\t\t\t\treturn consumeAnIdentlikeToken();\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x2e) {\n\t\t\tif(startsWithANumber()) {\n\t\t\t\treconsume();\n\t\t\t\treturn consumeANumericToken();\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x3a) return new ColonToken;\n\t\telse if(code == 0x3b) return new SemicolonToken;\n\t\telse if(code == 0x3c) {\n\t\t\tif(next(1) == 0x21 && next(2) == 0x2d && next(3) == 0x2d) {\n\t\t\t\tconsume(3);\n\t\t\t\treturn new CDOToken();\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x40) {\n\t\t\tif(wouldStartAnIdentifier(next(1), next(2), next(3))) {\n\t\t\t\treturn new AtKeywordToken(consumeAName());\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x5b) return new OpenSquareToken();\n\t\telse if(code == 0x5c) {\n\t\t\tif(startsWithAValidEscape()) {\n\t\t\t\treconsume();\n\t\t\t\treturn consumeAnIdentlikeToken();\n\t\t\t} else {\n\t\t\t\ttokenizeerror();\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x5d) return new CloseSquareToken();\n\t\telse if(code == 0x5e) {\n\t\t\tif(next() == 0x3d) {\n\t\t\t\tconsume();\n\t\t\t\treturn new PrefixMatchToken();\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x7b) return new OpenCurlyToken();\n\t\telse if(code == 0x7c) {\n\t\t\tif(next() == 0x3d) {\n\t\t\t\tconsume();\n\t\t\t\treturn new DashMatchToken();\n\t\t\t} else if(next() == 0x7c) {\n\t\t\t\tconsume();\n\t\t\t\treturn new ColumnToken();\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x7d) return new CloseCurlyToken();\n\t\telse if(code == 0x7e) {\n\t\t\tif(next() == 0x3d) {\n\t\t\t\tconsume();\n\t\t\t\treturn new IncludeMatchToken();\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(digit(code)) {\n\t\t\treconsume();\n\t\t\treturn consumeANumericToken();\n\t\t}\n\t\telse if(namestartchar(code)) {\n\t\t\treconsume();\n\t\t\treturn consumeAnIdentlikeToken();\n\t\t}\n\t\telse if(eof()) return new EOFToken();\n\t\telse return new DelimToken(code);\n\t};\n\n\tvar consumeComments = function() {\n\t\twhile(next(1) == 0x2f && next(2) == 0x2a) {\n\t\t\tconsume(2);\n\t\t\twhile(true) {\n\t\t\t\tconsume();\n\t\t\t\tif(code == 0x2a && next() == 0x2f) {\n\t\t\t\t\tconsume();\n\t\t\t\t\tbreak;\n\t\t\t\t} else if(eof()) {\n\t\t\t\t\ttokenizeerror();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tvar consumeANumericToken = function() {\n\t\tvar num = consumeANumber();\n\t\tif(wouldStartAnIdentifier(next(1), next(2), next(3))) {\n\t\t\tvar token = new DimensionToken();\n\t\t\ttoken.value = num.value;\n\t\t\ttoken.repr = num.repr;\n\t\t\ttoken.type = num.type;\n\t\t\ttoken.unit = consumeAName();\n\t\t\treturn token;\n\t\t} else if(next() == 0x25) {\n\t\t\tconsume();\n\t\t\tvar token = new PercentageToken();\n\t\t\ttoken.value = num.value;\n\t\t\ttoken.repr = num.repr;\n\t\t\treturn token;\n\t\t} else {\n\t\t\tvar token = new NumberToken();\n\t\t\ttoken.value = num.value;\n\t\t\ttoken.repr = num.repr;\n\t\t\ttoken.type = num.type;\n\t\t\treturn token;\n\t\t}\n\t};\n\n\tvar consumeAnIdentlikeToken = function() {\n\t\tvar str = consumeAName();\n\t\tif(str.toLowerCase() == \"url\" && next() == 0x28) {\n\t\t\tconsume();\n\t\t\twhile(whitespace(next(1)) && whitespace(next(2))) consume();\n\t\t\tif(next() == 0x22 || next() == 0x27) {\n\t\t\t\treturn new FunctionToken(str);\n\t\t\t} else if(whitespace(next()) && (next(2) == 0x22 || next(2) == 0x27)) {\n\t\t\t\treturn new FunctionToken(str);\n\t\t\t} else {\n\t\t\t\treturn consumeAURLToken();\n\t\t\t}\n\t\t} else if(next() == 0x28) {\n\t\t\tconsume();\n\t\t\treturn new FunctionToken(str);\n\t\t} else {\n\t\t\treturn new IdentifierToken(str);\n\t\t}\n\t};\n\n\tvar consumeAStringToken = function(endingCodePoint) {\n\t\tif(endingCodePoint === undefined) endingCodePoint = code;\n\t\tvar string = \"\";\n\t\twhile(consume()) {\n\t\t\tif(code == endingCodePoint || eof()) {\n\t\t\t\treturn new StringToken(string);\n\t\t\t} else if(newline(code)) {\n\t\t\t\ttokenizeerror();\n\t\t\t\treconsume();\n\t\t\t\treturn new BadStringToken();\n\t\t\t} else if(code == 0x5c) {\n\t\t\t\tif(eof(next())) {\n\t\t\t\t\tdonothing();\n\t\t\t\t} else if(newline(next())) {\n\t\t\t\t\tconsume();\n\t\t\t\t} else {\n\t\t\t\t\tstring += stringFromCode(consumeEscape())\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstring += stringFromCode(code);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar consumeAURLToken = function() {\n\t\tvar token = new URLToken(\"\");\n\t\twhile(whitespace(next())) consume();\n\t\tif(eof(next())) return token;\n\t\twhile(consume()) {\n\t\t\tif(code == 0x29 || eof()) {\n\t\t\t\treturn token;\n\t\t\t} else if(whitespace(code)) {\n\t\t\t\twhile(whitespace(next())) consume();\n\t\t\t\tif(next() == 0x29 || eof(next())) {\n\t\t\t\t\tconsume();\n\t\t\t\t\treturn token;\n\t\t\t\t} else {\n\t\t\t\t\tconsumeTheRemnantsOfABadURL();\n\t\t\t\t\treturn new BadURLToken();\n\t\t\t\t}\n\t\t\t} else if(code == 0x22 || code == 0x27 || code == 0x28 || nonprintable(code)) {\n\t\t\t\ttokenizeerror();\n\t\t\t\tconsumeTheRemnantsOfABadURL();\n\t\t\t\treturn new BadURLToken();\n\t\t\t} else if(code == 0x5c) {\n\t\t\t\tif(startsWithAValidEscape()) {\n\t\t\t\t\ttoken.value += stringFromCode(consumeEscape());\n\t\t\t\t} else {\n\t\t\t\t\ttokenizeerror();\n\t\t\t\t\tconsumeTheRemnantsOfABadURL();\n\t\t\t\t\treturn new BadURLToken();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttoken.value += stringFromCode(code);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar consumeEscape = function() {\n\t\t// Assume the the current character is the \\\n\t\t// and the next code point is not a newline.\n\t\tconsume();\n\t\tif(hexdigit(code)) {\n\t\t\t// Consume 1-6 hex digits\n\t\t\tvar digits = [code];\n\t\t\tfor(var total = 0; total < 5; total++) {\n\t\t\t\tif(hexdigit(next())) {\n\t\t\t\t\tconsume();\n\t\t\t\t\tdigits.push(code);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(whitespace(next())) consume();\n\t\t\tvar value = parseInt(digits.map(function(x){return String.fromCharCode(x);}).join(''), 16);\n\t\t\tif( value > maximumallowedcodepoint ) value = 0xfffd;\n\t\t\treturn value;\n\t\t} else if(eof()) {\n\t\t\treturn 0xfffd;\n\t\t} else {\n\t\t\treturn code;\n\t\t}\n\t};\n\n\tvar areAValidEscape = function(c1, c2) {\n\t\tif(c1 != 0x5c) return false;\n\t\tif(newline(c2)) return false;\n\t\treturn true;\n\t};\n\tvar startsWithAValidEscape = function() {\n\t\treturn areAValidEscape(code, next());\n\t};\n\n\tvar wouldStartAnIdentifier = function(c1, c2, c3) {\n\t\tif(c1 == 0x2d) {\n\t\t\treturn namestartchar(c2) || c2 == 0x2d || areAValidEscape(c2, c3);\n\t\t} else if(namestartchar(c1)) {\n\t\t\treturn true;\n\t\t} else if(c1 == 0x5c) {\n\t\t\treturn areAValidEscape(c1, c2);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\tvar startsWithAnIdentifier = function() {\n\t\treturn wouldStartAnIdentifier(code, next(1), next(2));\n\t};\n\n\tvar wouldStartANumber = function(c1, c2, c3) {\n\t\tif(c1 == 0x2b || c1 == 0x2d) {\n\t\t\tif(digit(c2)) return true;\n\t\t\tif(c2 == 0x2e && digit(c3)) return true;\n\t\t\treturn false;\n\t\t} else if(c1 == 0x2e) {\n\t\t\tif(digit(c2)) return true;\n\t\t\treturn false;\n\t\t} else if(digit(c1)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\tvar startsWithANumber = function() {\n\t\treturn wouldStartANumber(code, next(1), next(2));\n\t};\n\n\tvar consumeAName = function() {\n\t\tvar result = \"\";\n\t\twhile(consume()) {\n\t\t\tif(namechar(code)) {\n\t\t\t\tresult += stringFromCode(code);\n\t\t\t} else if(startsWithAValidEscape()) {\n\t\t\t\tresult += stringFromCode(consumeEscape());\n\t\t\t} else {\n\t\t\t\treconsume();\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t};\n\n\tvar consumeANumber = function() {\n\t\tvar repr = '';\n\t\tvar type = \"integer\";\n\t\tif(next() == 0x2b || next() == 0x2d) {\n\t\t\tconsume();\n\t\t\trepr += stringFromCode(code);\n\t\t}\n\t\twhile(digit(next())) {\n\t\t\tconsume();\n\t\t\trepr += stringFromCode(code);\n\t\t}\n\t\tif(next(1) == 0x2e && digit(next(2))) {\n\t\t\tconsume();\n\t\t\trepr += stringFromCode(code);\n\t\t\tconsume();\n\t\t\trepr += stringFromCode(code);\n\t\t\ttype = \"number\";\n\t\t\twhile(digit(next())) {\n\t\t\t\tconsume();\n\t\t\t\trepr += stringFromCode(code);\n\t\t\t}\n\t\t}\n\t\tvar c1 = next(1), c2 = next(2), c3 = next(3);\n\t\tif((c1 == 0x45 || c1 == 0x65) && digit(c2)) {\n\t\t\tconsume();\n\t\t\trepr += stringFromCode(code);\n\t\t\tconsume();\n\t\t\trepr += stringFromCode(code);\n\t\t\ttype = \"number\";\n\t\t\twhile(digit(next())) {\n\t\t\t\tconsume();\n\t\t\t\trepr += stringFromCode(code);\n\t\t\t}\n\t\t} else if((c1 == 0x45 || c1 == 0x65) && (c2 == 0x2b || c2 == 0x2d) && digit(c3)) {\n\t\t\tconsume();\n\t\t\trepr += stringFromCode(code);\n\t\t\tconsume();\n\t\t\trepr += stringFromCode(code);\n\t\t\tconsume();\n\t\t\trepr += stringFromCode(code);\n\t\t\ttype = \"number\";\n\t\t\twhile(digit(next())) {\n\t\t\t\tconsume();\n\t\t\t\trepr += stringFromCode(code);\n\t\t\t}\n\t\t}\n\t\tvar value = convertAStringToANumber(repr);\n\t\treturn {type:type, value:value, repr:repr};\n\t};\n\n\tvar convertAStringToANumber = function(string) {\n\t\t// CSS's number rules are identical to JS, afaik.\n\t\treturn +string;\n\t};\n\n\tvar consumeTheRemnantsOfABadURL = function() {\n\t\twhile(consume()) {\n\t\t\tif(code == 0x2d || eof()) {\n\t\t\t\treturn;\n\t\t\t} else if(startsWithAValidEscape()) {\n\t\t\t\tconsumeEscape();\n\t\t\t\tdonothing();\n\t\t\t} else {\n\t\t\t\tdonothing();\n\t\t\t}\n\t\t}\n\t};\n\n\n\n\tvar iterationCount = 0;\n\twhile(!eof(next())) {\n\t\ttokens.push(consumeAToken());\n\t\tif(iterationCount++ > str.length*2) throw new Error(\"The CSS Tokenizer is infinite-looping\");\n\t}\n\treturn tokens;\n}\n\nfunction CSSParserToken() { return this; }\nCSSParserToken.prototype.toJSON = function() {\n\treturn {token: this.tokenType};\n}\nCSSParserToken.prototype.toString = function() { return this.tokenType; }\nCSSParserToken.prototype.toCSSString = function() { return ''+this; }\n\nfunction BadStringToken() { return this; }\nBadStringToken.prototype = new CSSParserToken;\nBadStringToken.prototype.tokenType = \"BADSTRING\";\nBadStringToken.prototype.toCSSString = function() { return \"'\"; }\n\nfunction BadURLToken() { return this; }\nBadURLToken.prototype = new CSSParserToken;\nBadURLToken.prototype.tokenType = \"BADURL\";\nBadURLToken.prototype.toCSSString = function() { return \"url(\"; }\n\nfunction WhitespaceToken() { return this; }\nWhitespaceToken.prototype = new CSSParserToken;\nWhitespaceToken.prototype.tokenType = \"WHITESPACE\";\nWhitespaceToken.prototype.toString = function() { return \"WS\"; }\nWhitespaceToken.prototype.toCSSString = function() { return \" \"; }\n\nfunction CDOToken() { return this; }\nCDOToken.prototype = new CSSParserToken;\nCDOToken.prototype.tokenType = \"CDO\";\nCDOToken.prototype.toCSSString = function() { return \"<!--\"; }\n\nfunction CDCToken() { return this; }\nCDCToken.prototype = new CSSParserToken;\nCDCToken.prototype.tokenType = \"CDC\";\nCDCToken.prototype.toCSSString = function() { return \"-->\"; }\n\nfunction ColonToken() { return this; }\nColonToken.prototype = new CSSParserToken;\nColonToken.prototype.tokenType = \":\";\n\nfunction SemicolonToken() { return this; }\nSemicolonToken.prototype = new CSSParserToken;\nSemicolonToken.prototype.tokenType = \";\";\n\nfunction CommaToken() { return this; }\nCommaToken.prototype = new CSSParserToken;\nCommaToken.prototype.tokenType = \",\";\nCommaToken.prototype.value = \";\"; // backwards-compat with DELIM token\n\nfunction GroupingToken() { return this; }\nGroupingToken.prototype = new CSSParserToken;\n\nfunction OpenCurlyToken() { this.value = \"{\"; this.mirror = \"}\"; return this; }\nOpenCurlyToken.prototype = new GroupingToken;\nOpenCurlyToken.prototype.tokenType = \"{\";\n\nfunction CloseCurlyToken() { this.value = \"}\"; this.mirror = \"{\"; return this; }\nCloseCurlyToken.prototype = new GroupingToken;\nCloseCurlyToken.prototype.tokenType = \"}\";\n\nfunction OpenSquareToken() { this.value = \"[\"; this.mirror = \"]\"; return this; }\nOpenSquareToken.prototype = new GroupingToken;\nOpenSquareToken.prototype.tokenType = \"[\";\n\nfunction CloseSquareToken() { this.value = \"]\"; this.mirror = \"[\"; return this; }\nCloseSquareToken.prototype = new GroupingToken;\nCloseSquareToken.prototype.tokenType = \"]\";\n\nfunction OpenParenToken() { this.value = \"(\"; this.mirror = \")\"; return this; }\nOpenParenToken.prototype = new GroupingToken;\nOpenParenToken.prototype.tokenType = \"(\";\n\nfunction CloseParenToken() { this.value = \")\"; this.mirror = \"(\"; return this; }\nCloseParenToken.prototype = new GroupingToken;\nCloseParenToken.prototype.tokenType = \")\";\n\nfunction IncludeMatchToken() { return this; }\nIncludeMatchToken.prototype = new CSSParserToken;\nIncludeMatchToken.prototype.tokenType = \"~=\";\n\nfunction DashMatchToken() { return this; }\nDashMatchToken.prototype = new CSSParserToken;\nDashMatchToken.prototype.tokenType = \"|=\";\n\nfunction PrefixMatchToken() { return this; }\nPrefixMatchToken.prototype = new CSSParserToken;\nPrefixMatchToken.prototype.tokenType = \"^=\";\n\nfunction SuffixMatchToken() { return this; }\nSuffixMatchToken.prototype = new CSSParserToken;\nSuffixMatchToken.prototype.tokenType = \"$=\";\n\nfunction SubstringMatchToken() { return this; }\nSubstringMatchToken.prototype = new CSSParserToken;\nSubstringMatchToken.prototype.tokenType = \"*=\";\n\nfunction ColumnToken() { return this; }\nColumnToken.prototype = new CSSParserToken;\nColumnToken.prototype.tokenType = \"||\";\n\nfunction EOFToken() { return this; }\nEOFToken.prototype = new CSSParserToken;\nEOFToken.prototype.tokenType = \"EOF\";\nEOFToken.prototype.toCSSString = function() { return \"\"; }\n\nfunction DelimToken(code) {\n\tthis.value = stringFromCode(code);\n\treturn this;\n}\nDelimToken.prototype = new CSSParserToken;\nDelimToken.prototype.tokenType = \"DELIM\";\nDelimToken.prototype.toString = function() { return \"DELIM(\"+this.value+\")\"; }\nDelimToken.prototype.toCSSString = function() {\n\treturn (this.value == \"\\\\\") ? \"\\\\\\n\" : this.value;\n}\n\nfunction StringValuedToken() { return this; }\nStringValuedToken.prototype = new CSSParserToken;\nStringValuedToken.prototype.ASCIIMatch = function(str) {\n\treturn this.value.toLowerCase() == str.toLowerCase();\n}\n\nfunction IdentifierToken(val) {\n\tthis.value = val;\n}\nIdentifierToken.prototype = new StringValuedToken;\nIdentifierToken.prototype.tokenType = \"IDENT\";\nIdentifierToken.prototype.toString = function() { return \"IDENT(\"+this.value+\")\"; }\nIdentifierToken.prototype.toCSSString = function() {\n\treturn escapeIdent(this.value);\n}\n\nfunction FunctionToken(val) {\n\tthis.value = val;\n\tthis.mirror = \")\";\n}\nFunctionToken.prototype = new StringValuedToken;\nFunctionToken.prototype.tokenType = \"FUNCTION\";\nFunctionToken.prototype.toString = function() { return \"FUNCTION(\"+this.value+\")\"; }\nFunctionToken.prototype.toCSSString = function() {\n\treturn escapeIdent(this.value) + \"(\";\n}\n\t\nfunction AtKeywordToken(val) {\n\tthis.value = val;\n}\nAtKeywordToken.prototype = new StringValuedToken;\nAtKeywordToken.prototype.tokenType = \"AT-KEYWORD\";\nAtKeywordToken.prototype.toString = function() { return \"AT(\"+this.value+\")\"; }\nAtKeywordToken.prototype.toCSSString = function() {\n\treturn \"@\" + escapeIdent(this.value);\n}\n\nfunction HashToken(val) {\n\tthis.value = val;\n\tthis.type = \"unrestricted\";\n}\nHashToken.prototype = new StringValuedToken;\nHashToken.prototype.tokenType = \"HASH\";\nHashToken.prototype.toString = function() { return \"HASH(\"+this.value+\")\"; }\nHashToken.prototype.toCSSString = function() {\n\tvar escapeValue = (this.type == \"id\") ? escapeIdent : escapeHash;\n\treturn \"#\" + escapeValue(this.value);\n}\n\nfunction StringToken(val) {\nthis.value = val;\n}\nStringToken.prototype = new StringValuedToken;\nStringToken.prototype.tokenType = \"STRING\";\nStringToken.prototype.toString = function() {\n\treturn '\"' + escapeString(this.value) + '\"';\n}\n\nfunction URLToken(val) {\n\tthis.value = val;\n}\nURLToken.prototype = new StringValuedToken;\nURLToken.prototype.tokenType = \"URL\";\nURLToken.prototype.toString = function() { return \"URL(\"+this.value+\")\"; }\nURLToken.prototype.toCSSString = function() {\n\treturn 'url(\"' + escapeString(this.value) + '\")';\n}\n\nfunction NumberToken() {\n\tthis.value = null;\n\tthis.type = \"integer\";\n\tthis.repr = \"\";\n}\nNumberToken.prototype = new CSSParserToken;\nNumberToken.prototype.tokenType = \"NUMBER\";\nNumberToken.prototype.toString = function() {\n\tif(this.type == \"integer\")\n\t\treturn \"INT(\"+this.value+\")\";\n\treturn \"NUMBER(\"+this.value+\")\";\n}\nNumberToken.prototype.toJSON = function() {\n\tvar json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n\tjson.value = this.value;\n\tjson.type = this.type;\n\tjson.repr = this.repr;\n\treturn json;\n}\nNumberToken.prototype.toCSSString = function() { return this.repr; };\n\nfunction PercentageToken() {\n\tthis.value = null;\n\tthis.repr = \"\";\n}\nPercentageToken.prototype = new CSSParserToken;\nPercentageToken.prototype.tokenType = \"PERCENTAGE\";\nPercentageToken.prototype.toString = function() { return \"PERCENTAGE(\"+this.value+\")\"; }\nPercentageToken.prototype.toCSSString = function() { return this.repr + \"%\"; }\n\nfunction DimensionToken() {\n\tthis.value = null;\n\tthis.type = \"integer\";\n\tthis.repr = \"\";\n\tthis.unit = \"\";\n}\nDimensionToken.prototype = new CSSParserToken;\nDimensionToken.prototype.tokenType = \"DIMENSION\";\nDimensionToken.prototype.toString = function() { return \"DIM(\"+this.value+\",\"+this.unit+\")\"; }\nDimensionToken.prototype.toCSSString = function() {\n\tvar source = this.repr;\n\tvar unit = escapeIdent(this.unit);\n\tif(unit[0].toLowerCase() == \"e\" && (unit[1] == \"-\" || between(unit.charCodeAt(1), 0x30, 0x39))) {\n\t\t// Unit is ambiguous with scinot\n\t\t// Remove the leading \"e\", replace with escape.\n\t\tunit = \"\\\\65 \" + unit.slice(1, unit.length);\n\t}\n\treturn source+unit;\n}\n\nfunction escapeIdent(string) {\n\tstring = ''+string;\n\tvar result = '';\n\tvar firstcode = string.charCodeAt(0);\n\tfor(var i = 0; i < string.length; i++) {\n\t\tvar code = string.charCodeAt(i);\n\t\tif(code == 0x0) {\n\t\t\tthrow new InvalidCharacterError('Invalid character: the input contains U+0000.');\n\t\t}\n\n\t\tif(\n\t\t\tbetween(code, 0x1, 0x1f) || code == 0x7f ||\n\t\t\t(i == 0 && between(code, 0x30, 0x39)) ||\n\t\t\t(i == 1 && between(code, 0x30, 0x39) && firstcode == 0x2d)\n\t\t) {\n\t\t\tresult += '\\\\' + code.toString(16) + ' ';\n\t\t} else if(\n\t\t\tcode >= 0x80 ||\n\t\t\tcode == 0x2d ||\n\t\t\tcode == 0x5f ||\n\t\t\tbetween(code, 0x30, 0x39) ||\n\t\t\tbetween(code, 0x41, 0x5a) ||\n\t\t\tbetween(code, 0x61, 0x7a)\n\t\t) {\n\t\t\tresult += string[i];\n\t\t} else {\n\t\t\tresult += '\\\\' + string[i];\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction escapeHash(string) {\n\t// Escapes the contents of \"unrestricted\"-type hash tokens.\n\t// Won't preserve the ID-ness of \"id\"-type hash tokens;\n\t// use escapeIdent() for that.\n\tstring = ''+string;\n\tvar result = '';\n\tvar firstcode = string.charCodeAt(0);\n\tfor(var i = 0; i < string.length; i++) {\n\t\tvar code = string.charCodeAt(i);\n\t\tif(code == 0x0) {\n\t\t\tthrow new InvalidCharacterError('Invalid character: the input contains U+0000.');\n\t\t}\n\n\t\tif(\n\t\t\tcode >= 0x80 ||\n\t\t\tcode == 0x2d ||\n\t\t\tcode == 0x5f ||\n\t\t\tbetween(code, 0x30, 0x39) ||\n\t\t\tbetween(code, 0x41, 0x5a) ||\n\t\t\tbetween(code, 0x61, 0x7a)\n\t\t) {\n\t\t\tresult += string[i];\n\t\t} else {\n\t\t\tresult += '\\\\' + code.toString(16) + ' ';\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction escapeString(string) {\n\tstring = ''+string;\n\tvar result = '';\n\tfor(var i = 0; i < string.length; i++) {\n\t\tvar code = string.charCodeAt(i);\n\n\t\tif(code == 0x0) {\n\t\t\tthrow new InvalidCharacterError('Invalid character: the input contains U+0000.');\n\t\t}\n\n\t\tif(between(code, 0x1, 0x1f) || code == 0x7f) {\n\t\t\tresult += '\\\\' + code.toString(16) + ' ';\n\t\t} else if(code == 0x22 || code == 0x5c) {\n\t\t\tresult += '\\\\' + string[i];\n\t\t} else {\n\t\t\tresult += string[i];\n\t\t}\n\t}\n\treturn result;\n}\n\n// Exportation.\ncssSyntax.tokenize = tokenize;\ncssSyntax.IdentToken = IdentifierToken;\ncssSyntax.IdentifierToken = IdentifierToken;\ncssSyntax.FunctionToken = FunctionToken;\ncssSyntax.AtKeywordToken = AtKeywordToken;\ncssSyntax.HashToken = HashToken;\ncssSyntax.StringToken = StringToken;\ncssSyntax.BadStringToken = BadStringToken;\ncssSyntax.URLToken = URLToken;\ncssSyntax.BadURLToken = BadURLToken;\ncssSyntax.DelimToken = DelimToken;\ncssSyntax.NumberToken = NumberToken;\ncssSyntax.PercentageToken = PercentageToken;\ncssSyntax.DimensionToken = DimensionToken;\ncssSyntax.IncludeMatchToken = IncludeMatchToken;\ncssSyntax.DashMatchToken = DashMatchToken;\ncssSyntax.PrefixMatchToken = PrefixMatchToken;\ncssSyntax.SuffixMatchToken = SuffixMatchToken;\ncssSyntax.SubstringMatchToken = SubstringMatchToken;\ncssSyntax.ColumnToken = ColumnToken;\ncssSyntax.WhitespaceToken = WhitespaceToken;\ncssSyntax.CDOToken = CDOToken;\ncssSyntax.CDCToken = CDCToken;\ncssSyntax.ColonToken = ColonToken;\ncssSyntax.SemicolonToken = SemicolonToken;\ncssSyntax.CommaToken = CommaToken;\ncssSyntax.OpenParenToken = OpenParenToken;\ncssSyntax.CloseParenToken = CloseParenToken;\ncssSyntax.OpenSquareToken = OpenSquareToken;\ncssSyntax.CloseSquareToken = CloseSquareToken;\ncssSyntax.OpenCurlyToken = OpenCurlyToken;\ncssSyntax.CloseCurlyToken = CloseCurlyToken;\ncssSyntax.EOFToken = EOFToken;\ncssSyntax.CSSParserToken = CSSParserToken;\ncssSyntax.GroupingToken = GroupingToken;\n\n//\n// css parser\n//\n\nfunction TokenStream(tokens) {\n\t// Assume that tokens is an array.\n\tthis.tokens = tokens;\n\tthis.i = -1;\n}\nTokenStream.prototype.tokenAt = function(i) {\n\tif(i < this.tokens.length)\n\t\treturn this.tokens[i];\n\treturn new EOFToken();\n}\nTokenStream.prototype.consume = function(num) {\n\tif(num === undefined) num = 1;\n\tthis.i += num;\n\tthis.token = this.tokenAt(this.i);\n\t//console.log(this.i, this.token);\n\treturn true;\n}\nTokenStream.prototype.next = function() {\n\treturn this.tokenAt(this.i+1);\n}\nTokenStream.prototype.reconsume = function() {\n\tthis.i--;\n}\n\nfunction parseerror(s, msg) {\n\tconsole.log(\"Parse error at token \" + s.i + \": \" + s.token + \".\\n\" + msg);\n\treturn true;\n}\nfunction donothing(){ return true; };\n\nfunction consumeAListOfRules(s, topLevel) {\n\tvar rules = new TokenList();\n\tvar rule;\n\twhile(s.consume()) {\n\t\tif(s.token instanceof WhitespaceToken) {\n\t\t\tcontinue;\n\t\t} else if(s.token instanceof EOFToken) {\n\t\t\treturn rules;\n\t\t} else if(s.token instanceof CDOToken || s.token instanceof CDCToken) {\n\t\t\tif(topLevel == \"top-level\") continue;\n\t\t\ts.reconsume();\n\t\t\tif(rule = consumeAStyleRule(s)) rules.push(rule);\n\t\t} else if(s.token instanceof AtKeywordToken) {\n\t\t\ts.reconsume();\n\t\t\tif(rule = consumeAnAtRule(s)) rules.push(rule);\n\t\t} else {\n\t\t\ts.reconsume();\n\t\t\tif(rule = consumeAStyleRule(s)) rules.push(rule);\n\t\t}\n\t}\n}\n\nfunction consumeAnAtRule(s) {\n\ts.consume();\n\tvar rule = new AtRule(s.token.value);\n\twhile(s.consume()) {\n\t\tif(s.token instanceof SemicolonToken || s.token instanceof EOFToken) {\n\t\t\treturn rule;\n\t\t} else if(s.token instanceof OpenCurlyToken) {\n\t\t\trule.value = consumeASimpleBlock(s);\n\t\t\treturn rule;\n\t\t} else if(s.token instanceof SimpleBlock && s.token.name == \"{\") {\n\t\t\trule.value = s.token;\n\t\t\treturn rule;\n\t\t} else {\n\t\t\ts.reconsume();\n\t\t\trule.prelude.push(consumeAComponentValue(s));\n\t\t}\n\t}\n}\n\nfunction consumeAStyleRule(s) {\n\tvar rule = new StyleRule();\n\twhile(s.consume()) {\n\t\tif(s.token instanceof EOFToken) {\n\t\t\tparseerror(s, \"Hit EOF when trying to parse the prelude of a qualified rule.\");\n\t\t\treturn;\n\t\t} else if(s.token instanceof OpenCurlyToken) {\n\t\t\trule.value = consumeASimpleBlock(s);\n\t\t\treturn rule;\n\t\t} else if(s.token instanceof SimpleBlock && s.token.name == \"{\") {\n\t\t\trule.value = s.token;\n\t\t\treturn rule;\n\t\t} else {\n\t\t\ts.reconsume();\n\t\t\trule.prelude.push(consumeAComponentValue(s));\n\t\t}\n\t}\n}\n\nfunction consumeAListOfDeclarations(s) {\n\tvar decls = new TokenList();\n\twhile(s.consume()) {\n\t\tif(s.token instanceof WhitespaceToken || s.token instanceof SemicolonToken) {\n\t\t\tdonothing();\n\t\t} else if(s.token instanceof EOFToken) {\n\t\t\treturn decls;\n\t\t} else if(s.token instanceof AtKeywordToken) {\n\t\t\ts.reconsume();\n\t\t\tdecls.push(consumeAnAtRule(s));\n\t\t} else if(s.token instanceof IdentifierToken) {\n\t\t\tvar temp = [s.token];\n\t\t\twhile(!(s.next() instanceof SemicolonToken || s.next() instanceof EOFToken))\n\t\t\t\ttemp.push(consumeAComponentValue(s));\n\t\t\tvar decl;\n\t\t\tif(decl = consumeADeclaration(new TokenStream(temp))) decls.push(decl);\n\t\t} else {\n\t\t\tparseerror(s);\n\t\t\ts.reconsume();\n\t\t\twhile(!(s.next() instanceof SemicolonToken || s.next() instanceof EOFToken))\n\t\t\t\tconsumeAComponentValue(s);\n\t\t}\n\t}\n}\n\nfunction consumeADeclaration(s) {\n\t// Assumes that the next input token will be an ident token.\n\ts.consume();\n\tvar decl = new Declaration(s.token.value);\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\n\tif(!(s.next() instanceof ColonToken)) {\n\t\tparseerror(s);\n\t\treturn;\n\t} else {\n\t\ts.consume();\n\t}\n\twhile(!(s.next() instanceof EOFToken)) {\n\t\tdecl.value.push(consumeAComponentValue(s));\n\t}\n\tvar foundImportant = false;\n\tfor(var i = decl.value.length - 1; i >= 0; i--) {\n\t\tif(decl.value[i] instanceof WhitespaceToken) {\n\t\t\tcontinue;\n\t\t} else if(decl.value[i] instanceof IdentifierToken && decl.value[i].ASCIIMatch(\"important\")) {\n\t\t\tfoundImportant = true;\n\t\t} else if(foundImportant && decl.value[i] instanceof DelimToken && decl.value[i].value == \"!\") {\n\t\t\tdecl.value.splice(i, decl.value.length);\n\t\t\tdecl.important = true;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn decl;\n}\n\nfunction consumeAComponentValue(s) {\n\ts.consume();\n\tif(s.token instanceof OpenCurlyToken || s.token instanceof OpenSquareToken || s.token instanceof OpenParenToken)\n\t\treturn consumeASimpleBlock(s);\n\tif(s.token instanceof FunctionToken)\n\t\treturn consumeAFunction(s);\n\treturn s.token;\n}\n\nfunction consumeASimpleBlock(s) {\n\tvar mirror = s.token.mirror;\n\tvar block = new SimpleBlock(s.token.value);\n\twhile(s.consume()) {\n\t\tif(s.token instanceof EOFToken || (s.token instanceof GroupingToken && s.token.value == mirror))\n\t\t\treturn block;\n\t\telse {\n\t\t\ts.reconsume();\n\t\t\tblock.value.push(consumeAComponentValue(s));\n\t\t}\n\t}\n}\n\nfunction consumeAFunction(s) {\n\tvar func = new Func(s.token.value);\n\twhile(s.consume()) {\n\t\tif(s.token instanceof EOFToken || s.token instanceof CloseParenToken)\n\t\t\treturn func;\n\t\telse {\n\t\t\ts.reconsume();\n\t\t\tfunc.value.push(consumeAComponentValue(s));\n\t\t}\n\t}\n}\n\nfunction normalizeInput(input) {\n\tif(typeof input == \"string\")\n\t\treturn new TokenStream(tokenize(input));\n\tif(input instanceof TokenStream)\n\t\treturn input;\n\tif(input.length !== undefined)\n\t\treturn new TokenStream(input);\n\telse throw SyntaxError(input);\n}\n\nfunction parseAStylesheet(s) {\n\ts = normalizeInput(s);\n\tvar sheet = new Stylesheet();\n\tsheet.value = consumeAListOfRules(s, \"top-level\");\n\treturn sheet;\n}\n\nfunction parseAListOfRules(s) {\n\ts = normalizeInput(s);\n\treturn consumeAListOfRules(s);\n}\n\nfunction parseARule(s) {\n\ts = normalizeInput(s);\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\n\tif(s.next() instanceof EOFToken) throw SyntaxError();\n\tif(s.next() instanceof AtKeywordToken) {\n\t\tvar rule = consumeAnAtRule(s);\n\t} else {\n\t\tvar rule = consumeAStyleRule(s);\n\t\tif(!rule) throw SyntaxError();\n\t}\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\n\tif(s.next() instanceof EOFToken)\n\t\treturn rule;\n\tthrow SyntaxError();\n}\n\nfunction parseADeclaration(s) {\n\ts = normalizeInput(s);\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\n\tif(!(s.next() instanceof IdentifierToken)) throw SyntaxError();\n\tvar decl = consumeADeclaration(s);\n\tif(!decl) { throw new SyntaxError() }\n\treturn decl;\n}\n\nfunction parseAListOfDeclarations(s) {\n\ts = normalizeInput(s);\n\treturn consumeAListOfDeclarations(s);\n}\n\nfunction parseAComponentValue(s) {\n\ts = normalizeInput(s);\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\n\tif(s.next() instanceof EOFToken) throw SyntaxError();\n\tvar val = consumeAComponentValue(s);\n\tif(!val) throw SyntaxError();\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\n\tif(!(s.next() instanceof EOFToken)) throw new SyntaxError();\n\treturn val;\n}\n\nfunction parseAListOfComponentValues(s) {\n\ts = normalizeInput(s);\n\tvar vals = new TokenList();\n\twhile(true) {\n\t\tvar val = consumeAComponentValue(s);\n\t\tif(val instanceof EOFToken)\n\t\t\treturn vals\n\t\telse\n\t\t\tvals.push(val);\n\t}\n}\n\nfunction parseACommaSeparatedListOfComponentValues(s) {\n\ts = normalizeInput(s);\n\tvar listOfCVLs = new TokenList();\n\twhile(true) {\n\t\tvar vals = new TokenList();\n\t\twhile(true) {\n\t\t\tvar val = consumeAComponentValue(s);\n\t\t\tif(val instanceof EOFToken) {\n\t\t\t\tlistOfCVLs.push(vals);\n\t\t\t\treturn listOfCVLs;\n\t\t\t} else if(val instanceof CommaToken) {\n\t\t\t\tlistOfCVLs.push(vals);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tvals.push(val);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction CSSParserRule() { return this; }\nCSSParserRule.prototype.toString = function(indent) {\n\treturn JSON.stringify(this,null,indent);\n}\n\nfunction Stylesheet() {\n\tthis.value = new TokenList();\n\treturn this;\n}\nStylesheet.prototype = new CSSParserRule;\nStylesheet.prototype.type = \"STYLESHEET\";\nStylesheet.prototype.toCSSString = function() { return this.value.toCSSString(\"\\n\"); }\n\nfunction AtRule(name) {\n\tthis.name = name;\n\tthis.prelude = new TokenList();\n\tthis.value = null;\n\treturn this;\n}\nAtRule.prototype = new CSSParserRule;\nAtRule.prototype.toCSSString = function() { \n\tif(this.value) {\n\t\treturn \"@\" + escapeIdent(this.name) + \" \" + this.prelude.toCSSString() + this.value.toCSSString(); \n\t} else {\n\t\treturn \"@\" + escapeIdent(this.name) + \" \" + this.prelude.toCSSString() + '; '; \n\t}\n}\nAtRule.prototype.toStylesheet = function() {\n\treturn this.asStylesheet || (this.asStylesheet = this.value ? parseAStylesheet(this.value.value) : new Stylesheet());\n}\n\nfunction StyleRule() {\n\tthis.prelude = new TokenList(); this.selector = this.prelude;\n\tthis.value = null;\n\treturn this;\n}\nStyleRule.prototype = new CSSParserRule;\nStyleRule.prototype.type = \"STYLE-RULE\";\nStyleRule.prototype.toCSSString = function() {\n\treturn this.prelude.toCSSString() + this.value.toCSSString();\n}\nStyleRule.prototype.getSelector = function() {\n\treturn this.prelude;\n}\nStyleRule.prototype.getDeclarations = function() {\n\tif(!(this.value instanceof SimpleBlock)) { return new TokenList(); }\n\tvar value = this.value.value; return parseAListOfDeclarations(value);\n}\n\n\nfunction Declaration(name) {\n\tthis.name = name;\n\tthis.value = new TokenList();\n\tthis.important = false;\n\treturn this;\n}\nDeclaration.prototype = new CSSParserRule;\nDeclaration.prototype.type = \"DECLARATION\";\nDeclaration.prototype.toCSSString = function() {\n\treturn this.name + ':' + this.value.toCSSString() + '; ';\n}\n\nfunction SimpleBlock(type) {\n\tthis.name = type;\n\tthis.value = new TokenList();\n\treturn this;\n}\nSimpleBlock.prototype = new CSSParserRule;\nSimpleBlock.prototype.type = \"BLOCK\";\nSimpleBlock.prototype.toCSSString = function() {\n\tswitch(this.name) {\n\t\tcase \"(\":\n\t\t\treturn \"(\" + this.value.toCSSString() + \")\";\n\t\t\t\n\t\tcase \"[\":\n\t\t\treturn \"[\" + this.value.toCSSString() + \"]\";\n\t\t\t\n\t\tcase \"{\":\n\t\t\treturn \"{\" + this.value.toCSSString() + \"}\";\n\t\t\n\t\tdefault: //best guess\n\t\t\treturn this.name + this.value.toCSSString() + this.name;\n\t}\n}\n\nfunction Func(name) {\n\tthis.name = name;\n\tthis.value = new TokenList();\n\treturn this;\n}\nFunc.prototype = new CSSParserRule;\nFunc.prototype.type = \"FUNCTION\";\nFunc.prototype.toCSSString = function() {\n\treturn this.name+'('+this.value.toCSSString()+')';\n}\nFunc.prototype.getArguments = function() {\n\tvar args = new TokenList(); var arg = new TokenList(); var value = this.value;\n\tfor(var i = 0; i<value.length; i++) {\n\t\tif(value[i].tokenType == ',') {\n\t\t\targs.push(arg); arg = new TokenList();\n\t\t} else {\n\t\t\targ.push(value[i])\n\t\t}\n\t}\n\tif(args.length > 0 || arg.length > 0) { args.push(arg); }\n\treturn args;\n}\n\nfunction FuncArg() {\n\tthis.value = new TokenList();\n\treturn this;\n}\nFuncArg.prototype = new CSSParserRule;\nFuncArg.prototype.type = \"FUNCTION-ARG\";\nFuncArg.prototype.toCSSString = function() {\n\treturn this.value.toCSSString()+', ';\n}\n\n// Exportation.\ncssSyntax.CSSParserRule = CSSParserRule;\ncssSyntax.Stylesheet = Stylesheet;\ncssSyntax.AtRule = AtRule;\ncssSyntax.StyleRule = StyleRule;\ncssSyntax.Declaration = Declaration;\ncssSyntax.SimpleBlock = SimpleBlock;\ncssSyntax.Func = Func;\ncssSyntax.parseAStylesheet = parseAStylesheet;\ncssSyntax.parseAListOfRules = parseAListOfRules;\ncssSyntax.parseARule = parseARule;\ncssSyntax.parseADeclaration = parseADeclaration;\ncssSyntax.parseAListOfDeclarations = parseAListOfDeclarations;\ncssSyntax.parseAComponentValue = parseAComponentValue;\ncssSyntax.parseAListOfComponentValues = parseAListOfComponentValues;\ncssSyntax.parseACommaSeparatedListOfComponentValues = parseACommaSeparatedListOfComponentValues;\ncssSyntax.parse = parseAStylesheet;\ncssSyntax.parseCSSValue = parseAListOfComponentValues;\n\nreturn cssSyntax;\n\n}());\n\nrequire.define('src/core/css-syntax.js');","void function() {\n\t\n\t// request animation frame\n    var vendors = ['webkit', 'moz', 'ms', 'o'];\n    for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {\n        var vp = vendors[i];\n        window.requestAnimationFrame = window[vp+'RequestAnimationFrame'];\n        window.cancelAnimationFrame = (window[vp+'CancelAnimationFrame'] || window[vp+'CancelRequestAnimationFrame']);\n    }\n    if (!window.requestAnimationFrame || !window.cancelAnimationFrame) {\n\t\t\n\t\t// tick every 16ms\n        var listener_index = 0; var listeners = []; var tmp = []; var tick = function() {\n\t\t\tvar now = +(new Date()); var callbacks = listeners; listeners = tmp;\n\t\t\tfor(var i = 0; i<callbacks.length; i++) { callbacks[i](now); }\n\t\t\tlistener_index += callbacks.length; callbacks.length = 0; tmp = callbacks;\n\t\t\tsetTimeout(tick, 16);\n\t\t}; tick();\n\t\t\n\t\t// add a listener\n        window.requestAnimationFrame = function(callback) {\n            return listener_index + listeners.push(callback);\n        };\n\t\t\n\t\t// remove a listener\n        window.cancelAnimationFrame = function(index) {\n\t\t\tindex -= listener_index; if(index >= 0 && index < listeners.length) {\n\t\t\t\tlisteners[index] = function() {};\n\t\t\t}\n\t\t};\n\t\t\n    }\n\t\n\t// setImmediate\n\tif(!window.setImmediate) {\n\t\twindow.setImmediate = function(f) { return setTimeout(f, 0) };\n\t\twindow.cancelImmediate = clearTimeout;\n\t}\n\t\n}();\n\nrequire.define('src/core/polyfill-dom-requestAnimationFrame.js');","/////////////////////////////////////////////////////////////////\n////                                                         ////\n////                 prerequirements of qSL                  ////\n////                                                         ////\n/////////////////////////////////////////////////////////////////\n////                                                         ////\n////   Please note that I require querySelectorAll to work   ////\n////                                                         ////\n////   See http://github.com/termi/CSS_selector_engine/      ////\n////   for a polyfill for older browsers                     ////\n////                                                         ////\n/////////////////////////////////////////////////////////////////\n\n// TODO: improve event streams\n// - look for a few optimizations ideas in gecko/webkit\n// - use arrays in CompositeEventStream to avoid nested debouncings\nmodule.exports = (function(window, document) { \"use strict\";\n\n\t///\n\t/// event stream implementation\n\t/// please note this is required to 'live update' the qSA requests\n\t///\n\tfunction EventStream(connect, disconnect, reconnect) {\n\t\tvar self=this;\n\t\t\n\t\t// validate arguments\n\t\tif(!disconnect) disconnect=function(){};\n\t\tif(!reconnect) reconnect=connect;\n\t\t\n\t\t// high-level states\n\t\tvar isConnected=false;\n\t\tvar isDisconnected=false;\n\t\tvar shouldDisconnect=false;\n\t\t\n\t\t// global variables\n\t\tvar callback=null;\n\t\tvar yieldEvent = function() {\n\t\t\t\n\t\t\t// call the callback function, and pend disposal\n\t\t\tshouldDisconnect=true;\n\t\t\ttry { callback && callback(self); } catch(ex) { setImmediate(function() { throw ex; }); }\n\t\t\t\n\t\t\t// if no action was taken, dispose\n\t\t\tif(shouldDisconnect) { dispose(); }\n\t\t\t\n\t\t}\n\t\t\n\t\t// export the interface\n\t\tvar schedule = this.schedule = function(newCallback) {\n\t\t\n\t\t\t// do not allow to schedule on disconnected event streams\n\t\t\tif(isDisconnected) { throw new Error(\"Cannot schedule on a disconnected event stream\"); }\n\t\t\t\n\t\t\t// do not allow to schedule on already scheduled event streams\n\t\t\tif(isConnected && !shouldDisconnect) { throw new Error(\"Cannot schedule on an already-scheduled event stream\"); }\n\t\t\t\n\t\t\t// schedule the new callback\n\t\t\tcallback=newCallback; shouldDisconnect=false;\n\t\t\t\n\t\t\t// reconnect to the stream\n\t\t\tif(isConnected) {\n\t\t\t\treconnect(yieldEvent);\n\t\t\t} else {\n\t\t\t\tconnect(yieldEvent);\n\t\t\t\tisConnected=true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar dispose = this.dispose = function() {\n\t\t\n\t\t\t// do not allow to dispose non-connected streams\n\t\t\tif(isConnected) {\n\t\t\t\n\t\t\t\t// disconnect & save resources\n\t\t\t\tdisconnect(); \n\t\t\t\tself=null; yieldEvent=null; callback=null; \n\t\t\t\tisConnected=false; isDisconnected=true; shouldDisconnect=false;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\n\t///\n\t/// call a function every frame\n\t///\n\tfunction AnimationFrameEventStream(options) {\n\t\t\n\t\t// flag that says whether the observer is still needed or not\n\t\tvar rid = 0;\n\t\t\t\n\t\t// start the event stream\n\t\tEventStream.call(\n\t\t\tthis, \n\t\t\tfunction connect(yieldEvent) { rid = requestAnimationFrame(yieldEvent); },\n\t\t\tfunction disconnect() { cancelAnimationFrame(rid); }\n\t\t);\n\t\t\n\t}\n\n\t///\n\t/// call a function every timeout\n\t///\n\tfunction TimeoutEventStream(options) {\n\t\t\n\t\t// flag that says whether the observer is still needed or not\n\t\tvar rid = 0; var timeout=(typeof(options)==\"number\") ? (+options) : (\"timeout\" in options ? +options.timeout : 333);\n\t\t\t\n\t\t// start the event stream\n\t\tEventStream.call(\n\t\t\tthis, \n\t\t\tfunction connect(yieldEvent) { rid = setTimeout(yieldEvent, timeout); },\n\t\t\tfunction disconnect() { clearTimeout(rid); }\n\t\t);\n\t\t\n\t}\n\n\t///\n\t/// call a function every time the mouse moves\n\t///\n\tfunction MouseEventStream() {\n\t\tvar self=this; var pointermove = ((\"PointerEvent\" in window) ? \"pointermove\" : ((\"MSPointerEvent\" in window) ? \"MSPointerMove\" : \"mousemove\"));\n\n\t\t// flag that says whether the event is still observed or not\n\t\tvar scheduled = false; var interval=0;\n\t\t\n\t\t// handle the synchronous nature of mutation events\n\t\tvar yieldEvent=null;\n\t\tvar yieldEventDelayed = function() {\n\t\t\tif(scheduled) return;\n\t\t\twindow.removeEventListener(pointermove, yieldEventDelayed, true);\n\t\t\tscheduled = requestAnimationFrame(yieldEvent);\n\t\t}\n\t\t\n\t\t// start the event stream\n\t\tEventStream.call(\n\t\t\tthis, \n\t\t\tfunction connect(newYieldEvent) {\n\t\t\t\tyieldEvent=newYieldEvent;\n\t\t\t\twindow.addEventListener(pointermove, yieldEventDelayed, true);\n\t\t\t},\n\t\t\tfunction disconnect() { \n\t\t\t\twindow.removeEventListener(pointermove, yieldEventDelayed, true);\n\t\t\t\tcancelAnimationFrame(scheduled); yieldEventDelayed=null; yieldEvent=null; scheduled=false;\n\t\t\t},\n\t\t\tfunction reconnect(newYieldEvent) { \n\t\t\t\tyieldEvent=newYieldEvent; scheduled=false;\n\t\t\t\twindow.addEventListener(pointermove, yieldEventDelayed, true);\n\t\t\t}\n\t\t);\n\t\t\n\t}\n\n\t///\n\t/// call a function every time the mouse is clicked/unclicked\n\t///\n\tfunction MouseButtonEventStream() {\n\t\tvar self=this; \n\t\tvar pointerup = ((\"PointerEvent\" in window) ? \"pointerup\" : ((\"MSPointerEvent\" in window) ? \"MSPointerUp\" : \"mouseup\"));\n\t\tvar pointerdown = ((\"PointerEvent\" in window) ? \"pointerdown\" : ((\"MSPointerEvent\" in window) ? \"MSPointerDown\" : \"mousedown\"));\n\n\t\t// flag that says whether the event is still observed or not\n\t\tvar scheduled = false; var interval=0;\n\t\t\n\t\t// handle the synchronous nature of mutation events\n\t\tvar yieldEvent=null;\n\t\tvar yieldEventDelayed = function() {\n\t\t\tif(scheduled) return;\n\t\t\twindow.removeEventListener(pointerup, yieldEventDelayed, true);\n\t\t\twindow.removeEventListener(pointerdown, yieldEventDelayed, true);\n\t\t\tscheduled = requestAnimationFrame(yieldEvent);\n\t\t}\n\t\t\n\t\t// start the event stream\n\t\tEventStream.call(\n\t\t\tthis, \n\t\t\tfunction connect(newYieldEvent) {\n\t\t\t\tyieldEvent=newYieldEvent;\n\t\t\t\twindow.addEventListener(pointerup, yieldEventDelayed, true);\n\t\t\t\twindow.addEventListener(pointerdown, yieldEventDelayed, true);\n\t\t\t},\n\t\t\tfunction disconnect() { \n\t\t\t\twindow.removeEventListener(pointerup, yieldEventDelayed, true);\n\t\t\t\twindow.removeEventListener(pointerdown, yieldEventDelayed, true);\n\t\t\t\tcancelAnimationFrame(scheduled); yieldEventDelayed=null; yieldEvent=null; scheduled=false;\n\t\t\t},\n\t\t\tfunction reconnect(newYieldEvent) { \n\t\t\t\tyieldEvent=newYieldEvent; scheduled=false;\n\t\t\t\twindow.addEventListener(pointerup, yieldEventDelayed, true);\n\t\t\t\twindow.addEventListener(pointerdown, yieldEventDelayed, true);\n\t\t\t}\n\t\t);\n\t\t\n\t}\n\n\t///\n\t/// call a function whenever the DOM is modified\n\t///\n\tvar DOMUpdateEventStream;\n\tif(\"MutationObserver\" in window) {\n\t\tDOMUpdateEventStream = function DOMUpdateEventStream(options) {\n\t\t\t \n\t\t\t// configuration of the observer\n\t\t\tif(options) {\n\t\t\t\tvar target = \"target\" in options ? options.target : document.documentElement;\n\t\t\t\tvar config = { \n\t\t\t\t\tsubtree: \"subtree\" in options ? !!options.subtree : true, \n\t\t\t\t\tattributes: \"attributes\" in options ? !!options.attributes : true, \n\t\t\t\t\tchildList: \"childList\" in options ? !!options.childList : true, \n\t\t\t\t\tcharacterData: \"characterData\" in options ? !!options.characterData : false\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tvar target = document.documentElement;\n\t\t\t\tvar config = { \n\t\t\t\t\tsubtree: true, \n\t\t\t\t\tattributes: true, \n\t\t\t\t\tchildList: true, \n\t\t\t\t\tcharacterData: false\n\t\t\t\t};\n\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t// start the event stream\n\t\t\tvar observer = null;\n\t\t\tEventStream.call(\n\t\t\t\tthis, \n\t\t\t\tfunction connect(yieldEvent) { if(config) { observer=new MutationObserver(yieldEvent); observer.observe(target,config); target=null; config=null; } },\n\t\t\t\tfunction disconnect() { observer && observer.disconnect(); observer=null; },\n\t\t\t\tfunction reconnect() { observer.takeRecords(); }\n\t\t\t);\n\n\t\t}\n\t} else if(\"MutationEvent\" in window) {\n\t\tDOMUpdateEventStream = function DOMUpdateEventStream(options) {\n\t\t\tvar self=this;\n\n\t\t\t// flag that says whether the event is still observed or not\n\t\t\tvar scheduled = false;\n\t\t\t\n\t\t\t// configuration of the observer\n\t\t\tif(options) {\n\t\t\t\tvar target = \"target\" in options ? options.target : document.documentElement;\n\t\t\t} else {\n\t\t\t\tvar target = document.documentElement;\n\t\t\t}\n\t\t\t\n\t\t\t// handle the synchronous nature of mutation events\n\t\t\tvar yieldEvent=null;\n\t\t\tvar yieldEventDelayed = function() {\n\t\t\t\tif(scheduled || !yieldEventDelayed) return;\n\t\t\t\tdocument.removeEventListener(\"DOMContentLoaded\", yieldEventDelayed, false);\n\t\t\t\tdocument.removeEventListener(\"DOMContentLoaded\", yieldEventDelayed, false);\n\t\t\t\ttarget.removeEventListener(\"DOMSubtreeModified\", yieldEventDelayed, false);\n\t\t\t\tscheduled = requestAnimationFrame(yieldEvent);\n\t\t\t}\n\t\t\t\n\t\t\t// start the event stream\n\t\t\tEventStream.call(\n\t\t\t\tthis, \n\t\t\t\tfunction connect(newYieldEvent) {\n\t\t\t\t\tyieldEvent=newYieldEvent;\n\t\t\t\t\tdocument.addEventListener(\"DOMContentLoaded\", yieldEventDelayed, false);\n\t\t\t\t\ttarget.addEventListener(\"DOMSubtreeModified\", yieldEventDelayed, false);\n\t\t\t\t},\n\t\t\t\tfunction disconnect() { \n\t\t\t\t\tdocument.removeEventListener(\"DOMContentLoaded\", yieldEventDelayed, false);\n\t\t\t\t\ttarget.removeEventListener(\"DOMSubtreeModified\", yieldEventDelayed, false);\n\t\t\t\t\tcancelAnimationFrame(scheduled); yieldEventDelayed=null; yieldEvent=null; scheduled=false;\n\t\t\t\t},\n\t\t\t\tfunction reconnect(newYieldEvent) { \n\t\t\t\t\tyieldEvent=newYieldEvent; scheduled=false;\n\t\t\t\t\ttarget.addEventListener(\"DOMSubtreeModified\", yieldEventDelayed, false);\n\t\t\t\t}\n\t\t\t);\n\t\t\t\n\t\t}\n\t} else {\n\t\tDOMUpdateEventStream = AnimationFrameEventStream;\n\t}\n\n\t///\n\t/// call a function every time the focus shifts\n\t///\n\tfunction FocusEventStream() {\n\t\tvar self=this;\n\t\t\n\t\t// handle the filtering nature of focus events\n\t\tvar yieldEvent=null; var previousActiveElement=null; var previousHasFocus=false; var rid=0;\n\t\tvar yieldEventDelayed = function() {\n\t\t\t\n\t\t\t// if the focus didn't change\n\t\t\tif(previousActiveElement==document.activeElement && previousHasFocus==document.hasFocus()) {\n\t\t\t\t\n\t\t\t\t// then do not generate an event\n\t\t\t\tsetTimeout(yieldEventDelayed, 333); // focus that didn't move is expected to stay\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t// else, generate one & save config\n\t\t\t\tpreviousActiveElement=document.activeElement;\n\t\t\t\tpreviousHasFocus=document.hasFocus();\n\t\t\t\tyieldEvent();\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t// start the event stream\n\t\tEventStream.call(\n\t\t\tthis, \n\t\t\tfunction connect(newYieldEvent) {\n\t\t\t\tyieldEvent=newYieldEvent;\n\t\t\t\trid=setTimeout(yieldEventDelayed, 500); // let the document load\n\t\t\t},\n\t\t\tfunction disconnect() { \n\t\t\t\tclearTimeout(rid); yieldEventDelayed=null; yieldEvent=null; rid=0;\n\t\t\t},\n\t\t\tfunction reconnect(newYieldEvent) { \n\t\t\t\tyieldEvent=newYieldEvent;\n\t\t\t\trid=setTimeout(yieldEventDelayed, 100); // focus by tab navigation moves fast\n\t\t\t}\n\t\t);\n\t\t\n\t}\n\n\t///\n\t/// composite event stream\n\t/// because sometimes you need more than one event source\n\t///\n\tfunction CompositeEventStream(stream1, stream2) {\n\t\tvar self=this;\n\t\t\n\t\t// fields\n\t\tvar yieldEvent=null; var s1=false, s2=false;\n\t\tvar yieldEventWrapper=function(s) { \n\t\t\tif(s==stream1) s1=true;\n\t\t\tif(s==stream2) s2=true;\n\t\t\tif(s1&&s2) return;\n\t\t\tyieldEvent(self);\n\t\t}\n\t\t\n\t\t// start the event stream\n\t\tEventStream.call(\n\t\t\tthis, \n\t\t\tfunction connect(newYieldEvent) {\n\t\t\t\tyieldEvent=newYieldEvent;\n\t\t\t\tstream1.schedule(yieldEventWrapper);\n\t\t\t\tstream2.schedule(yieldEventWrapper);\n\t\t\t},\n\t\t\tfunction disconnect() { \n\t\t\t\tstream1.dispose();\n\t\t\t\tstream2.dispose();\n\t\t\t},\n\t\t\tfunction reconnect(newYieldEvent) { \n\t\t\t\tyieldEvent=newYieldEvent;\n\t\t\t\ts1 && stream1.schedule(yieldEventWrapper);\n\t\t\t\ts2 && stream2.schedule(yieldEventWrapper);\n\t\t\t\ts1 = s2 = false;\n\t\t\t}\n\t\t);\n\t}\n\t\n\treturn {\n\t\tEventStream:                EventStream,\n\t\tAnimationFrameEventStream:  AnimationFrameEventStream,\n\t\tTimeoutEventStream:         TimeoutEventStream,\n\t\tMouseEventStream:           MouseEventStream,\n\t\tMouseButtonEventStream:     MouseButtonEventStream,\n\t\tDOMUpdateEventStream:       DOMUpdateEventStream,\n\t\tFocusEventStream:           FocusEventStream,\n\t\tCompositeEventStream:       CompositeEventStream\n\t};\n\n})(window, document);\nrequire.define('src/core/dom-experimental-event-streams.js');","/////////////////////////////////////////////////////////////////\n////                                                         ////\n////                  Implementation of qSL                  ////\n////                                                         ////\n/////////////////////////////////////////////////////////////////\n////                                                         ////\n////   Please note that I require querySelectorAll to work   ////\n////                                                         ////\n////   See http://github.com/termi/CSS_selector_engine/      ////\n////   for a polyfill for older browsers                     ////\n////                                                         ////\n/////////////////////////////////////////////////////////////////\n\nmodule.exports = (function(window, document) { \"use strict\";\n\n\t// import dependencies\n\tvar eventStreams = require('src/core/dom-experimental-event-streams.js'),\n\t    DOMUpdateEventStream = eventStreams.DOMUpdateEventStream,\n\t\tAnimationFrameEventStream = eventStreams.AnimationFrameEventStream,\n\t\tCompositeEventStream = eventStreams.CompositeEventStream,\n\t\tFocusEventStream = eventStreams.FocusEventStream,\n\t\tMouseButtonEventStream = eventStreams.MouseButtonEventStream,\n\t\tTimeoutEventStream = eventStreams.TimeoutEventStream,\n\t\tMouseEventStream = eventStreams.MouseEventStream;\n\n\t///\n\t/// the live querySelectorAll implementation\n\t///\n\tfunction querySelectorLive(selector, handler, root) {\n\t\t\n\t\t// restrict the selector coverage to some part of the DOM only\n\t\tvar root = root || document;\n\t\t\n\t\t// TODO: make use of \"mutatedAncestorElement\" to update only elements inside the mutated zone\n\t\t\n\t\tvar currentElms = [];\n\t\tvar loop = function loop(eventStream) {\n\t\t\t\n\t\t\t// schedule next run\n\t\t\teventStream.schedule(loop);\n\t\t\t\n\t\t\t// update elements matching the selector\n\t\t\tvar newElms = [];\n\t\t\tvar oldElms = currentElms.slice(0);\n\t\t\tvar temps = root.querySelectorAll(selector);\n\t\t\tfor(var i=newElms.length=temps.length; i;) { newElms.push(temps[--i]); }\n\t\t\tcurrentElms = newElms.slice(0); temps=null;\n\t\t\t\n\t\t\t// first let's clear all elements that have been removed from the document\n\t\t\toldElms = oldElms.filter(function(e) {\n\t\t\t\t\n\t\t\t\t// check whether the current element is still there\n\t\t\t\tvar isStillInDocument = (\n\t\t\t\t\te===document.documentElement \n\t\t\t\t\t|| document.documentElement.contains(e)\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\tif(isStillInDocument) {\n\t\t\t\t\t\n\t\t\t\t\t// NEED_COMPARE: we will compare this element to the new list\n\t\t\t\t\treturn true;\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\t// DELETE: raise onremoved, pop old elements\n\t\t\t\t\ttry { handler.onremoved && handler.onremoved(e); } catch(ex) { setImmediate(function() {throw ex})}\n\t\t\t\t\treturn false;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t\t// now pop and match until both lists are exhausted\n\t\t\t// (we use the fact the returned elements are in document order)\n\t\t\tvar el1 = oldElms.pop();\n\t\t\tvar el2 = newElms.pop();\n\t\t\twhile(el1 || el2) {\n\t\t\t\tif(el1===el2) {\n\t\t\t\t\n\t\t\t\t\t// MATCH: pop both elements\n\t\t\t\t\tel1 = oldElms.pop();\n\t\t\t\t\tel2 = newElms.pop();\n\t\t\t\t\t\n\t\t\t\t} else if (el2 && /*el1 is after el2*/(!el1||(el2.compareDocumentPosition(el1) & (1|2|8|32))===0)) {\n\t\t\t\t\t\n\t\t\t\t\t// INSERT: raise onadded, pop new elements\n\t\t\t\t\ttry { handler.onadded && handler.onadded(el2); } catch(ex) { setImmediate(function() {throw ex})}\n\t\t\t\t\tel2 = newElms.pop();\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\n\t\t\t\t\t// DELETE: raise onremoved, pop old elements\n\t\t\t\t\ttry { handler.onremoved && handler.onremoved(el1); } catch(ex) { setImmediate(function() {throw ex})}\n\t\t\t\t\tel1 = oldElms.pop();\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t};\n\t\t\n\t\t// use the event stream that best matches our needs\n\t\tvar simpleSelector = selector.replace(/:(dir|lang|root|empty|blank|nth-child|nth-last-child|first-child|last-child|only-child|nth-of-type|nth-last-of-child|fist-of-type|last-of-type|only-of-type|not|matches|default)\\b/gi,'')\n\t\tvar eventStream; if(simpleSelector.indexOf(':') == -1) {\n\t\t\t\n\t\t\t// static stuff only\n\t\t\teventStream = new DOMUpdateEventStream({target:root}); \n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\t// dynamic stuff too\n\t\t\teventStream = new DOMUpdateEventStream({target:root}); \n\t\t\tif(DOMUpdateEventStream != AnimationFrameEventStream) {\n\t\t\t\n\t\t\t\t// detect the presence of focus-related pseudo-classes\n\t\t\t\tvar reg = /:(focus|active)\\b/gi;\n\t\t\t\tif(reg.test(simpleSelector)) {\n\t\t\t\t\t\n\t\t\t\t\t// mouse events should be listened\n\t\t\t\t\teventStream = new CompositeEventStream(\n\t\t\t\t\t\tnew FocusEventStream(),\n\t\t\t\t\t\teventStream\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\t// simplify simpleSelector\n\t\t\t\t\tvar reg = /:(focus)\\b/gi;\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, ''); // :active has other hooks\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// detect the presence of mouse-button-related pseudo-classes\n\t\t\t\tvar reg = /:(active)\\b/gi;\n\t\t\t\tif(reg.test(simpleSelector)) {\n\t\t\t\t\t\n\t\t\t\t\t// mouse events should be listened\n\t\t\t\t\teventStream = new CompositeEventStream(\n\t\t\t\t\t\tnew MouseButtonEventStream(),\n\t\t\t\t\t\teventStream\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\t// simplify simpleSelector\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\t// detect the presence of user input pseudo-classes\n\t\t\t\tvar reg = /:(target|checked|indeterminate|valid|invalid|in-range|out-of-range|user-error)\\b/gi;\n\t\t\t\tif(reg.test(simpleSelector)) {\n\t\t\t\t\t\n\t\t\t\t\t// slowly dynamic stuff do happen\n\t\t\t\t\teventStream = new CompositeEventStream(\n\t\t\t\t\t\tnew TimeoutEventStream(250),\n\t\t\t\t\t\teventStream\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\t// simplify simpleSelector\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\n\n\t\t\t\t\tvar reg = /:(any-link|link|visited|local-link|enabled|disabled|read-only|read-write|required|optional)\\b/gi;\n\t\t\t\t\t// simplify simpleSelector\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// detect the presence of nearly-static pseudo-classes\n\t\t\t\tvar reg = /:(any-link|link|visited|local-link|enabled|disabled|read-only|read-write|required|optional)\\b/gi;\n\t\t\t\tif(reg.test(simpleSelector)) {\n\t\t\t\t\t\n\t\t\t\t\t// nearly static stuff do happen\n\t\t\t\t\teventStream = new CompositeEventStream(\n\t\t\t\t\t\tnew TimeoutEventStream(333),\n\t\t\t\t\t\teventStream\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\t// simplify simpleSelector\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// detect the presence of mouse-related pseudo-classes\n\t\t\t\tvar reg = /:(hover)\\b/gi;\n\t\t\t\tif(reg.test(simpleSelector)) {\n\t\t\t\t\t\n\t\t\t\t\t// mouse events should be listened\n\t\t\t\t\teventStream = new CompositeEventStream(\n\t\t\t\t\t\tnew MouseEventStream(),\n\t\t\t\t\t\teventStream\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\t// simplify simpleSelector\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// detect the presence of unknown pseudo-classes\n\t\t\t\tif(simpleSelector.indexOf(':') !== -1) {\n\t\t\t\t\t\n\t\t\t\t\t// other stuff do happen, too (let's give up on events)\n\t\t\t\t\teventStream = new AnimationFrameEventStream(); \n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t// start handling changes\n\t\tloop(eventStream);\n\t\t\n\t}\n\t\n\treturn querySelectorLive;\n\t\n})(window, document);\nrequire.define('src/core/dom-query-selector-live.js');","// TODO: comment about the 'no_auto_stylesheet_detection' flag?\n\nmodule.exports = (function(window, document) { \"use strict\";\n\t\n\t// import dependencies\n\trequire('src/core/polyfill-dom-console.js');\n\trequire('src/core/polyfill-dom-requestAnimationFrame.js');\n\tvar cssSyntax = require('src/core/css-syntax.js');\n\tvar domEvents = require('src/core/dom-events.js');\n\tvar querySelectorLive = require('src/core/dom-query-selector-live.js');\n\t\n\t// define the module\n\tvar cssCascade = {\n\t\t\n\t\t//\n\t\t// returns the priority of a unique selector (NO COMMA!)\n\t\t// { the return value is an integer, with the same formula as webkit }\n\t\t//\n\t\tcomputeSelectorPriorityOf: function computeSelectorPriorityOf(selector) {\n\t\t\tif(typeof selector == \"string\") selector = cssSyntax.parse(selector.trim()+\"{}\").value[0].selector;\n\t\t\t\n\t\t\tvar numberOfIDs = 0;\n\t\t\tvar numberOfClasses = 0;\n\t\t\tvar numberOfTags = 0;\n\t\t\t\n\t\t\t// TODO: improve this parser, or find one on the web\n\t\t\tfor(var i = 0; i < selector.length; i++) {\n\t\t\t\t\n\t\t\t\tif(selector[i] instanceof cssSyntax.IdentifierToken) {\n\t\t\t\t\tnumberOfTags++;\n\t\t\t\t\t\n\t\t\t\t} else if(selector[i] instanceof cssSyntax.DelimToken) {\n\t\t\t\t\tif(selector[i].value==\".\") {\n\t\t\t\t\t\tnumberOfClasses++; i++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else if(selector[i] instanceof cssSyntax.ColonToken) {\n\t\t\t\t\tif(selector[++i] instanceof cssSyntax.ColonToken) {\n\t\t\t\t\t\tnumberOfTags++; i++;\n\t\t\t\t\t\t\n\t\t\t\t\t} else if((selector[i] instanceof cssSyntax.Func) && (/^(not|matches)$/i).test(selector[i].name)) {\n\t\t\t\t\t\tvar nestedPriority = this.computeSelectorPriorityOf(selector[i].value);\n\t\t\t\t\t\tnumberOfTags += nestedPriority % 256; nestedPriority /= 256;\n\t\t\t\t\t\tnumberOfClasses += nestedPriority % 256; nestedPriority /= 256;\n\t\t\t\t\t\tnumberOfIDs += nestedPriority;\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnumberOfClasses++;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else if(selector[i] instanceof cssSyntax.SimpleBlock) {\n\t\t\t\t\tif(selector[i].name==\"[\") {\n\t\t\t\t\t\tnumberOfClasses++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else if(selector[i] instanceof cssSyntax.HashToken) {\n\t\t\t\t\tnumberOfIDs++;\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t// TODO: stop ignoring unknown symbols?\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(numberOfIDs>255) numberOfIDs=255;\n\t\t\tif(numberOfClasses>255) numberOfClasses=255;\n\t\t\tif(numberOfTags>255) numberOfTags=255;\n\t\t\t\n\t\t\treturn ((numberOfIDs*256)+numberOfClasses)*256+numberOfTags;\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// returns an array of the css rules matching an element\n\t\t//\n\t\tfindAllMatchingRules: function findAllMatchingRules(element) {\n\t\t\treturn this.findAllMatchingRulesWithPseudo(element);\n\t\t},\n\t\t\n\t\t//\n\t\t// returns an array of the css rules matching a pseudo-element\n\t\t//\n\t\tfindAllMatchingRulesWithPseudo: function findAllMatchingRules(element,pseudo) {\n\t\t\tpseudo = pseudo ? (''+pseudo).toLowerCase() : pseudo;\n\t\t\t\n\t\t\t// let's look for new results if needed...\n\t\t\tvar results = [];\n\t\t\t\n\t\t\t// walk the whole stylesheet...\n\t\t\tvar visit = function(rules) {\n\t\t\t\ttry {\n\t\t\t\t\tfor(var r = rules.length; r--; ) {\n\t\t\t\t\t\tvar rule = rules[r]; \n\t\t\t\t\t\t\n\t\t\t\t\t\t// media queries hook\n\t\t\t\t\t\tif(rule.disabled) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(rule instanceof cssSyntax.StyleRule) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// consider each selector independently\n\t\t\t\t\t\t\tvar subrules = rule.subRules || cssCascade.splitRule(rule);\n\t\t\t\t\t\t\tfor(var sr = subrules.length; sr--; ) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tvar selector = subrules[sr].selector.toCSSString().replace(/ *(\\/\\*\\*\\/|  ) */g,' ').trim();\n\t\t\t\t\t\t\t\tif(pseudo) {\n\t\t\t\t\t\t\t\t\t// WE ONLY ACCEPT SELECTORS ENDING WITH THE PSEUDO\n\t\t\t\t\t\t\t\t\tvar selectorLow = selector.toLowerCase();\n\t\t\t\t\t\t\t\t\tvar newLength = selector.length-pseudo.length-1;\n\t\t\t\t\t\t\t\t\tif(newLength<=0) continue;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(selectorLow.lastIndexOf('::'+pseudo)==newLength-1) {\n\t\t\t\t\t\t\t\t\t\tselector = selector.substr(0,newLength-1);\n\t\t\t\t\t\t\t\t\t} else if(selectorLow.lastIndexOf(':'+pseudo)==newLength) {\n\t\t\t\t\t\t\t\t\t\tselector = selector.substr(0,newLength);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t// fix selectors like \"#element > :first-child ~ ::before\"\n\t\t\t\t\t\t\t\t\tif(selector.trim().length == 0) { selector = '*' }\n\t\t\t\t\t\t\t\t\telse if(selector[selector.length-1] == ' ') { selector += '*' }\n\t\t\t\t\t\t\t\t\telse if(selector[selector.length-1] == '+') { selector += '*' }\n\t\t\t\t\t\t\t\t\telse if(selector[selector.length-1] == '>') { selector += '*' }\n\t\t\t\t\t\t\t\t\telse if(selector[selector.length-1] == '~') { selector += '*' }\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// look if the selector matches\n\t\t\t\t\t\t\t\tvar isMatching = false;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tif(element.matches) isMatching=element.matches(selector)\n\t\t\t\t\t\t\t\t\telse if(element.matchesSelector) isMatching=element.matchesSelector(selector)\n\t\t\t\t\t\t\t\t\telse if(element.oMatchesSelector) isMatching=element.oMatchesSelector(selector)\n\t\t\t\t\t\t\t\t\telse if(element.msMatchesSelector) isMatching=element.msMatchesSelector(selector)\n\t\t\t\t\t\t\t\t\telse if(element.mozMatchesSelector) isMatching=element.mozMatchesSelector(selector)\n\t\t\t\t\t\t\t\t\telse if(element.webkitMatchesSelector) isMatching=element.webkitMatchesSelector(selector)\n\t\t\t\t\t\t\t\t\telse { throw new Error(\"no element.matches?\") }\n\t\t\t\t\t\t\t\t} catch(ex) { debugger; setImmediate(function() { throw ex; }) }\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// if yes, add it to the list of matched selectors\n\t\t\t\t\t\t\t\tif(isMatching) { results.push(subrules[sr]); }\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else if(rule instanceof cssSyntax.AtRule && rule.name==\"media\") {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// visit them\n\t\t\t\t\t\t\tvisit(rule.toStylesheet().value);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tsetImmediate(function() { throw ex; });\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(var s=cssCascade.stylesheets.length; s--; ) {\n\t\t\t\tvar rules = cssCascade.stylesheets[s];\n\t\t\t\tvisit(rules);\n\t\t\t}\n\t\t\t\n\t\t\treturn results;\n\t\t},\n\t\t\n\t\t//\n\t\t// a list of all properties supported by the current browser\n\t\t//\n\t\tallCSSProperties: null,\n\t\tgetAllCSSProperties: function getAllCSSProperties() {\n\t\t\t\n\t\t\tif(this.allCSSProperties) return this.allCSSProperties;\n\t\t\t\n\t\t\t// get all claimed properties\n\t\t\tvar s = getComputedStyle(document.documentElement); var ps = new Array(s.length);\n\t\t\tfor(var i=s.length; i--; ) {\n\t\t\t\tps[i] = s[i];\n\t\t\t}\n\t\t\t\n\t\t\t// FIX A BUG WHERE WEBKIT DOESN'T REPORT ALL PROPERTIES\n\t\t\tif(ps.indexOf('content')==-1) {ps.push('content');}\n\t\t\tif(ps.indexOf('counter-reset')==-1) {\n\t\t\t\t\n\t\t\t\tps.push('counter-reset');\n\t\t\t\tps.push('counter-increment');\n\t\t\t\t\n\t\t\t\t// FIX A BUG WHERE WEBKIT RETURNS SHIT FOR THE COMPUTED VALUE OF COUNTER-RESET\n\t\t\t\tcssCascade.computationUnsafeProperties['counter-reset']=true;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// save in a cache for faster access the next times\n\t\t\treturn this.allCSSProperties = ps;\n\t\t\t\n\t\t},\n\t\t\n\t\t// \n\t\t// those properties are not safe for computation->specified round-tripping\n\t\t// \n\t\tcomputationUnsafeProperties: {\n\t\t\t\"block-size\"      : true,\n\t\t\t\"bottom\"          : true,\n\t\t\t\"direction\"       : true,\n\t\t\t\"display\"         : true,\n\t\t\t\"font-size\"       : true,\n\t\t\t\"height\"          : true,\n\t\t\t\"inline-size\"     : true,\n\t\t\t\"left\"            : true,\n\t\t\t\"line-height\"     : true,\n\t\t\t\"margin-left\"     : true,\n\t\t\t\"margin-right\"    : true,\n\t\t\t\"margin-bottom\"   : true,\n\t\t\t\"margin-top\"      : true,\n\t\t\t\"max-height\"      : true,\n\t\t\t\"max-width\"       : true,\n\t\t\t\"min-height\"      : true,\n\t\t\t\"min-width\"       : true,\n\t\t\t\"padding-left\"    : true,\n\t\t\t\"padding-right\"   : true,\n\t\t\t\"padding-bottom\"  : true,\n\t\t\t\"padding-top\"     : true,\n\t\t\t\"right\"           : true,\n\t\t\t\"text-align\"      : true,\n\t\t\t\"text-align-last\" : true,\n\t\t\t\"top\"             : true,\n\t\t\t\"width\"           : true,\n\t\t\t__proto__         : null,\n\t\t},\n\t\t\n\t\t//\n\t\t// a list of property we should inherit...\n\t\t//\n\t\tinheritingProperties: {\n\t\t\t\"border-collapse\"       : true,\n\t\t\t\"border-spacing\"        : true,\n\t\t\t\"caption-side\"          : true,\n\t\t\t\"color\"                 : true,\n\t\t\t\"cursor\"                : true,\n\t\t\t\"direction\"             : true,\n\t\t\t\"empty-cells\"           : true,\n\t\t\t\"font-family\"           : true,\n\t\t\t\"font-size\"             : true,\n\t\t\t\"font-style\"            : true,\n\t\t\t\"font-variant\"          : true,\n\t\t\t\"font-weight\"           : true,\n\t\t\t\"font\"                  : true,\n\t\t\t\"letter-spacing\"        : true,\n\t\t\t\"line-height\"           : true,\n\t\t\t\"list-style-image\"      : true,\n\t\t\t\"list-style-position\"   : true,\n\t\t\t\"list-style-type\"       : true,\n\t\t\t\"list-style\"            : true,\n\t\t\t\"orphans\"               : true,\n\t\t\t\"quotes\"                : true,\n\t\t\t\"text-align\"            : true,\n\t\t\t\"text-indent\"           : true,\n\t\t\t\"text-transform\"        : true,\n\t\t\t\"visibility\"            : true,\n\t\t\t\"white-space\"           : true,\n\t\t\t\"widows\"                : true,\n\t\t\t\"word-break\"            : true,\n\t\t\t\"word-spacing\"          : true,\n\t\t\t\"word-wrap\"             : true,\n\t\t\t__proto__               : null,\n\t\t},\n\t\t\n\t\t//\n\t\t// returns the default style for a tag\n\t\t//\n\t\tdefaultStylesForTag: Object.create ? Object.create(null) : {},\n\t\tgetDefaultStyleForTag: function getDefaultStyleForTag(tagName) {\n\t\t\t\n\t\t\t// get result from cache\n\t\t\tvar result = this.defaultStylesForTag[tagName];\n\t\t\tif(result) return result;\n\t\t\t\n\t\t\t// create dummy virtual element\n\t\t\tvar element = document.createElement(tagName);\n\t\t\tvar style = this.defaultStylesForTag[tagName] = getComputedStyle(element);\n\t\t\tif(style.display) return style;\n\t\t\t\n\t\t\t// webkit fix: insert the dummy element anywhere (head -> display:none)\n\t\t\tdocument.head.insertBefore(element, document.head.firstChild);\n\t\t\treturn style;\n\t\t},\n\t\t\n\t\t// \n\t\t// returns the specified style of an element. \n\t\t// REMARK: may or may not unwrap \"inherit\" and \"initial\" depending on implementation\n\t\t// REMARK: giving \"matchedRules\" as a parameter allow you to mutualize the \"findAllMatching\" rules calls\n\t\t// \n\t\tgetSpecifiedStyle: function getSpecifiedStyle(element, cssPropertyName, matchedRules) {\n\t\t\t\n\t\t\t// hook for css regions\n\t\t\tvar fragmentSource;\n\t\t\tif(fragmentSource=element.getAttribute('data-css-regions-fragment-of')) {\n\t\t\t\tfragmentSource = document.querySelector('[data-css-regions-fragment-source=\"'+fragmentSource+'\"]');\n\t\t\t\tif(fragmentSource) return cssCascade.getSpecifiedStyle(fragmentSource, cssPropertyName);\n\t\t\t}\n\t\t\t\n\t\t\t// give IE a thumbs up for this!\n\t\t\tif(element.currentStyle && !window.opera) {\n\t\t\t\t\n\t\t\t\t// ask IE to manage the style himself...\n\t\t\t\tvar bestValue = element.myStyle[cssPropertyName] || element.currentStyle[cssPropertyName] || '';\n\t\t\t\t\n\t\t\t\t// return a parsed representation of the value\n\t\t\t\treturn cssSyntax.parseAListOfComponentValues(bestValue);\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t// TODO: support the \"initial\" and \"inherit\" things?\n\t\t\t\t\n\t\t\t\t// first, let's try inline style as it's fast and generally accurate\n\t\t\t\t// TODO: what if important rules override that?\n\t\t\t\ttry {\n\t\t\t\t\tif(bestValue = element.style.getPropertyValue(cssPropertyName) || element.myStyle[cssPropertyName]) {\n\t\t\t\t\t\treturn cssSyntax.parseAListOfComponentValues(bestValue);\n\t\t\t\t\t}\n\t\t\t\t} catch(ex) {}\n\t\t\t\t\n\t\t\t\t// find all relevant style rules\n\t\t\t\tvar isBestImportant=false; var bestPriority = 0; var bestValue = new cssSyntax.TokenList();\n\t\t\t\tvar rules = matchedRules || (\n\t\t\t\t\tcssPropertyName in cssCascade.monitoredProperties\n\t\t\t\t\t? element.myMatchedRules || []\n\t\t\t\t\t: cssCascade.findAllMatchingRules(element)\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\tvar visit = function(rules) {\n\t\t\t\t\t\n\t\t\t\t\tfor(var i=rules.length; i--; ) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// media queries hook\n\t\t\t\t\t\tif(rules[i].disabled) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// find a relevant declaration\n\t\t\t\t\t\tif(rules[i] instanceof cssSyntax.StyleRule) {\n\t\t\t\t\t\t\tvar decls = rules[i].getDeclarations();\n\t\t\t\t\t\t\tfor(var j=decls.length-1; j>=0; j--) {\n\t\t\t\t\t\t\t\tif(decls[j].type==\"DECLARATION\") {\n\t\t\t\t\t\t\t\t\tif(decls[j].name==cssPropertyName) {\n\t\t\t\t\t\t\t\t\t\t// only works if selectors containing a \",\" are deduplicated\n\t\t\t\t\t\t\t\t\t\tvar currentPriority = cssCascade.computeSelectorPriorityOf(rules[i].selector);\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tif(isBestImportant) {\n\t\t\t\t\t\t\t\t\t\t\t// only an important declaration can beat another important declaration\n\t\t\t\t\t\t\t\t\t\t\tif(decls[j].important) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(currentPriority >= bestPriority) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tbestPriority = currentPriority;\n\t\t\t\t\t\t\t\t\t\t\t\t\tbestValue = decls[j].value;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t// an important declaration beats any non-important declaration\n\t\t\t\t\t\t\t\t\t\t\tif(decls[j].important) {\n\t\t\t\t\t\t\t\t\t\t\t\tisBestImportant = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbestPriority = currentPriority;\n\t\t\t\t\t\t\t\t\t\t\t\tbestValue = decls[j].value;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t// the selector priority has to be higher otherwise\n\t\t\t\t\t\t\t\t\t\t\t\tif(currentPriority >= bestPriority) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tbestPriority = currentPriority;\n\t\t\t\t\t\t\t\t\t\t\t\t\tbestValue = decls[j].value;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if((rules[i] instanceof cssSyntax.AtRule) && (rules[i].name==\"media\")) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// visit them\n\t\t\t\t\t\t\tvisit(rules[i].toStylesheet())\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tvisit(rules);\n\t\t\t\t\n\t\t\t\t// return our best guess...\n\t\t\t\treturn bestValue||null;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\t\n\t\t//\n\t\t// start monitoring a new stylesheet\n\t\t// (should usually not be used because stylesheets load automatically)\n\t\t//\n\t\tstylesheets: [],\n\t\tloadStyleSheet: function loadStyleSheet(cssText,i) {\n\t\t\t\n\t\t\t// load in order\n\t\t\t\n\t\t\t// parse the stylesheet content\n\t\t\tvar rules = cssSyntax.parse(cssText).value;\n\t\t\t\n\t\t\t// add the stylesheet into the object model\n\t\t\tif(typeof(i)!==\"undefined\") { cssCascade.stylesheets[i]=rules; } \n\t\t\telse { i=cssCascade.stylesheets.push(rules);}\n\t\t\t\n\t\t\t// make sure to monitor the required rules\n\t\t\tcssCascade.startMonitoringStylesheet(rules)\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// start monitoring a new stylesheet\n\t\t// (should usually not be used because stylesheets load automatically)\n\t\t//\n\t\tloadStyleSheetTag: function loadStyleSheetTag(stylesheet,i) {\n\t\t\t\n\t\t\tif(stylesheet.hasAttribute('data-css-polyfilled')) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(stylesheet.tagName=='LINK') {\n\t\t\t\t\n\t\t\t\t// oh, no, we have to download it...\n\t\t\t\ttry {\n\t\t\t\t\t\n\t\t\t\t\t// dummy value in-between\n\t\t\t\t\tcssCascade.stylesheets[i] = new cssSyntax.TokenList();\n\t\t\t\t\t\n\t\t\t\t\t//\n\t\t\t\t\tvar xhr = new XMLHttpRequest(); xhr.href = stylesheet.href;\n\t\t\t\t\txhr.open('GET',stylesheet.href,true); xhr.ruleIndex = i; \n\t\t\t\t\txhr.onreadystatechange = function() {\n\t\t\t\t\t\tif(this.readyState==4) { \n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// status 0 is a webkit bug for local files\n\t\t\t\t\t\t\tif(this.status==200||this.status==0) {\n\t\t\t\t\t\t\t\tcssCascade.loadStyleSheet(this.responseText,this.ruleIndex)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcssConsole.log(\"css-cascade polyfill failled to load: \" + this.href);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\txhr.send();\n\t\t\t\t\t\n\t\t\t\t} catch(ex) {\n\t\t\t\t\tcssConsole.log(\"css-cascade polyfill failled to load: \" + stylesheet.href);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t// oh, cool, we just have to parse the content!\n\t\t\t\tcssCascade.loadStyleSheet(stylesheet.textContent,i);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// mark the stylesheet as ok\n\t\t\tstylesheet.setAttribute('data-css-polyfilled',true);\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// calling this function will load all currently existing stylesheets in the document\n\t\t// (should usually not be used because stylesheets load automatically)\n\t\t//\n\t\tselectorForStylesheets: \"style:not([data-no-css-polyfill]):not([data-css-polyfilled]), link[rel=stylesheet]:not([data-no-css-polyfill]):not([data-css-polyfilled])\",\n\t\tloadAllStyleSheets: function loadAllStyleSheets() {\n\t\t\t\n\t\t\t// for all stylesheets in the <head> tag...\n\t\t\tvar head = document.head || document.documentElement;\n\t\t\tvar stylesheets = head.querySelectorAll(cssCascade.selectorForStylesheets);\n\t\t\t\n\t\t\tvar intialLength = this.stylesheets.length;\n\t\t\tthis.stylesheets.length += stylesheets.length\n\t\t\t\n\t\t\t// for all of them...\n\t\t\tfor(var i = stylesheets.length; i--;) {\n\t\t\t\t\n\t\t\t\t// \n\t\t\t\t// load the stylesheet\n\t\t\t\t// \n\t\t\t\tvar stylesheet = stylesheets[i]; \n\t\t\t\tcssCascade.loadStyleSheetTag(stylesheet,intialLength+i)\n\t\t\t\t\n\t\t\t}\n\t\t},\n\t\t\n\t\t//\n\t\t// this is where we store event handlers for monitored properties\n\t\t//\n\t\tmonitoredProperties: Object.create ? Object.create(null) : {},\n\t\tmonitoredPropertiesHandler: {\n\t\t\tonupdate: function(element, rule) {\n\t\t\t\t\n\t\t\t\t// we need to find all regexps that matches\n\t\t\t\tvar mps = cssCascade.monitoredProperties;\n\t\t\t\tvar decls = rule.getDeclarations();\n\t\t\t\tfor(var j=decls.length-1; j>=0; j--) {\n\t\t\t\t\tif(decls[j].type==\"DECLARATION\") {\n\t\t\t\t\t\tif(decls[j].name in mps) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// call all handlers waiting for this\n\t\t\t\t\t\t\tvar hs = mps[decls[j].name];\n\t\t\t\t\t\t\tfor(var hi=hs.length; hi--;) {\n\t\t\t\t\t\t\t\ths[hi].onupdate(element,rule);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// don't call twice\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t},\n\t\t\n\t\t//\n\t\t// add an handler to some properties (aka fire when their value *MAY* be affected)\n\t\t// REMARK: because this event does not promise the value changed, you may want to figure it out before relayouting\n\t\t//\n\t\tstartMonitoringProperties: function startMonitoringProperties(properties, handler) {\n\t\t\t\n\t\t\tfor(var i=properties.length; i--; ) {\n\t\t\t\tvar property = properties[i];\n\t\t\t\tvar handlers = (\n\t\t\t\t\tcssCascade.monitoredProperties[property]\n\t\t\t\t\t|| (cssCascade.monitoredProperties[property] = [])\n\t\t\t\t);\n\t\t\t\thandlers.push(handler)\n\t\t\t}\n\t\t\t\n\t\t\tfor(var s=0; s<cssCascade.stylesheets.length; s++) {\n\t\t\t\tvar currentStylesheet = cssCascade.stylesheets[s];\n\t\t\t\tcssCascade.startMonitoringStylesheet(currentStylesheet);\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// calling this function will detect monitored rules in the stylesheet\n\t\t// (should usually not be used because stylesheets load automatically)\n\t\t//\n\t\tstartMonitoringStylesheet: function startMonitoringStylesheet(rules) {\n\t\t\tfor(var i=0; i<rules.length; i++) {\n\t\t\t\t\n\t\t\t\t// only consider style rules\n\t\t\t\tif(rules[i] instanceof cssSyntax.StyleRule) {\n\t\t\t\t\t\n\t\t\t\t\t// try to see if the current rule is worth monitoring\n\t\t\t\t\tif(rules[i].isMonitored) continue;\n\t\t\t\t\t\n\t\t\t\t\t// for that, let's see if we can find a declaration we should watch\n\t\t\t\t\tvar decls = rules[i].getDeclarations();\n\t\t\t\t\tfor(var j=decls.length-1; j>=0; j--) {\n\t\t\t\t\t\tif(decls[j].type==\"DECLARATION\") {\n\t\t\t\t\t\t\tif(decls[j].name in cssCascade.monitoredProperties) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// if we found some, start monitoring\n\t\t\t\t\t\t\t\tcssCascade.startMonitoringRule(rules[i]);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else if(rules[i] instanceof cssSyntax.AtRule) {\n\t\t\t\t\t\n\t\t\t\t\t// handle @media\n\t\t\t\t\tif(rules[i].name == \"media\" && window.matchMedia) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tcssCascade.startMonitoringMedia(rules[i]);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t},\n\t\t\n\t\t//\n\t\t// calling this function will detect media query updates and fire events accordingly\n\t\t// (should usually not be used because stylesheets load automatically)\n\t\t//\n\t\tstartMonitoringMedia: function startMonitoringMedia(atrule) {\n\t\t\ttry {\n\t\t\t\t\n\t\t\t\tvar media = window.matchMedia(atrule.prelude.toCSSString());\n\t\t\t\t\n\t\t\t\t// update all the rules when needed\n\t\t\t\tvar rules = atrule.toStylesheet().value;\n\t\t\t\tcssCascade.updateMedia(rules, !media.matches, false);\n\t\t\t\tmedia.addListener(\n\t\t\t\t\tfunction(newMedia) { cssCascade.updateMedia(rules, !newMedia.matches, true); }\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\t// it seems I like taking risks...\n\t\t\t\tcssCascade.startMonitoringStylesheet(rules);\n\t\t\t\t\n\t\t\t} catch(ex) {\n\t\t\t\tsetImmediate(function() { throw ex; })\n\t\t\t}\n\t\t},\n\t\t\n\t\t//\n\t\t// define what happens when a media query status changes\n\t\t//\n\t\tupdateMedia: function(rules,disabled,update) {\n\t\t\tfor(var i=rules.length; i--; ) {\n\t\t\t\trules[i].disabled = disabled;\n\t\t\t\t// TODO: should probably get handled by a setter on the rule...\n\t\t\t\tvar sr = rules[i].subRules;\n\t\t\t\tif(sr) {\n\t\t\t\t\tfor(var j=sr.length; j--; ) {\n\t\t\t\t\t\tsr[j].disabled = disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// in case of update, all elements matching the selector went potentially updated...\n\t\t\tif(update) {\n\t\t\t\tfor(var i=rules.length; i--; ) {\n\t\t\t\t\tvar els = document.querySelectorAll(rules[i].selector.toCSSString());\n\t\t\t\t\tfor(var j=els.length; j--; ) {\n\t\t\t\t\t\tcssCascade.monitoredPropertiesHandler.onupdate(els[j],rules[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\n\t\t// \n\t\t// splits a rule if it has multiple selectors\n\t\t// \n\t\tsplitRule: function splitRule(rule) {\n\t\t\t\n\t\t\t// create an array for all the subrules\n\t\t\tvar rules = [];\n\t\t\t\n\t\t\t// fill the array\n\t\t\tvar currentRule = new cssSyntax.StyleRule(); currentRule.disabled=rule.disabled;\n\t\t\tfor(var i=0; i<rule.selector.length; i++) {\n\t\t\t\tif(rule.selector[i] instanceof cssSyntax.DelimToken && rule.selector[i].value==\",\") {\n\t\t\t\t\tcurrentRule.value = rule.value; rules.push(currentRule);\n\t\t\t\t\tcurrentRule = new cssSyntax.StyleRule(); currentRule.disabled=rule.disabled;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentRule.selector.push(rule.selector[i])\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrentRule.value = rule.value; rules.push(currentRule);\n\t\t\t\n\t\t\t// save the result of the split as subrules\n\t\t\treturn rule.subRules = rules;\n\t\t\t\n\t\t},\n\t\t\n\t\t// \n\t\t// ask the css-selector implementation to notify changes for the rules\n\t\t// \n\t\tstartMonitoringRule: function startMonitoringRule(rule) {\n\t\t\t\n\t\t\t// avoid monitoring rules twice\n\t\t\tif(!rule.isMonitored) { rule.isMonitored=true } else { return; }\n\t\t\t\n\t\t\t// split the rule if it has multiple selectors\n\t\t\tvar rules = rule.subRules || cssCascade.splitRule(rule);\n\t\t\t\n\t\t\t// monitor the rules\n\t\t\tfor(var i=0; i<rules.length; i++) {\n\t\t\t\trule = rules[i];\n\t\t\t\tquerySelectorLive(rule.selector.toCSSString(), {\n\t\t\t\t\tonadded: function(e) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// add the rule to the matching list of this element\n\t\t\t\t\t\t(e.myMatchedRules = e.myMatchedRules || []).unshift(rule); // TODO: does not respect priority order\n\t\t\t\t\t\t\n\t\t\t\t\t\t// generate an update event\n\t\t\t\t\t\tcssCascade.monitoredPropertiesHandler.onupdate(e, rule);\n\t\t\t\t\t\t\n\t\t\t\t\t},\n\t\t\t\t\tonremoved: function(e) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// remove the rule from the matching list of this element\n\t\t\t\t\t\tif(e.myMatchedRules) e.myMatchedRules.splice(e.myMatchedRules.indexOf(rule), 1);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// generate an update event\n\t\t\t\t\t\tcssCascade.monitoredPropertiesHandler.onupdate(e, rule);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// converts a css property name to a javascript name\n\t\t//\n\t\ttoCamelCase: function toCamelCase(variable) { \n\t\t\treturn variable.replace(\n\t\t\t\t/-([a-z])/g, \n\t\t\t\tfunction(str,letter) { \n\t\t\t\t\treturn letter.toUpperCase();\n\t\t\t\t}\n\t\t\t);\n\t\t},\n\t\t\n\t\t//\n\t\t// add some magic code to support properties on the style interface\n\t\t//\n\t\tpolyfillStyleInterface: function(cssPropertyName) {\n\t\t\t\n\t\t\tvar prop = {\n\t\t\t\t\n\t\t\t\tget: function() {\n\t\t\t\t\t\n\t\t\t\t\t// check we know which element we work on\n\t\t\t\t\ttry { if(!this.parentElement) throw new Error(\"Please use the anHTMLElement.myStyle property to get polyfilled properties\") }\n\t\t\t\t\tcatch(ex) { setImmediate(function() { throw ex; }); return ''; }\n\t\t\t\t\t\n\t\t\t\t\ttry { \n\t\t\t\t\t\t// non-computed style: return the local style of the element\n\t\t\t\t\t\tthis.clip = (this.clip===undefined?'':this.clip);\n\t\t\t\t\t\treturn this.parentElement.getAttribute('data-style-'+cssPropertyName);\n\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\t// computed style: return the specified style of the element\n\t\t\t\t\t\tvar value = cssCascade.getSpecifiedStyle(this.parentElement, cssPropertyName, undefined, true);\n\t\t\t\t\t\treturn value && value.length>0 ? value.toCSSString() : '';\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\tset: function(v) {\n\t\t\t\t\t\n\t\t\t\t\t// check that the style is writable\n\t\t\t\t\tthis.clip = (this.clip===undefined?'':this.clip);\n\n\t\t\t\t\t// check we know which element we work on\n\t\t\t\t\ttry { if(!this.parentElement) throw new Error(\"Please use the anHTMLElement.myStyle property to set polyfilled properties\") }\n\t\t\t\t\tcatch(ex) { setImmediate(function() { throw ex; }); return; }\n\t\t\t\t\t\n\t\t\t\t\t// modify the local style of the element\n\t\t\t\t\tif(this.parentElement.getAttribute('data-style-'+cssPropertyName) != v) {\n\t\t\t\t\t\tthis.parentElement.setAttribute('data-style-'+cssPropertyName,v);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t};\n\t\t\t\n\t\t\tvar styleProtos = [];\n\t\t\ttry { styleProtos.push(Object.getPrototypeOf(document.documentElement.style) || CSSStyleDeclaration); } catch (ex) {}\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(getComputedStyle(document.documentElement))); } catch (ex) {}\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.currentStyle)); } catch (ex) {}\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.runtimeStyle)); } catch (ex) {}\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.specifiedStyle)); } catch (ex) {}\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.cascadedStyle)); } catch (ex) {}\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.usedStyle)); } catch (ex) {}\n\t\t\t\n\t\t\tfor(var i = styleProtos.length; i--;) {\n\t\t\t\tvar styleProto = styleProtos[i];\n\t\t\t\tObject.defineProperty(styleProto,cssPropertyName,prop);\n\t\t\t\tObject.defineProperty(styleProto,cssCascade.toCamelCase(cssPropertyName),prop);\n\t\t\t}\n\t\t\tcssCascade.startMonitoringRule(cssSyntax.parse('[style*=\"'+cssPropertyName+'\"]{'+cssPropertyName+':attr(style)}').value[0]);\n\t\t\tcssCascade.startMonitoringRule(cssSyntax.parse('[data-style-'+cssPropertyName+']{'+cssPropertyName+':attr(style)}').value[0]);\n\t\t\t\n\t\t\t// add to the list of polyfilled properties...\n\t\t\tcssCascade.getAllCSSProperties().push(cssPropertyName);\n\t\t\tcssCascade.computationUnsafeProperties[cssPropertyName] = true;\n\t\t\t\n\t\t}\n\t\t\n\t};\n\n\t//\n\t// polyfill for browsers not support CSSStyleDeclaration.parentElement (all of them right now)\n\t//\n\tdomEvents.EventTarget.implementsIn(cssCascade);\n\tObject.defineProperty(Element.prototype,'myStyle',{\n\t\tget: function() {\n\t\t\tvar style = this.style; \n\t\t\tif(!style.parentElement) style.parentElement = this;\n\t\t\treturn style;\n\t\t}\n\t});\n\n\t//\n\t// load all stylesheets at the time the script is loaded\n\t// then do it again when all stylesheets are downloaded\n\t// and again if some style tag is added to the DOM\n\t//\n\tif(!(\"no_auto_stylesheet_detection\" in window)) {\n\t\t\n\t\tcssCascade.loadAllStyleSheets();\n\t\tdocument.addEventListener(\"DOMContentLoaded\", function() {\n\t\t\tcssCascade.loadAllStyleSheets();\n\t\t\tquerySelectorLive(\n\t\t\t\tcssCascade.selectorForStylesheets,\n\t\t\t\t{\n\t\t\t\t\tonadded: function(e) {\n\t\t\t\t\t\t// TODO: respect DOM order?\n\t\t\t\t\t\tcssCascade.loadStyleSheetTag(e);\n\t\t\t\t\t\tcssCascade.dispatchEvent('stylesheetadded');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t)\n\t\t})\n\t}\n\t\n\treturn cssCascade;\n\n})(window, document);\n\nrequire.define('src/core/css-cascade.js');","module.exports = (function(window, document) { \"use strict\"; \n\n\tvar cssSyntax = require('src/core/css-syntax.js');\n\tvar cssCascade = require('src/core/css-cascade.js');\n\t\n\tvar cssBreak = {\n\n\t\t//\n\t\t// returns true if an element is replaced \n\t\t// (can't be broken because considered as an image in css layout)\n\t\t// \n\t\tisReplacedElement: function isReplacedElement(element) {\n\t\t\tif(!(element instanceof Element)) return false;\n\t\t\tvar replacedElementTags = /^(SVG|MATH|IMG|VIDEO|PICTURE|OBJECT|EMBED|IFRAME|TEXTAREA|BUTTON|INPUT)$/; // TODO: more\n\t\t\treturn replacedElementTags.test(element.tagName);\n\t\t},\n\t\t\n\t\t// \n\t\t// returns true if an element has a scrollbar or act on overflowing content\n\t\t// \n\t\tisScrollable: function isScrollable(element, elementOverflow) {\n\t\t\tif(!(element instanceof Element)) return false;\n\t\t\tif(typeof(elementOverflow)==\"undefined\") elementOverflow = getComputedStyle(element).overflow;\n\t\t\t\n\t\t\treturn (\n\t\t\t\telementOverflow !== \"visible\"\n\t\t\t\t&& elementOverflow !== \"hidden\"\n\t\t\t);\n\t\t\t\n\t\t},\n\t\t\n\t\t// \n\t\t// returns true if the element is part of an inline flow\n\t\t// TextNodes definitely qualify, but also inline-block elements\n\t\t// \n\t\tisSingleLineOfTextComponent: function(element, elementStyle, elementDisplay, elementPosition, isReplaced) {\n\t\t\tif(!(element instanceof Element)) return true;\n\t\t\tif(typeof(elementStyle)==\"undefined\") elementStyle = getComputedStyle(element);\n\t\t\tif(typeof(elementDisplay)==\"undefined\") elementDisplay = elementStyle.display;\n\t\t\tif(typeof(elementPosition)==\"undefined\") elementPosition = elementStyle.position;\n\t\t\tif(typeof(isReplaced)==\"undefined\") isReplaced = this.isReplacedElement(element);\n\t\t\t\n\t\t\treturn (\n\t\t\t\telementDisplay === \"inline-block\"\n\t\t\t\t|| elementDisplay === \"inline-table\"\n\t\t\t\t|| elementDisplay === \"inline-flex\"\n\t\t\t\t|| elementDisplay === \"inline-grid\"\n\t\t\t\t// TODO: more\n\t\t\t) && (\n\t\t\t\telementPosition === \"static\"\n\t\t\t\t|| elementPosition === \"relative\"\n\t\t\t);\n\t\t\t\n\t\t},\n\t\t\n\t\t// \n\t\t// returns true if the element is part of an inline flow\n\t\t// TextNodes definitely qualify, but also inline-block elements\n\t\t// \n\t\thasAnyInlineFlow: function(element) {\n\t\t\t\n\t\t\tfunction countAsInline(element) {\n\t\t\t\tif(!(element instanceof Element)) return !(/^\\s*$/.test(element.nodeValue));\n\t\t\t\treturn !cssBreak.isOutOfFlowElement(element) && cssBreak.isSingleLineOfTextComponent(element);\n\t\t\t}\n\t\t\t\n\t\t\t// try to find any inline element\n\t\t\tvar current = element.firstChild;\n\t\t\twhile(current) {\n\t\t\t\tif(countAsInline(current)) return true;\n\t\t\t\tcurrent = current.nextSibling;\n\t\t\t}\n\t\t\t\n\t\t\t// no inline element\n\t\t\treturn false;\n\t\t\t\n\t\t},\n\t\t\n\t\t// \n\t\t// returns true if the element breaks the inline flow\n\t\t// (the case of block elements, mostly)\n\t\t// \n\t\tisLineBreakingElement: function(element, elementStyle, elementDisplay, elementPosition) {\n\t\t\t\n\t\t\tif(!(element instanceof Element)) return false;\n\t\t\tif(typeof(elementStyle)==\"undefined\") elementStyle = getComputedStyle(element);\n\t\t\tif(typeof(elementDisplay)==\"undefined\") elementDisplay = elementStyle.display;\n\t\t\tif(typeof(elementPosition)==\"undefined\") elementPosition = elementStyle.position;\n\t\t\t\n\t\t\treturn (\n\t\t\t\t(\n\t\t\t\t\t// in-flow bock elements\n\t\t\t\t\t(elementDisplay === \"block\")\n\t\t\t\t\t&& !this.isOutOfFlowElement(element, elementStyle, elementDisplay, elementPosition)\n\t\t\t\t\t\n\t\t\t\t) || (\n\t\t\t\t\t\n\t\t\t\t\t// displayed <br> elements\n\t\t\t\t\telement.tagName===\"BR\" && elementDisplay!==\"none\"\n\t\t\t\t\t\n\t\t\t\t)\n\t\t\t);\n\t\t},\n\t\t\n\t\t// \n\t\t// returns true if the element breaks the inline flow before him\n\t\t// (the case of block elements, mostly)\n\t\t// \n\t\tisLinePreBreakingElement: function(element, elementStyle, elementDisplay, elementPosition) {\n\t\t\tif(!(element instanceof Element)) return false;\n\n\t\t\tvar breakBefore = cssCascade.getSpecifiedStyle(element,'break-before').toCSSString();\n\t\t\treturn (\n\t\t\t\t(breakBefore==\"region\"||breakBefore==\"all\") \n\t\t\t\t|| cssBreak.isLineBreakingElement(element, elementStyle, elementDisplay, elementPosition)\n\t\t\t);\n\t\t\t\n\t\t},\n\t\t\n\t\t// \n\t\t// returns true if the element breaks the inline flow after him\n\t\t// (the case of block elements, mostly)\n\t\t// \n\t\tisLinePostBreakingElement: function(element, elementStyle, elementDisplay, elementPosition) {\n\t\t\tif(!(element instanceof Element)) return false;\n\t\t\t\n\t\t\tvar breakAfter = cssCascade.getSpecifiedStyle(element,'break-after').toCSSString();\n\t\t\treturn (\n\t\t\t\t(breakAfter==\"region\"||breakAfter==\"all\") \n\t\t\t\t|| cssBreak.isLineBreakingElement(element, elementStyle, elementDisplay, elementPosition)\n\t\t\t);\n\t\t\t\n\t\t},\n\t\t\n\t\t// \n\t\t// returns true if the element is outside any block/inline flow\n\t\t// (this the case of absolutely positioned elements, and floats)\n\t\t// \n\t\tisOutOfFlowElement: function(element, elementStyle, elementDisplay, elementPosition, elementFloat) {\n\t\t\tif(!(element instanceof Element)) return false;\n\t\t\tif(typeof(elementStyle)==\"undefined\") elementStyle = getComputedStyle(element);\n\t\t\tif(typeof(elementDisplay)==\"undefined\") elementDisplay = elementStyle.display;\n\t\t\tif(typeof(elementPosition)==\"undefined\") elementPosition = elementStyle.position; \n\t\t\tif(typeof(elementFloat)==\"undefined\") elementFloat = elementStyle.float || elementStyle.styleFloat || elementStyle.cssFloat;\n\t\t\t\n\t\t\treturn (\n\t\t\t\t\n\t\t\t\t// positioned elements are out of the flow\n\t\t\t\t(elementPosition===\"absolute\"||elementPosition===\"fixed\")\n\t\t\t\t\n\t\t\t\t// floated elements as well\n\t\t\t\t|| (elementFloat!==\"none\") \n\t\t\t\t\n\t\t\t\t// not sure but let's say hidden elements as well\n\t\t\t\t|| (elementDisplay===\"none\")\n\t\t\t\t\n\t\t\t);\n\t\t\t\n\t\t},\n\t\t\n\t\t// \n\t\t// returns true if two sibling elements are in the same text line\n\t\t// (this function is not perfect, work with it with care)\n\t\t// \n\t\tareInSameSingleLine: function areInSameSingleLine(element1, element2) {\n\t\t\t\n\t\t\t//\n\t\t\t// look for obvious reasons why it wouldn't be the case\n\t\t\t//\n\t\t\t\n\t\t\t// if the element are not direct sibling, we must use their inner siblings as well\n\t\t\tif(element1.nextSibling != element2) { \n\t\t\t\tif(element2.nextSibling != element1) throw \"I gave up!\"; \n\t\t\t\tvar t = element1; element1=element2; element2=t;\n\t\t\t}\n\t\t\t \n\t\t\t// a block element is never on the same line as another element\n\t\t\tif(this.isLinePostBreakingElement(element1)) return false;\n\t\t\tif(this.isLinePreBreakingElement(element2)) return false;\n\t\t\t\n\t\t\t// if the previous element is out of flow, we may consider it as being part of the current line\n\t\t\tif(this.isOutOfFlowElement(element1)) return true;\n\t\t\t\n\t\t\t// if the current object is not a single line component, return false\n\t\t\tif(!this.isSingleLineOfTextComponent(element1)) return false;\n\t\t\t\n\t\t\t// \n\t\t\t// compute the in-flow bounding rect of the two elements\n\t\t\t// \n\t\t\tvar element1box = Node.getBoundingClientRect(element1);\n\t\t\tvar element2box = Node.getBoundingClientRect(element2);\n\t\t\tfunction shift(box,shiftX,shiftY) {\n\t\t\t\treturn {\n\t\t\t\t\ttop: box.top+shiftY,\n\t\t\t\t\tbottom: box.bottom+shiftY,\n\t\t\t\t\tleft: box.left+shiftX,\n\t\t\t\t\tright: box.right+shiftX\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// we only need to shift elements\n\t\t\tif(element1 instanceof Element) {\n\t\t\t\tvar element1Style = getComputedStyle(element1);\n\t\t\t\telement1box = shift(element1box, parseFloat(element1Style.marginLeft), parseFloat(element1Style.marginTop))\n\t\t\t\tif(element1Style.position==\"relative\") {\n\t\t\t\t\telement1box = shift(element1box, parseFloat(element1Style.left), parseFloat(element1Style.top))\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// we only need to shift elements\n\t\t\tif(element2 instanceof Element) {\n\t\t\t\tvar element2Style = getComputedStyle(element2);\n\t\t\t\telement2box = shift(element2box, parseFloat(element2Style.marginLeft), parseFloat(element2Style.marginTop))\n\t\t\t\tif(element2Style.position==\"relative\") {\n\t\t\t\t\telement2box = shift(element2box, parseFloat(element2Style.left), parseFloat(element2Style.top))\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// order the nodes so that they are in left-to-right order\n\t\t\t// (this means invert their order in the case of right-to-left flow)\n\t\t\tvar firstElement = getComputedStyle(element1.parentNode).direction==\"rtl\" ? element2box : element1box;\n\t\t\tvar secondElement = getComputedStyle(element1.parentNode).direction==\"rtl\" ? element1box : element2box;\n\t\t\t\n\t\t\t// return true if both elements are have non-overlapping\n\t\t\t// margin- and position-corrected in-flow bounding rect\n\t\t\t// and if their relative position is the one of the current\n\t\t\t// flow (either rtl or ltr)\n\t\t\treturn firstElement.right <= secondElement.left;\n\t\t\t\n\t\t\t// TODO: what about left-to-right + right-aligned text?\n\t\t\t// I should probably takes care of vertical position in this case to solve ambiguities\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// returns true if the element has \"overflow: hidden\" set on it, and actually overflows\n\t\t//\n\t\tisHiddenOverflowing: function isHiddenOverflowing(element, elementOverflow) {\n\t\t\tif(!(element instanceof Element)) return false;\n\t\t\tif(typeof(elementOverflow)==\"undefined\") elementOverflow = getComputedStyle(element).display;\n\t\t\t\n\t\t\treturn (\n\t\t\t\telementOverflow == \"hidden\" \n\t\t\t\t&& element.offsetHeight != element.scrollHeight // trust me that works\n\t\t\t);\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// returns true if the element has a border-radius that impacts his layout\n\t\t//\n\t\thasBigRadius: function(element, elementStyle) {\n\t\t\tif(!(element instanceof Element)) return false;\n\t\t\tif(typeof(elementStyle)==\"undefined\") elementStyle = getComputedStyle(element);\n\n\t\t\t// if the browser supports radiuses {f### prefixes}\n\t\t\tif(\"borderTopLeftRadius\" in elementStyle) {\n\t\t\t\t\n\t\t\t\tvar tlRadius = parseFloat(elementStyle.borderTopLeftRadius);\n\t\t\t\tvar trRadius = parseFloat(elementStyle.borderTopRightRadius);\n\t\t\t\tvar blRadius = parseFloat(elementStyle.borderBottomLeftRadius);\n\t\t\t\tvar brRadius = parseFloat(elementStyle.borderBottomRightRadius);\n\t\t\t\t\n\t\t\t\t// tiny radiuses (<15px) are tolerated anyway\n\t\t\t\tif(tlRadius < 15 && trRadius < 15 && blRadius < 15 && brRadius < 15) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar tWidth = parseFloat(elementStyle.borderTopWidth);\n\t\t\t\tvar bWidth = parseFloat(elementStyle.borderBottomWidth);\n\t\t\t\tvar lWidth = parseFloat(elementStyle.borderLeftWidth);\n\t\t\t\tvar rWidth = parseFloat(elementStyle.borderRightWidth);\n\t\t\t\t\n\t\t\t\t// make sure the radius itself is contained into the border\n\t\t\t\t\n\t\t\t\tif(tlRadius > tWidth) return true;\n\t\t\t\tif(tlRadius > lWidth) return true;\n\t\t\t\t\n\t\t\t\tif(trRadius > tWidth) return true;\n\t\t\t\tif(trRadius > rWidth) return true;\n\t\t\t\t\n\t\t\t\tif(blRadius > bWidth) return true;\n\t\t\t\tif(blRadius > lWidth) return true;\n\t\t\t\t\n\t\t\t\tif(brRadius > bWidth) return true;\n\t\t\t\tif(brRadius > rWidth) return true;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// all conditions were met\n\t\t\treturn false;\n\t\t},\n\t\t\n\t\t//\n\t\t// return trus if the break-inside property is 'avoid' or 'avoid-region'\n\t\t//\n\t\tisBreakInsideAvoid: function isBreakInsideAvoid(element, elementStyle) {\n\t\t\tvar breakInside = cssCascade.getSpecifiedStyle(element, 'break-inside', undefined, true).toCSSString().trim().toLowerCase(); \n\t\t\treturn (breakInside == \"avoid\" || breakInside == \"avoid-region\");\n\t\t},\n\t\t\n\t\t//\n\t\t// returns true if the element is unbreakable according to the spec\n\t\t// (and some of the expected limitations of HTML/CSS)\n\t\t//\n\t\tisMonolithic: function isMonolithic(element) {\n\t\t\tif(!(element instanceof Element)) return false;\n\t\t\t\n\t\t\tvar elementStyle = getComputedStyle(element);\n\t\t\tvar elementOverflow = elementStyle.overflow;\n\t\t\tvar elementDisplay = elementStyle.display;\n\t\t\t\n\t\t\t// Some content is not fragmentable, for example:\n\t\t\t// - many types of replaced elements (such as images or video)\n\t\t\t\n\t\t\tvar isReplaced = this.isReplacedElement(element);\n\t\t\t\n\t\t\t// - scrollable elements\n\t\t\t\n\t\t\tvar isScrollable = this.isScrollable(element, elementOverflow);\n\t\t\t\n\t\t\t// - a single line of text content. \n\t\t\t\n\t\t\tvar isSingleLineOfText = this.isSingleLineOfTextComponent(element, elementStyle, elementDisplay, undefined, isReplaced);\n\t\t\t\n\t\t\t// Such content is considered monolithic: it contains no\n\t\t\t// possible break points. \n\t\t\t\n\t\t\t// In addition to any content which is not fragmentable, \n\t\t\t// UAs may consider as monolithic:\n\t\t\t// - any elements with overflow set to auto or scroll \n\t\t\t// - any elements with overflow: hidden and a non-auto logical height (and no specified maximum logical height).\n\t\t\t\n\t\t\tvar isHiddenOverflowing = this.isHiddenOverflowing(element, elementOverflow);\n\t\t\t\n\t\t\t// ADDITION TO THE SPEC:\n\t\t\t// I don't want to handle the case where \n\t\t\t// an element has a border-radius that is bigger\n\t\t\t// than the border-width to which it belongs\n\t\t\tvar hasBigRadius = this.hasBigRadius(element, elementStyle);\n\t\t\t\n\t\t\t// ADDITION TO THE SPEC:\n\t\t\t// Someone proposed to support \"break-inside: avoid\" here\n\t\t\tvar isBreakInsideAvoid = this.isBreakInsideAvoid(element, elementStyle);\n\t\t\t\n\t\t\t// all of them are monolithic\n\t\t\treturn isReplaced || isScrollable || isSingleLineOfText || isHiddenOverflowing || hasBigRadius || isBreakInsideAvoid;\n\t\t\t\n\t\t},\n\t\t\n\t\t// \n\t\t// returns true if \"r\" is a collapsed range located at a possible break point for \"region\"\n\t\t// (this function does all the magic for you, but you may want to avoid using it too much)\n\t\t// \n\t\tisPossibleBreakPoint: function isPossibleBreakPoint(r, region) {\n\t\t\t\n\t\t\t// r has to be a range, and be collapsed\n\t\t\tif(!(r instanceof Range)) return false;\n\t\t\tif(!(r.collapsed)) return false;\n\t\t\t\n\t\t\t// no ancestor up to the region has to be monolithic\n\t\t\tvar ancestor = r.startContainer;\n\t\t\twhile(ancestor && ancestor !== region) {\n\t\t\t\tif(cssBreak.isMonolithic(ancestor)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tancestor = ancestor.parentNode;\n\t\t\t}\n\t\t\t\n\t\t\t// we also have to check that we're not between two single-line-of-text elements\n\t\t\t// that are actually on the same line (in which case you can't break)\n\t\t\tvar ancestor = r.startContainer; \n\t\t\tvar lastAncestor = r.startContainer.childNodes[r.startOffset];\n\t\t\twhile(ancestor && lastAncestor !== region) {\n\t\t\t\tif(lastAncestor && lastAncestor.previousSibling) {\n\t\t\t\t\t\n\t\t\t\t\tif(this.areInSameSingleLine(lastAncestor, lastAncestor.previousSibling)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlastAncestor = ancestor;\n\t\t\t\tancestor = ancestor.parentNode;\n\t\t\t}\n\t\t\t\n\t\t\t// there are some very specific conditions for breaking\n\t\t\t// at the edge of an element:\n\t\t\t\n\t\t\tif(r.startOffset==0) {\n\t\t\t\t\n\t\t\t\t// Class 3 breaking point:\n\t\t\t\t// ========================\n\t\t\t\t// Between the content edge of a block container box \n\t\t\t\t// and the outer edges of its child content (margin \n\t\t\t\t// edges of block-level children or line box edges \n\t\t\t\t// for inline-level children) if there is a (non-zero)\n\t\t\t\t// gap between them.\n\t\t\t\t\n\t\t\t\tvar firstChild = r.startContainer.childNodes[0];\n\t\t\t\tif(firstChild) {\n\t\t\t\t\t\n\t\t\t\t\tvar firstChildBox = (\n\t\t\t\t\t\tNode.getBoundingClientRect(firstChild)\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\tvar parentBox = (\n\t\t\t\t\t\tr.startContainer.getBoundingClientRect()\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\tif(firstChildBox.top == parentBox.top) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// all conditions are met!\n\t\t\treturn true;\n\t\t\t\n\t\t}\n\t\t\n\t};\n\t\n\treturn cssBreak;\n\t\n})(window, document);\nrequire.define('src/core/css-break.js');","\"use strict\";\n\n//\n// start by polyfilling caretRangeFromPoint\n//\n\nif(!document.caretRangeFromPoint) {\n    if (document.caretPositionFromPoint) {\n        document.caretRangeFromPoint = function caretRangeFromPoint(x,y) {\n            var r = document.createRange();\n            var p = document.caretPositionFromPoint(x,y); \n            if(p.offsetNode) {\n                r.setStart(p.offsetNode, p.offset);\n                r.setEnd(p.offsetNode, p.offset);\n            }\n            return r;\n        }\n    } else if((document.body||document.createElement('body')).createTextRange) {\n        \n        //\n        // we may want to convert TextRange to Range\n        //\n        \n        var TextRangeUtils = {\n            convertToDOMRange: function (textRange, document) {\n                var adoptBoundary = function(domRange, textRangeInner, bStart) {\n                    // iterate backwards through parent element to find anchor location\n                    var cursorNode = document.createElement('a'), cursor = textRangeInner.duplicate();\n                    cursor.collapse(bStart);\n                    var parent = cursor.parentElement();\n                    do {\n                            parent.insertBefore(cursorNode, cursorNode.previousSibling);\n                            cursor.moveToElementText(cursorNode);\n                    } while (cursor.compareEndPoints(bStart ? 'StartToStart' : 'StartToEnd', textRangeInner) > 0 && cursorNode.previousSibling);\n                    \n                    // when we exceed or meet the cursor, we've found the node\n                    if (cursor.compareEndPoints(bStart ? 'StartToStart' : 'StartToEnd', textRangeInner) == -1 && cursorNode.nextSibling) {\n                            // data node\n                            cursor.setEndPoint(bStart ? 'EndToStart' : 'EndToEnd', textRangeInner);\n                            domRange[bStart ? 'setStart' : 'setEnd'](cursorNode.nextSibling, cursor.text.length);\n                    } else {\n                            // element\n                            domRange[bStart ? 'setStartBefore' : 'setEndBefore'](cursorNode);\n                    }\n                    cursorNode.parentNode.removeChild(cursorNode);\n                }\n                \n                // validate arguments\n                if(!document) { document=window.document; }\n                \n                // return a DOM range\n                var domRange = document.createRange();\n                adoptBoundary(domRange, textRange, true);\n                adoptBoundary(domRange, textRange, false);\n                return domRange;\n            },\n\n            convertFromDOMRange: function (domRange) {\n                var adoptEndPoint = function(textRange, domRangeInner, bStart) {\n                    // find anchor node and offset\n                    var container = domRangeInner[bStart ? 'startContainer' : 'endContainer'];\n                    var offset = domRangeInner[bStart ? 'startOffset' : 'endOffset'], textOffset = 0;\n                    var anchorNode = DOMUtils.isDataNode(container) ? container : container.childNodes[offset];\n                    var anchorParent = DOMUtils.isDataNode(container) ? container.parentNode : container;\n                    // visible data nodes need a text offset\n                    if (container.nodeType == 3 || container.nodeType == 4)\n                        textOffset = offset;\n                    \n                    // create a cursor element node to position range (since we can't select text nodes)\n                    var cursorNode = domRangeInner._document.createElement('a');\n                    anchorParent.insertBefore(cursorNode, anchorNode);\n                    var cursor = domRangeInner._document.body.createTextRange();\n                    cursor.moveToElementText(cursorNode);\n                    cursorNode.parentNode.removeChild(cursorNode);\n                    // move range\n                    textRange.setEndPoint(bStart ? 'StartToStart' : 'EndToStart', cursor);\n                    textRange[bStart ? 'moveStart' : 'moveEnd']('character', textOffset);\n                }\n               \n                // return an IE text range\n                var textRange = domRange._document.body.createTextRange();\n                adoptEndPoint(textRange, domRange, true);\n                adoptEndPoint(textRange, domRange, false);\n                return textRange;\n            }\n        };\n\n        \n        document.caretRangeFromPoint = function caretRangeFromPoint(x,y) {\n            \n            // the accepted number of vertical backtracking, in CSS pixels\n            var IYDepth = 40;\n            \n            // try to create a text range at the specified location\n            var r = document.body.createTextRange();\n            for(var iy=IYDepth; iy; iy=iy-4) {\n                var ix = x; if(true) {\n                    try {\n                        r.moveToPoint(ix,iy+y-IYDepth); \n                        return TextRangeUtils.convertToDOMRange(r);\n                    } catch(ex) {}\n                }\n            }\n            \n            // if that fails, return the location just after the element located there\n            try {\n                \n                var elem = document.elementFromPoint(x-1,y-1);\n                var r = document.createRange();\n                r.setStartAfter(elem);\n                return r;\n                \n            } catch(ex) {\n                \n                return null;\n                \n            }\n        }\n    }\n}\n\n\n///\n/// helper function for moving ranges char by char\n///\n\nRange.prototype.myMoveOneCharLeft = function() {\n    var r = this;\n    \n    // move to the previous cursor location\n    if(r.endOffset > 0) {\n        \n        // if we can enter into the previous sibling\n        var previousSibling = r.endContainer.childNodes[r.endOffset-1];\n        if(previousSibling && previousSibling.lastChild) {\n            \n            // enter the previous sibling from its end\n            r.setEndAfter(previousSibling.lastChild);\n            \n        } else if(previousSibling && previousSibling.nodeType==previousSibling.TEXT_NODE) { // todo: lookup value\n            \n            // enter the previous text node from its end\n            r.setEnd(previousSibling, previousSibling.nodeValue.length);\n            \n        } else {\n            \n            // else move before that element\n            r.setEnd(r.endContainer, r.endOffset-1);\n            \n        }\n        \n    } else {\n        r.setEndBefore(r.endContainer);\n    }\n    \n}\n\nRange.prototype.myMoveOneCharRight = function() {\n    var r = this;\n    \n    // move to the previous cursor location\n    var max = (r.startContainer.nodeType==r.startContainer.TEXT_NODE ? r.startContainer.nodeValue.length : r.startContainer.childNodes.length)\n    if(r.startOffset < max) {\n        \n        // if we can enter into the next sibling\n        var nextSibling = r.endContainer.childNodes[r.endOffset];\n        if(nextSibling && nextSibling.firstChild) {\n            \n            // enter the next sibling from its start\n            r.setStartBefore(nextSibling.firstChild);\n            \n        } else if(nextSibling && nextSibling.nodeType==nextSibling.TEXT_NODE && nextSibling.nodeValue!='') { // todo: lookup value\n            \n            // enter the next text node from its start\n            r.setStart(nextSibling, 0);\n            \n        } else {\n            \n            // else move before that element\n            r.setStart(r.startContainer, r.startOffset+1);\n            \n        }\n        \n    } else {\n        r.setStartAfter(r.endContainer);\n    }\n    \n    // shouldn't be needed but who knows...\n    r.setEnd(r.startContainer, r.startOffset);\n    \n}\n\n\n///\n/// This functions is optimized to not yield inside a word in a text node\n///\nRange.prototype.myMoveTowardRight = function() {\n    var r = this;\n    \n    // move to the previous cursor location\n    var isTextNode = r.startContainer.nodeType==r.startContainer.TEXT_NODE;\n    var max = (isTextNode ? r.startContainer.nodeValue.length : r.startContainer.childNodes.length)\n    if(r.startOffset < max) {\n        \n        // if we can enter into the next sibling\n        var nextSibling = r.endContainer.childNodes[r.endOffset];\n        if(nextSibling && nextSibling.firstChild) {\n            \n            // enter the next sibling from its start\n            r.setStartBefore(nextSibling.firstChild);\n            \n        } else if(nextSibling && nextSibling.nodeType==nextSibling.TEXT_NODE && nextSibling.nodeValue!='') { // todo: lookup value\n            \n            // enter the next text node from its start\n            r.setStart(nextSibling, 0);\n            \n        } else if(isTextNode) {\n            \n            // move to the next non a-zA-Z symbol\n            var currentText = r.startContainer.nodeValue;\n            var currentOffset = r.startOffset;\n            var currentLetter = currentText[currentOffset++];\n            while(currentOffset < max && /^\\w$/.test(currentLetter)) {\n                currentLetter = currentText[currentOffset++];\n            }\n            r.setStart(r.startContainer, currentOffset);\n            \n        } else {\n            \n            // else move after that element\n            r.setStart(r.startContainer, r.startOffset+1);\n            \n        }\n        \n    } else {\n        r.setStartAfter(r.endContainer);\n    }\n    \n    // shouldn't be needed but who knows...\n    r.setEnd(r.startContainer, r.startOffset);\n    \n}\n\n\nRange.prototype.myMoveEndOneCharLeft = function() {\n    var r = this;\n    \n    // move to the previous cursor location\n    if(r.endOffset > 0) {\n        \n        // if we can enter into the previous sibling\n        var previousSibling = r.endContainer.childNodes[r.endOffset-1];\n        if(previousSibling && previousSibling.lastChild) {\n            \n            // enter the previous sibling from its end\n            r.setEndAfter(previousSibling.lastChild);\n            \n        } else if(previousSibling && previousSibling.nodeType==previousSibling.TEXT_NODE) { // todo: lookup value\n            \n            // enter the previous text node from its end\n            r.setEnd(previousSibling, previousSibling.nodeValue.length);\n            \n        } else {\n            \n            // else move before that element\n            r.setEnd(r.endContainer, r.endOffset-1);\n            \n        }\n        \n    } else {\n        r.setEndBefore(r.endContainer);\n    }\n    \n}\n\nRange.prototype.myMoveEndOneCharRight = function() {\n    var r = this;\n    \n    // move to the previous cursor location\n    var max = (r.endContainer.nodeType==r.endContainer.TEXT_NODE ? r.endContainer.nodeValue.length : r.endContainer.childNodes.length)\n    if(r.endOffset < max) {\n        \n        // if we can enter into the next sibling\n        var nextSibling = r.endContainer.childNodes[r.endOffset];\n        if(nextSibling && nextSibling.firstChild) {\n            \n            // enter the next sibling from its start\n            r.setEndBefore(nextSibling.firstChild);\n            \n        } else if(nextSibling && nextSibling.nodeType==nextSibling.TEXT_NODE) { // todo: lookup value\n            \n            // enter the next text node from its start\n            r.setEnd(nextSibling, 0);\n            \n        } else {\n            \n            // else move before that element\n            r.setEnd(r.endContainer, r.endOffset+1);\n            \n        }\n        \n    } else {\n        r.setEndAfter(r.endContainer);\n    }\n    \n}\n\n//\n// Get the *real* bounding client rect of the range\n// { therefore we need to fix some browser bugs... }\n//\nRange.prototype.myGetSelectionRect = function() {\n    \n    // get the browser's claimed rect\n    var rect = this.getBoundingClientRect();\n\t\n\t// HACK FOR ANDROID BROWSER AND OLD WEBKIT\n\tif(!rect) { \n\t\trect={top:0,right:0,bottom:0,left:0,width:0,height:0}; \n\t}\n    \n    // if the value seems wrong... (some browsers don't like collapsed selections)\n    if(this.collapsed && rect.top===0 && rect.bottom===0) {\n        \n        // select one char and infer location\n        var clone = this.cloneRange(); var collapseToLeft=false; clone.collapse(false); \n        \n        // the case where no char before is tricky...\n        if(clone.startOffset==0) {\n            \n            // let's move on char to the right\n            clone.myMoveTowardRight();\n            collapseToLeft=true;\n\n            // note: some browsers don't like selections\n            // that spans multiple containers, so we will\n            // iterate this process until we have one true\n            // char selected\n            clone.setStart(clone.endContainer, 0); \n            \n        } else {\n            \n            // else, just select the char before\n            clone.setStart(this.startContainer, this.startOffset-1);\n            collapseToLeft=false;\n            \n        }\n        \n        // get some real rect\n        var rect = clone.myGetSelectionRect();\n        \n        // compute final value\n        if(collapseToLeft) {\n            return {\n                \n                left: rect.left,\n                right: rect.left,\n                width: 0,\n                \n                top: rect.top,\n                bottom: rect.bottom,\n                height: rect.height\n                \n            }\n        } else {\n            return {\n                \n                left: rect.right,\n                right: rect.right,\n                width: 0,\n                \n                top: rect.top,\n                bottom: rect.bottom,\n                height: rect.height\n                \n            }\n        }\n        \n    } else {\n        return rect;\n    }\n    \n}\n\n// not sure it's needed but still\nif(!window.Element) window.Element=window.HTMLElement;\nif(!window.Node) window.Node = {};\n\n// make getBCR working on text nodes & stuff\nNode.getBoundingClientRect = function getBoundingClientRect(element) {\n    if (element.getBoundingClientRect) {\n        \n        var rect = element.getBoundingClientRect();\n        \n    } else {\n        \n        var range = document.createRange();\n        range.selectNode(element);\n        \n        var rect = range.getBoundingClientRect();\n        \n    }\n\t\n\t// HACK FOR ANDROID BROWSER AND OLD WEBKIT\n\tif(!rect) { \n\t\trect={top:0,right:0,bottom:0,left:0,width:0,height:0}; \n\t}\n\t\n\treturn rect;\n};\n\n\n// make getCR working on text nodes & stuff\nNode.getClientRects = function getClientRects(firstChild) {\n    if (firstChild.getBoundingClientRect) {\n        \n        return firstChild.getClientRects();\n        \n    } else {\n        \n        var range = document.createRange();\n        range.selectNode(firstChild);\n        \n        return range.getClientRects();\n        \n    }\n};\n\n// fix for IE (contains fails for text nodes...)\nNode.contains = function contains(parentNode,node) {\n    if(node.nodeType != 1) {\n        if(!node.parentNode) return false;\n        return node.parentNode==parentNode || parentNode.contains(node.parentNode);\n    } else {\n        return parentNode.contains(node);\n    }\n}\n\n//\n// get the bounding rect of the selection, including the bottom padding/marging of the previous element if required\n// { this is a special version for breaking algorithms that do not want to miss the previous element real size }\n//\nRange.prototype.myGetExtensionRect = function() {\n    \n    // this function returns the selection rect\n    // but does take care of taking in account \n    // the bottom-{padding/border} of the previous\n    // sibling element, to detect overflow points\n    // more accurately\n    \n    var rect = this.myGetSelectionRect();\n    var previousSibling = this.endContainer.childNodes[this.endOffset-1];\n    if(previousSibling) {\n        \n        // correct with the new take\n        var prevSibRect = Node.getBoundingClientRect(previousSibling);\n        var adjustedBottom = Math.max(rect.bottom,prevSibRect.bottom);\n        if(adjustedBottom == rect.bottom) return rect;\n        return {\n            \n            left: rect.left,\n            right: rect.right,\n            width: rect.width,\n            \n            top: rect.top,\n            bottom: adjustedBottom,\n            height: adjustedBottom - rect.top\n            \n        };\n        \n    } else if(rect.bottom==0 && this.endContainer.nodeType === 3) {\n        \n        // note that if we are in a text node, \n        // we may want to cover all the previous\n        // text in the node to avoid whitespace\n        // related bugs\n        \n        var onlyWhiteSpaceBefore = /^(\\s|\\n)*$/.test(this.endContainer.nodeValue.substr(0,this.endOffset));\n        if(onlyWhiteSpaceBefore) {\n            \n            // if we are in the fucking whitespace land, return first line\n            var prevSibRect = Node.getClientRects(this.endContainer)[0];\n            return prevSibRect;\n            \n        } else {\n            \n            // otherwhise, let's rely on previous chars\n            var auxiliaryRange = this.cloneRange();\n            auxiliaryRange.setStart(this.endContainer,0);\n            \n            // correct with the new take\n            var prevSibRect = auxiliaryRange.getBoundingClientRect();\n            var adjustedBottom = Math.max(rect.bottom,prevSibRect.bottom);\n            return {\n                \n                left: rect.left,\n                right: rect.right,\n                width: rect.width,\n                \n                top: rect.top,\n                bottom: adjustedBottom,\n                height: adjustedBottom - rect.top\n                \n            };\n            \n        }\n        \n    } else {\n        \n        return rect;\n        \n    }\n}\nrequire.define('src/css-regions/lib/range-extensions.js');","//\n// this module holds the big-picture actions of the polyfill\n//\nmodule.exports = (function(window, document) { \"use strict\";\n\t\n\tvar domEvents = require('src/core/dom-events.js');\n\tvar cssSyntax = require('src/core/css-syntax.js');\n\tvar cssCascade = require('src/core/css-cascade.js');\n\tvar cssBreak = require('src/core/css-break.js');\n\n\tvar cssRegionsHelpers = window.cssRegionsHelpers = {\n\t\t\n\t\t//\n\t\t// returns the previous sibling of the element\n\t\t// or the previous sibling of its nearest ancestor that has one\n\t\t//\n\t\tgetAllLevelPreviousSibling: function(e, region) {\n\t\t\tif(!e || e==region) return null;\n\t\t\t\n\t\t\t// find the nearest ancestor that has a previous sibling\n\t\t\twhile(!e.previousSibling) {\n\t\t\t\t\n\t\t\t\t// but bubble to the next avail ancestor\n\t\t\t\te = e.parentNode;\n\t\t\t\t\n\t\t\t\t// dont get over the bar\n\t\t\t\tif(!e || e==region) return null;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// return that sibling\n\t\t\treturn e.previousSibling;\n\t\t},\n\t\t\n\t\t//\n\t\t// prepares the element to become a css region\n\t\t//\n\t\tmarkNodesAsRegion: function(nodes,fast) {\n\t\t\tnodes.forEach(function(node) {\n\t\t\t\tnode.regionOverset = 'empty';\n\t\t\t\tnode.setAttribute('data-css-region',node.cssRegionsLastFlowFromName);\n\t\t\t\tcssRegionsHelpers.hideTextNodesFromFragmentSource([node]);\n\t\t\t\tnode.cssRegionsWrapper = node.cssRegionsWrapper || node.appendChild(document.createElement(\"cssregion\"));\n\t\t\t});\n\t\t},\n\t\t\n\t\t//\n\t\t// prepares the element to return to its normal css life\n\t\t//\n\t\tunmarkNodesAsRegion: function(nodes,fast) {\n\t\t\tnodes.forEach(function(node) {\n\t\t\t\t\n\t\t\t\t// restore regionOverset to its natural value\n\t\t\t\tnode.regionOverset = 'fit';\n\t\t\t\t\n\t\t\t\t// remove the current <cssregion> tag\n\t\t\t\ttry { node.cssRegionsWrapper && node.removeChild(node.cssRegionsWrapper); } \n\t\t\t\tcatch(ex) { setImmediate(function() { throw ex })}; \n\t\t\t\tnode.cssRegionsWrapper = undefined;\n\t\t\t\tdelete node.cssRegionsWrapper;\n\t\t\t\t\n\t\t\t\t// restore top-level texts that may have been hidden\n\t\t\t\tcssRegionsHelpers.unhideTextNodesFromFragmentSource([node]);\n\t\t\t\t\n\t\t\t\t// unmark as a region\n\t\t\t\tnode.removeAttribute('data-css-region');\n\t\t\t});\n\t\t},\n\t\t\n\t\t//\n\t\t// prepares the element for cloning (mainly give them an ID)\n\t\t//\n\t\tfragmentSourceIndex: 0,\n\t\tmarkNodesAsFragmentSource: function(nodes,ignoreRoot) {\n\t\t\t\n\t\t\tfunction visit(node,k) {\n\t\t\t\tvar child, next;\n\t\t\t\tswitch (node.nodeType) {\n\t\t\t\t\tcase 1: // Element node\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(typeof(k)==\"undefined\" || !ignoreRoot) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// mark as fragment source\n\t\t\t\t\t\t\tvar id = node.getAttributeNode('data-css-regions-fragment-source');\n\t\t\t\t\t\t\tif(!id) { node.setAttribute('data-css-regions-fragment-source', cssRegionsHelpers.fragmentSourceIndex++); }\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tnode.setAttribute('data-css-regions-cloning', true);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// expand list values\n\t\t\t\t\t\tif(node.tagName=='OL') cssRegionsHelpers.expandListValues(node);\n\t\t\t\t\t\tif(typeof(k)!=\"undefined\" && node.tagName==\"LI\") cssRegionsHelpers.expandListValues(node.parentNode);\n\t\t\t\t\t\t\n\t\t\t\t\tcase 9: // Document node\n\t\t\t\t\tcase 11: // Document fragment node\n\t\t\t\t\t\tchild = node.firstChild;\n\t\t\t\t\t\twhile (child) {\n\t\t\t\t\t\t\tnext = child.nextSibling;\n\t\t\t\t\t\t\tvisit(child);\n\t\t\t\t\t\t\tchild = next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tnodes.forEach(visit);\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// computes the \"value\" attribute of every LI element out there\n\t\t//\n\t\texpandListValues: function(OL) {\n\t\t\tif(OL.getAttribute(\"data-css-li-value-expanded\")) return;\n\t\t\tOL.setAttribute('data-css-li-value-expanded', true);\n\t\t\t\n\t\t\tif(OL.hasAttribute(\"reversed\")) {\n\t\t\t\t\n\t\t\t\tvar currentValue = OL.getAttribute(\"start\") ? parseInt(OL.getAttribute(\"start\")) : OL.childElementCount;\n\t\t\t\tvar increment = -1;\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tvar currentValue = OL.getAttribute(\"start\") ? parseInt(OL.getAttribute(\"start\")) : 1;\n\t\t\t\tvar increment = +1;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tvar LI = OL.firstElementChild; var LIV = null;\n\t\t\twhile(LI) {\n\t\t\t\tif(LI.tagName===\"LI\") {\n\t\t\t\t\tif(LIV=LI.getAttributeNode(\"value\")) {\n\t\t\t\t\t\tcurrentValue = parseInt(LIV.nodeValue);\n\t\t\t\t\t\tLI.setAttribute('data-css-old-value', currentValue)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLI.setAttribute(\"value\", currentValue);\n\t\t\t\t\t}\n\t\t\t\t\tcurrentValue = currentValue + increment;\n\t\t\t\t}\n\t\t\t\tLI = LI.nextElementSibling;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// reverts to automatic computation of the value of LI elements\n\t\t//\n\t\tunexpandListValues: function(OL) {\n\t\t\tif(!OL.hasAttribute('data-css-li-value-expanded')) return;\n\t\t\tOL.removeAttribute('data-css-li-value-expanded')\n\t\t\tvar LI = OL.firstElementChild; var LIV = null;\n\t\t\twhile(LI) {\n\t\t\t\tif(LI.tagName===\"LI\") {\n\t\t\t\t\tif(LIV=LI.getAttributeNode(\"data-css-old-value\")) {\n\t\t\t\t\t\tLI.removeAttributeNode(LIV);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLI.removeAttribute('value');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tLI = LI.nextElementSibling;\n\t\t\t}\n\t\t},\n\t\t\n\t\t//\n\t\t// makes empty text nodes which cannot get \"display: none\" applied to them\n\t\t//\n\t\tlistOfTextNodesForIE: [],\n\t\thideTextNodesFromFragmentSource: function(nodes) {\n\t\t\t\n\t\t\tfunction visit(node,k) {\n\t\t\t\tvar child, next;\n\t\t\t\tswitch (node.nodeType) {\n\t\t\t\t\tcase 3: // Text node\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(!node.parentNode.getAttribute('data-css-regions-fragment-source')) {\n\t\t\t\t\t\t\t// we have to remove their content the hard way...\n\t\t\t\t\t\t\tnode.cssRegionsSavedNodeValue = node.nodeValue;\n\t\t\t\t\t\t\tnode.nodeValue = \"\";\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// HACK: OTHERWISE IE WILL GC THE TEXTNODE AND RETURNS YOU\n\t\t\t\t\t\t\t// A FRESH TEXTNODE THE NEXT TIME WHERE YOUR EXPANDO\n\t\t\t\t\t\t\t// IS NOWHERE TO BE SEEN!\n\t\t\t\t\t\t\tif(navigator.userAgent.indexOf('MSIE')>0 || navigator.userAgent.indexOf(\"Trident\")>0) {\n\t\t\t\t\t\t\t\tif(cssRegionsHelpers.listOfTextNodesForIE.indexOf(node)==-1) {\n\t\t\t\t\t\t\t\t\tcssRegionsHelpers.listOfTextNodesForIE.push(node);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tcase 1: // Element node\n\t\t\t\t\t\tif(node.hasAttribute('data-css-regions-cloning')) {\n\t\t\t\t\t\t\tnode.removeAttribute('data-css-regions-cloning');\n\t\t\t\t\t\t\tnode.setAttribute('data-css-regions-cloned', true);\n\t\t\t\t\t\t\tif(node.currentStyle) node.currentStyle.display.toString(); // IEFIX FOR BAD STYLE RECALC\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(typeof(k)==\"undefined\") return;\n\t\t\t\t\t\t\n\t\t\t\t\tcase 9: // Document node\n\t\t\t\t\tcase 11: // Document fragment node                    \n\t\t\t\t\t\tchild = node.firstChild;\n\t\t\t\t\t\twhile (child) {\n\t\t\t\t\t\t\tnext = child.nextSibling;\n\t\t\t\t\t\t\tvisit(child);\n\t\t\t\t\t\t\tchild = next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tnodes.forEach(visit);\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// makes emptied text nodes visible again\n\t\t//\n\t\tunhideTextNodesFromFragmentSource: function(nodes) {\n\t\t\t\n\t\t\tfunction visit(node) {\n\t\t\t\tvar child, next;\n\t\t\t\tswitch (node.nodeType) {\n\t\t\t\t\tcase 3: // Text node\n\t\t\t\t\t\t\n\t\t\t\t\t\t// we have to remove their content the hard way...\n\t\t\t\t\t\tif(\"cssRegionsSavedNodeValue\" in node) {\n\t\t\t\t\t\t\tnode.nodeValue = node.cssRegionsSavedNodeValue;\n\t\t\t\t\t\t\tdelete node.cssRegionsSavedNodeValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tcase 1: // Element node\n\t\t\t\t\t\tif(typeof(k)==\"undefined\") return;\n\t\t\t\t\t\t\n\t\t\t\t\tcase 9: // Document node\n\t\t\t\t\tcase 11: // Document fragment node                    \n\t\t\t\t\t\tchild = node.firstChild;\n\t\t\t\t\t\twhile (child) {\n\t\t\t\t\t\t\tnext = child.nextSibling;\n\t\t\t\t\t\t\tvisit(child);\n\t\t\t\t\t\t\tchild = next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tnodes.forEach(visit);\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// prepares the content elements to return to ther normal css life\n\t\t//\n\t\tunmarkNodesAsFragmentSource: function(nodes) {\n\t\t\t\n\t\t\tfunction visit(node,k) {\n\t\t\t\tvar child, next;\n\t\t\t\tswitch (node.nodeType) {\n\t\t\t\t\tcase 3: // Text node\n\t\t\t\t\t\t\n\t\t\t\t\t\t// we have to reinstall their content the hard way...\n\t\t\t\t\t\tif(\"cssRegionsSavedNodeValue\" in node) {\n\t\t\t\t\t\t\tnode.nodeValue = node.cssRegionsSavedNodeValue;\n\t\t\t\t\t\t\tdelete node.cssRegionsSavedNodeValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1: // Element node\n\t\t\t\t\t\tnode.removeAttribute('data-css-regions-cloned');\n\t\t\t\t\t\tnode.removeAttribute('data-css-regions-fragment-source');\n\t\t\t\t\t\tif(node.currentStyle) node.currentStyle.display.toString(); // IEFIX FOR BAD STYLE RECALC\n\t\t\t\t\t\tif(node.tagName==\"OL\") cssRegionsHelpers.unexpandListValues(node);\n\t\t\t\t\t\tif(typeof(k)!=\"undefined\" && node.tagName==\"LI\") cssRegionsHelpers.unexpandListValues(node.parentNode);\n\t\t\t\t\t\t\n\t\t\t\t\tcase 9: // Document node\n\t\t\t\t\tcase 11: // Document fragment node\n\t\t\t\t\t\tchild = node.firstChild;\n\t\t\t\t\t\twhile (child) {\n\t\t\t\t\t\t\tnext = child.nextSibling;\n\t\t\t\t\t\t\tvisit(child);\n\t\t\t\t\t\t\tchild = next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tnodes.forEach(visit);\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// marks cloned content as fragment instead of as fragment source (basically)\n\t\t//\n\t\ttransformFragmentSourceToFragments: function(nodes) {\n\t\t\t\n\t\t\tfunction visit(node) {\n\t\t\t\tvar child, next;\n\t\t\t\tswitch (node.nodeType) {\n\t\t\t\t\tcase 1: // Element node\n\t\t\t\t\t\tvar id = node.getAttribute('data-css-regions-fragment-source');\n\t\t\t\t\t\tnode.removeAttribute('data-css-regions-fragment-source');\n\t\t\t\t\t\tnode.removeAttribute('data-css-regions-cloning');\n\t\t\t\t\t\tnode.removeAttribute('data-css-regions-cloned');\n\t\t\t\t\t\tnode.setAttribute('data-css-regions-fragment-of', id);\n\t\t\t\t\t\tif(node.id) node.id += \"--fragment\";\n\t\t\t\t\t\t\n\t\t\t\t\tcase 9: // Document node\n\t\t\t\t\tcase 11: // Document fragment node\n\t\t\t\t\t\tchild = node.firstChild;\n\t\t\t\t\t\twhile (child) {\n\t\t\t\t\t\t\tnext = child.nextSibling;\n\t\t\t\t\t\t\tvisit(child);\n\t\t\t\t\t\t\tchild = next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tnodes.forEach(visit);\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// removes some invisible text nodes from the tree\n\t\t// (useful if you don't want to face browser bugs when dealing with them)\n\t\t//\n\t\tembedTrailingWhiteSpaceNodes: function(fragment) {\n\t\t\t\n\t\t\tvar onlyWhiteSpace = /^\\s*$/;\n\t\t\tfunction visit(node) {\n\t\t\t\tvar child, next;\n\t\t\t\tswitch (node.nodeType) {\n\t\t\t\t\tcase 3: // Text node\n\t\t\t\t\t\t\n\t\t\t\t\t\t// we only remove nodes at the edges\n\t\t\t\t\t\tif (!node.previousSibling) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// we only remove nodes if their parent doesn't preserve whitespace\n\t\t\t\t\t\t\tif (getComputedStyle(node.parentNode).whiteSpace.substring(0,3)!==\"pre\") {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// only remove pure whitespace nodes\n\t\t\t\t\t\t\t\tif (onlyWhiteSpace.test(node.nodeValue)) {\n\t\t\t\t\t\t\t\t\tnode.parentNode.setAttribute('data-whitespace-before',node.nodeValue);\n\t\t\t\t\t\t\t\t\tnode.parentNode.removeChild(node);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// we only remove nodes at the edges\n\t\t\t\t\t\tif (!node.nextSibling) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// we only remove nodes if their parent doesn't preserve whitespace\n\t\t\t\t\t\t\tif (getComputedStyle(node.parentNode).whiteSpace.substring(0,3)!==\"pre\") {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// only remove pure whitespace nodes\n\t\t\t\t\t\t\t\tif (onlyWhiteSpace.test(node.nodeValue)) {\n\t\t\t\t\t\t\t\t\tnode.parentNode.setAttribute('data-whitespace-after',node.nodeValue);\n\t\t\t\t\t\t\t\t\tnode.parentNode.removeChild(node);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1: // Element node\n\t\t\t\t\tcase 9: // Document node\n\t\t\t\t\tcase 11: // Document fragment node\n\t\t\t\t\t\tchild = node.firstChild;\n\t\t\t\t\t\twhile (child) {\n\t\t\t\t\t\t\tnext = child.nextSibling;\n\t\t\t\t\t\t\tvisit(child);\n\t\t\t\t\t\t\tchild = next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvisit(fragment);\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// recover the previously removed invisible text nodes\n\t\t//\n\t\tunembedTrailingWhiteSpaceNodes: function(fragment) {\n\t\t\t\n\t\t\tvar onlyWhiteSpace = /^\\s*$/;\n\t\t\tfunction visit(node) {\n\t\t\t\tvar child, next;\n\t\t\t\tswitch (node.nodeType) {\n\t\t\t\t\tcase 1: // Element node\n\t\t\t\t\t\tvar txt = \"\";\n\t\t\t\t\t\tif(txt = node.getAttribute('data-whitespace-before')) {\n\t\t\t\t\t\t\tif(node.getAttribute('data-starting-fragment')=='' && node.getAttribute('data-special-starting-fragment','')) {\n\t\t\t\t\t\t\t\tnode.insertBefore(document.createTextNode(txt),node.firstChild);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnode.removeAttribute('data-whitespace-before')\n\t\t\t\t\t\tif(txt = node.getAttribute('data-whitespace-after')) {\n\t\t\t\t\t\t\tif(node.getAttribute('data-continued-fragment')=='' && node.getAttribute('data-special-continued-fragment','')) {\n\t\t\t\t\t\t\t\tnode.insertAfter(document.createTextNode(txt),node.lastChild);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnode.removeAttribute('data-whitespace-after')\n\t\t\t\t\t\t\n\t\t\t\t\tcase 9: // Document node\n\t\t\t\t\tcase 11: // Document fragment node\n\t\t\t\t\t\tchild = node.firstChild;\n\t\t\t\t\t\twhile (child) {\n\t\t\t\t\t\t\tnext = child.nextSibling;\n\t\t\t\t\t\t\tvisit(child);\n\t\t\t\t\t\t\tchild = next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvisit(fragment);\n\t\t\t\n\t\t},\n\t\t\n\t\t///\n\t\t/// walk the two trees the same way, and copy all the styles\n\t\t/// BEWARE: if the DOMs are different, funny things will happen\n\t\t/// NOTE: this function will also remove elements put in another flow\n\t\t///\n\t\tcopyStyle: function(root1, root2) {\n\t\t\t\n\t\t\tfunction visit(node1, node2, isRoot) {\n\t\t\t\tvar child1, next1, child2, next2;\n\t\t\t\tswitch (node1.nodeType) {\n\t\t\t\t\tcase 1: // Element node\n\t\t\t\t\t\t\n\t\t\t\t\t\t// firstly, setup a cache of all css properties on the element\n\t\t\t\t\t\tvar matchedRules = (node1.currentStyle && !window.opera) ? undefined : cssCascade.findAllMatchingRules(node1)\n\t\t\t\t\t\t\n\t\t\t\t\t\t// and compute the value of all css properties\n\t\t\t\t\t\tvar properties = cssCascade.allCSSProperties || cssCascade.getAllCSSProperties();\n\t\t\t\t\t\tfor(var p=properties.length; p--; ) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// if the property is computation-safe, use the computed value\n\t\t\t\t\t\t\tif(!(properties[p] in cssCascade.computationUnsafeProperties) && properties[p][0]!='-') {\n\t\t\t\t\t\t\t\tvar style = getComputedStyle(node1).getPropertyValue(properties[p]);\n\t\t\t\t\t\t\t\tvar defaultStyle = cssCascade.getDefaultStyleForTag(node1.tagName).getPropertyValue(properties[p]);\n\t\t\t\t\t\t\t\tif(style != defaultStyle) node2.style.setProperty(properties[p], style)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// otherwise, get the element's specified value\n\t\t\t\t\t\t\tvar cssValue = cssCascade.getSpecifiedStyle(node1, properties[p], matchedRules);\n\t\t\t\t\t\t\tif(cssValue && cssValue.length) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// if we have a specified value, let's use it\n\t\t\t\t\t\t\t\tnode2.style.setProperty(properties[p], cssValue.toCSSString());\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} else if(isRoot && node1.parentNode && properties[p][0] != '-') {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// NOTE: the root will be detached from its parent\n\t\t\t\t\t\t\t\t// Therefore, we have to inherit styles from it (oh no!)\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// TODO: create a list of inherited properties\n\t\t\t\t\t\t\t\tif(!(properties[p] in cssCascade.inheritingProperties)) continue;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// if the property is computation-safe, use the computed value\n\t\t\t\t\t\t\t\tif((properties[p]==\"font-size\") || (!(properties[p] in cssCascade.computationUnsafeProperties) && properties[p][0]!='-')) {\n\t\t\t\t\t\t\t\t\tvar style = getComputedStyle(node1).getPropertyValue(properties[p]);\n\t\t\t\t\t\t\t\t\tnode2.style.setProperty(properties[p], style);\n\t\t\t\t\t\t\t\t\t//var parentStyle = style; try { parentStyle = getComputedStyle(node1.parentNode).getPropertyValue(properties[p]) } catch(ex){}\n\t\t\t\t\t\t\t\t\t//var defaultStyle = cssCascade.getDefaultStyleForTag(node1.tagName).getPropertyValue(properties[p]);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t//if(style === parentStyle) {\n\t\t\t\t\t\t\t\t\t//  node2.style.setProperty(properties[p], style)\n\t\t\t\t\t\t\t\t\t//}\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// otherwise, get the parent's specified value\n\t\t\t\t\t\t\t\tvar cssValue = cssCascade.getSpecifiedStyle(node1, properties[p], matchedRules);\n\t\t\t\t\t\t\t\tif(cssValue && cssValue.length) {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t// if we have a specified value, let's use it\n\t\t\t\t\t\t\t\t\tnode2.style.setProperty(properties[p], cssValue.toCSSString());\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// now, let's work on ::after and ::before\n\t\t\t\t\t\tvar importPseudo = function(node1,node2,pseudo) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// we'll need to use getSpecifiedStyle here as the pseudo thing is slow\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\tvar mayExist = !!cssCascade.findAllMatchingRulesWithPseudo(node1,pseudo.substr(1)).length;\n\t\t\t\t\t\t\tif(!mayExist) return;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvar pseudoStyle = getComputedStyle(node1,pseudo);\n\t\t\t\t\t\t\tif(pseudoStyle.content!='none'){\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// let's create a stylesheet for the element\n\t\t\t\t\t\t\t\tvar stylesheet = document.createElement('style');\n\t\t\t\t\t\t\t\tstylesheet.setAttribute('data-no-css-polyfill',true);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// compute the value of all css properties\n\t\t\t\t\t\t\t\tvar node2style = \"\";\n\t\t\t\t\t\t\t\tvar properties = cssCascade.allCSSProperties || cssCascade.getAllCSSProperties();\n\t\t\t\t\t\t\t\tfor(var p=properties.length; p--; ) {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t// we always use the computed value, because we don't have better\n\t\t\t\t\t\t\t\t\tvar style = pseudoStyle.getPropertyValue(properties[p]);\n\t\t\t\t\t\t\t\t\tnode2style += properties[p]+\":\"+style+\";\";\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tstylesheet.textContent = (\n\t\t\t\t\t\t\t\t\t'[data-css-regions-fragment-of=\"' + node1.getAttribute('data-css-regions-fragment-source') + '\"]' \n\t\t\t\t\t\t\t\t\t+':not([data-css-regions-starting-fragment]):not([data-css-regions-special-starting-fragment])'\n\t\t\t\t\t\t\t\t\t+':'+pseudo+'{'\n\t\t\t\t\t\t\t\t\t+node2style\n\t\t\t\t\t\t\t\t\t+\"}\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tnode2.parentNode.insertBefore(stylesheet, node2);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\timportPseudo(node1,node2,\":before\");\n\t\t\t\t\t\timportPseudo(node1,node2,\":after\");\n\t\t\t\t\t\t\n\t\t\t\t\t\t// retarget events\n\t\t\t\t\t\tcssRegionsHelpers.retargetEvents(node1,node2);\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\tcase 9: // Document node\n\t\t\t\t\tcase 11: // Document fragment node\n\t\t\t\t\t\tchild1 = node1.firstChild;\n\t\t\t\t\t\tchild2 = node2.firstChild;\n\t\t\t\t\t\twhile (child1) {\n\t\t\t\t\t\t\tnext1 = child1.nextSibling;\n\t\t\t\t\t\t\tnext2 = child2.nextSibling;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// decide between process style or hide\n\t\t\t\t\t\t\tif(child1.cssRegionsLastFlowIntoName && child1.cssRegionsLastFlowIntoType===\"element\") {\n\t\t\t\t\t\t\t\tnode2.removeChild(child2);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvisit(child1, child2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tchild1 = next1;\n\t\t\t\t\t\t\tchild2 = next2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvisit(root1, root2, true);\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// make sure the most critical events still fire in the fragment source\n\t\t// even if the browser initially fire them on the fragments\n\t\t//\n\t\tretargetEvents: function retargetEvents(node1,node2) {\n\t\t\t\n\t\t\tvar retargetEvent = \"cssRegionsHelpers.retargetEvent(this,event)\";\n\t\t\tnode2.setAttribute(\"onclick\", retargetEvent);\n\t\t\tnode2.setAttribute(\"ondblclick\", retargetEvent);\n\t\t\tnode2.setAttribute(\"onmousedown\", retargetEvent);\n\t\t\tnode2.setAttribute(\"onmouseup\", retargetEvent);\n\t\t\tnode2.setAttribute(\"onmousein\", retargetEvent);\n\t\t\tnode2.setAttribute(\"onmouseout\", retargetEvent);\n\t\t\tnode2.setAttribute(\"onmouseenter\", retargetEvent);\n\t\t\tnode2.setAttribute(\"onmouseleave\", retargetEvent);\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// single hub for event retargeting operations.\n\t\t//\n\t\tretargetEvent: function retargeEvent(node2,e) {\n\t\t\t\n\t\t\t// get the node we should fire the event on\n\t\t\tvar node1 = (\n\t\t\t\t(node2.cssRegionsFragmentSource) ||\n\t\t\t\t(node2.cssRegionsFragmentSource=document.querySelector('[data-css-regions-fragment-source=\"' + node2.getAttribute('data-css-regions-fragment-of') + '\"]'))\n\t\t\t);\n\t\t\t\n\t\t\tif(node1) {\n\t\t\t\n\t\t\t\t// dispatch the event on the real node\n\t\t\t\tvar ne = domEvents.cloneEvent(e);\n\t\t\t\tnode1.dispatchEvent(ne);\n\t\t\t\t\n\t\t\t\t// prevent the event to fire on the region\n\t\t\t\te.stopImmediatePropagation ? e.stopImmediatePropagation() : e.stopPropagation();\n\t\t\t\t\n\t\t\t\t// make sure to cancel the event if required\n\t\t\t\tif(ne.isDefaultPrevented || ne.defaultPrevented) { e.preventDefault(); return false; }\n\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t};\n\t\n\treturn cssRegionsHelpers;\n\t\n})(window, document);\nrequire.define('src/css-regions/lib/helpers.js');","//\n// this module holds the front-facing features of the polyfill\n//\nmodule.exports = (function(window, document, cssRegions) { \"use strict\";\n\n\tvar domEvents = require('src/core/dom-events.js');\n\tvar cssSyntax = require('src/core/css-syntax.js');\n\tvar cssCascade = require('src/core/css-cascade.js');\n\tvar cssBreak = require('src/core/css-break.js');\n\tvar cssRegionsHelpers = require('src/css-regions/lib/helpers.js');\n\tvar ES = require('src/core/dom-experimental-event-streams.js');\n\n\t// \n\t// this class contains flow-relative data field\n\t// \n\tcssRegions.Flow = function NamedFlow(name) {\n\t\t\n\t\t// TODO: force immediate relayout if someone ask the overset properties\n\t\t// and the layout has been deemed wrong (still isn't a proof of correctness but okay)\n\t\t\n\t\t// define the flow name\n\t\tthis.name = name; Object.defineProperty(this, \"name\", {get: function() { return name; }});\n\t\t\n\t\t// define the overset status\n\t\tthis.overset = false;\n\t\t\n\t\t// define the first empty region\n\t\tthis.firstEmptyRegionIndex = -1;\n\t\t\n\t\t// elements poured into the flow\n\t\tthis.content = []; this.lastContent = [];\n\t\t\n\t\t// elements that consume this flow\n\t\tthis.regions = []; this.lastRegions = [];\n\t\t\n\t\t// event handlers\n\t\tthis.eventListeners = {\n\t\t\t\"regionfragmentchange\": [],\n\t\t\t\"regionoversetchange\": [],\n\t\t};\n\t\t\n\t\t// this function is used to work with dom event streams\n\t\tvar This=this; This.update = function(stream) {\n\t\t\tstream.schedule(This.update); This.relayout();\n\t\t};\n\t\t\n\t\t// register to style changes already\n\t\tThis.lastStylesheetAdded = 0;\n\t\tcssCascade.addEventListener('stylesheetadded', function() {\n\t\t\tif(This.lastStylesheetAdded - Date() > 100) {\n\t\t\t\tThis.lastStylesheetAdded = +Date();\n\t\t\t\tThis.relayout();\n\t\t\t} else {\n\t\t\t\tcssConsole.warn(\"Please don't add stylesheets as a response to region events. Operation cancelled.\")\n\t\t\t}\n\t\t});\n\t\t\n\t\t// a small counter to avoid enter retry loops\n\t\tThis.failedLayoutCount = 0;\n\t\t\n\t\t// some other fields\n\t\tThis.lastEventRAF = 0;\n\t\tThis.restartLayout = false;\n\t}\n\t\t\n\tcssRegions.Flow.prototype.removeFromContent = function(element) {\n\t\t\n\t\t// clean up stuff\n\t\tthis.removeEventListenersOf(element);\n\t\t\n\t\t// remove reference\n\t\tvar index = this.content.indexOf(element);\n\t\tif(index>=0) { this.content.splice(index,1); }\n\t\t\n\t};\n\n\tcssRegions.Flow.prototype.removeFromRegions = function(element) {\n\t\t\n\t\t// clean up stuff\n\t\tthis.removeEventListenersOf(element);\n\t\t\n\t\t// remove reference\n\t\tvar index = this.regions.indexOf(element);\n\t\tif(index>=0) { this.regions.splice(index,1); }\n\t\t\n\t};\n\n\tcssRegions.Flow.prototype.addToContent = function(element) {\n\t\t\n\t\t// handle trivial cases real quick\n\t\tvar content = this.content; \n\t\tif(content.length==0 || content[content.length-1].nextSibling === element) {\n\t\t\tcontent.push(element);\n\t\t\treturn;\n\t\t}\n\t\tif(content[0].previousSibling === element) {\n\t\t\tcontent.unshift(element);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// walk the tree to find an element inside the content chain\n\t\tvar currentNodeIndex = -1;\n\t\tvar treeWalker = document.createTreeWalker(\n\t\t\tdocument.documentElement,\n\t\t\tNodeFilter.SHOW_ELEMENT,\n\t\t\tfunction(node) { \n\t\t\t\treturn (currentNodeIndex = content.indexOf(node)) >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP; \n\t\t\t},\n\t\t\tfalse\n\t\t); \n\t\t\n\t\t// which by the way has to be after the considered element\n\t\ttreeWalker.currentNode = element;\n\t\t\n\t\t// if we find such node\n\t\tif(treeWalker.nextNode()) {\n\t\t\t\n\t\t\t// insert the element at his current location\n\t\t\tcontent.splice(currentNodeIndex,0,element);\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\t// add the new element to the end of the array\n\t\t\tcontent.push(element);\n\t\t\t\n\t\t}\n\n\t};\n\n\tcssRegions.Flow.prototype.addToRegions = function(element) {\n\t\t\n\t\t// walk the tree to find an element inside the region chain\n\t\tvar regions = this.regions;\n\t\tvar treeWalker = document.createTreeWalker(\n\t\t\tdocument.documentElement,\n\t\t\tNodeFilter.SHOW_ELEMENT,\n\t\t\tfunction(node) { \n\t\t\t\treturn regions.indexOf(node) >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT; \n\t\t\t},\n\t\t\tfalse\n\t\t);\n\t\t\n\t\t// which by the way has to be after the considered element\n\t\ttreeWalker.currentNode = element;\n\t\t\n\t\t// if we find such node\n\t\tif(treeWalker.nextNode()) {\n\t\t\t\n\t\t\t// insert the element at his current location\n\t\t\tregions.splice(this.regions.indexOf(treeWalker.currentNode),0,element);\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\t// add the new element to the end of the array\n\t\t\tregions.push(element);\n\t\t}\n\t\t\n\t};\n\n\tcssRegions.Flow.prototype.generateContentFragment = function() {\n\t\tvar fragment = document.createDocumentFragment(); var This=this;\n\n\t\t// add copies of all due content\n\t\tfor(var i=0; i<this.content.length; i++) {\n\t\t\tvar element = this.content[i];\n\t\t\t\n\t\t\t// \n\t\t\t// STEP 1: IDENTIFY FRAGMENT SOURCES AS SUCH\n\t\t\t//\n\t\t\tcssRegionsHelpers.markNodesAsFragmentSource([element], element.cssRegionsLastFlowIntoType==\"content\");\n\t\t\t\n\t\t\t\n\t\t\t//\n\t\t\t// STEP 2: CLONE THE FRAGMENT SOURCES\n\t\t\t// \n\t\t\t\n\t\t\t// depending on the requested behavior\n\t\t\tif(element.cssRegionsLastFlowIntoType==\"element\") {\n\t\t\t\t\n\t\t\t\t\t// add the element\n\t\t\t\t\tvar el = element;\n\t\t\t\t\tvar elClone = el.cloneNode(true);\n\t\t\t\t\tvar elToInsert = elClone; if(elToInsert.tagName==\"LI\") {\n\t\t\t\t\t\telToInsert = document.createElement(el.parentNode.tagName);\n\t\t\t\t\t\telToInsert.style.margin=\"0\";\n\t\t\t\t\t\telToInsert.style.padding=\"0\";\n\t\t\t\t\t\telToInsert.appendChild(elClone);\n\t\t\t\t\t}\n\t\t\t\t\tfragment.appendChild(elToInsert);\n\t\t\t\t\t\n\t\t\t\t\t// clone the style\n\t\t\t\t\tcssRegionsHelpers.copyStyle(el, elClone);\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t// add current children\n\t\t\t\tvar el = element.firstChild; while(el) {\n\t\t\t\t\t\n\t\t\t\t\t// add the element\n\t\t\t\t\tvar elClone = el.cloneNode(true);\n\t\t\t\t\tvar elToInsert = elClone; if(elToInsert.tagName==\"LI\") {\n\t\t\t\t\t\telToInsert = document.createElement(el.parentNode.tagName);\n\t\t\t\t\t\telToInsert.style.margin=\"0\";\n\t\t\t\t\t\telToInsert.style.padding=\"0\";\n\t\t\t\t\t\telToInsert.appendChild(elClone);\n\t\t\t\t\t}\n\t\t\t\t\tfragment.appendChild(elToInsert);\n\t\t\t\t\t\n\t\t\t\t\t// clone the style\n\t\t\t\t\tcssRegionsHelpers.copyStyle(el, elClone);\n\t\t\t\t\t\n\t\t\t\t\tel = el.nextSibling;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t//\n\t\t// STEP 3: HIDE TEXT NODES IN FRAGMENT SOURCES\n\t\t//\n\t\tcssRegionsHelpers.hideTextNodesFromFragmentSource(this.content);\n\t\t\n\t\t//\n\t\t// STEP 4: CONVERT CLONED FRAGMENT SOURCES INTO TRUE FRAGMENTS\n\t\t//\n\t\tcssRegionsHelpers.transformFragmentSourceToFragments(\n\t\t\tArray.prototype.slice.call(fragment.childNodes,0)\n\t\t)\n\t\t\n\t\t\n\t\t//\n\t\t// CLONED CONTENT IS READY!\n\t\t//\n\t\treturn fragment;\n\t}\n\n\tcssRegions.Flow.prototype.relayout = function() {\n\t\tvar This = this;\n\t\t\n\t\t// prevent previous relayouts from eventing\n\t\tcancelAnimationFrame(This.lastEventRAF);\n\t\t\n\t\t// batch relayout queries\n\t\tif(This.relayoutScheduled) { return; }\n\t\tif(This.relayoutInProgress) { This.restartLayout=true; return; }\n\t\tThis.relayoutScheduled = true;\n\t\trequestAnimationFrame(function() { This._relayout() });\n\t\t\n\t}\n\n\tcssRegions.Flow.prototype._relayout = function(data){\n\t\tvar This=this;\n\t\t\n\t\ttry {\n\t\t\t\n\t\t\t//\n\t\t\t// note: it is recommended to look at the beautiful \n\t\t\t// drawings I made before attempting to understand\n\t\t\t// this stuff. If you don't have them, ask me.\n\t\t\t//\n\t\t\tcssConsole.log(\"starting a new relayout for \"+This.name);\n\t\t\tThis.relayoutInProgress=true; This.relayoutScheduled=false;\n\t\t\tThis.lastRelayout = +new Date();\n\t\t\t//debugger;\n\t\t\t\n\t\t\t// NOTE: we recover the scroll position in case the browser mess it up\n\t\t\tvar docElmScrollTop = data && data.docElmScrollTop ? data.docElmScrollTop : document.documentElement.scrollTop;\n\t\t\tvar docBdyScrollTop = data && data.docBdyScrollTop ? data.docBdyScrollTop : document.body.scrollTop;\n\t\t\t\n\t\t\t\n\t\t\t//\n\t\t\t// STEP 1: REMOVE PREVIOUS EVENT LISTENERS\n\t\t\t//\n\t\t\t\n\t\t\t// remove the listeners from everything\n\t\t\tThis.removeEventListenersOf(This.lastRegions);\n\t\t\tThis.removeEventListenersOf(This.lastContent);\n\t\t\tcancelAnimationFrame(This.lastEventRAF);\n\t\t\t\n\t\t\t\n\t\t\t//\n\t\t\t// STEP 2: RESTORE CONTENT/REGIONS TO A CLEAN STATE\n\t\t\t//\n\t\t\t\n\t\t\t// detect elements being removed of the document\n\t\t\tThis.regions = This.regions.filter(function(e) { return document.documentElement.contains(e); })\n\t\t\tThis.content = This.content.filter(function(e) { return document.documentElement.contains(e); })\n\t\t\t\n\t\t\t// cleanup previous layout\n\t\t\tcssRegionsHelpers.unmarkNodesAsRegion(This.lastRegions); This.lastRegions = This.regions.slice(0);\n\t\t\tcssRegionsHelpers.unmarkNodesAsFragmentSource(This.lastContent); This.lastContent = This.content.slice(0);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t//\n\t\t\t// STEP 3: EMPTY ALL REGIONS\n\t\t\t// ADD WRAPPER FOR FLOW CONTENT\n\t\t\t// PREPARE FOR CONTENT CLONING\n\t\t\t//\n\t\t\t\n\t\t\t// empty all the regions\n\t\t\tcssRegionsHelpers.markNodesAsRegion(This.regions);\n\t\t\t\n\t\t\t// create a fresh list of the regions\n\t\t\tvar regionStack = This.regions.slice(0).reverse();\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t//\n\t\t\t// STEP 4: CLONE THE CONTENT\n\t\t\t// ADD METADATA TO CLONED CONTENT\n\t\t\t// HIDE FLOW CONTENT AT INITIAL POSITION\n\t\t\t//\n\t\t\t\n\t\t\t// create a fresh list of the content\n\t\t\t// compute the style of all source elements\n\t\t\t// generate stylesheets for those rules\n\t\t\tvar contentFragment = This.generateContentFragment();\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t//\n\t\t\t// STEP 5: POUR CONTENT INTO THE REGIONS\n\t\t\t//\n\t\t\t\n\t\t\t// layout this stuff\n\t\t\tcssRegions.layoutContent(regionStack, contentFragment, {\n\t\t\t\tonprogress: function(continueLayout) {\n\t\t\t\t\t\n\t\t\t\t\t// NOTE: we recover the scroll position in case the browser mess it up\n\t\t\t\t\tdocument.documentElement.scrollTop = docElmScrollTop;\n\t\t\t\t\tdocument.body.scrollTop = docBdyScrollTop;\n\t\t\t\t\t\n\t\t\t\t\t// NOTE: if the current layout goes nowhere, start a new one already\n\t\t\t\t\tif(This.restartLayout) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tThis.relayoutInProgress = false;\n\t\t\t\t\t\tThis.failedLayoutCount = 0;\n\t\t\t\t\t\tThis.restartLayout = false;\n\t\t\t\t\t\tThis._relayout({\n\t\t\t\t\t\t\tdocElmScrollTop: docElmScrollTop,\n\t\t\t\t\t\t\tdocBdyScrollTop: docBdyScrollTop\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t\tsetImmediate(continueLayout);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t},\n\t\t\t\tondone: function onLayoutDone(overset) {\n\t\t\t\t\n\t\t\t\t\tThis.overset = overset;\n\t\t\t\t\tThis.firstEmptyRegionIndex = This.regions.length-1; while(This.regions[This.firstEmptyRegionIndex]) {\n\t\t\t\t\t\n\t\t\t\t\t\t// tell whether the region is empty\n\t\t\t\t\t\tvar isEmpty = false;\n\t\t\t\t\t\tisEmpty = isEmpty || !This.regions[This.firstEmptyRegionIndex].cssRegionsWrapper;\n\t\t\t\t\t\tisEmpty = isEmpty || !This.regions[This.firstEmptyRegionIndex].cssRegionsWrapper.firstChild;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// if the region is not empty\n\t\t\t\t\t\tif(!isEmpty) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// the first empty region if the next one, if it exists\n\t\t\t\t\t\t\tif((++This.firstEmptyRegionIndex)==This.regions.length) {\n\t\t\t\t\t\t\t\tThis.firstEmptyRegionIndex = -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t// else, let's try the previous region\n\t\t\t\t\t\t\tThis.firstEmptyRegionIndex--; \n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t//\n\t\t\t\t\t// STEP 6: REGISTER TO UPDATE EVENTS\n\t\t\t\t\t//\n\t\t\t\t\t\n\t\t\t\t\t// make sure regions update are taken in consideration\n\t\t\t\t\tif(window.MutationObserver) {\n\t\t\t\t\t\tThis.addEventListenersTo(This.content);\n\t\t\t\t\t\tThis.addEventListenersTo(This.regions);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// the other browsers don't get this as acurately\n\t\t\t\t\t\t// but that shouldn't be that of an issue for 99% of the cases\n\t\t\t\t\t\tsetImmediate(function() {\n\t\t\t\t\t\t\tThis.addEventListenersTo(This.content);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t//\n\t\t\t\t\t// STEP 7: FIRE SOME EVENTS\n\t\t\t\t\t//\n\t\t\t\t\tif(This.regions.length > 0 && !This.restartLayout) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// before doing anything, let's check our stuff is consistent\n\t\t\t\t\t\tvar isBuggy = false;\n\t\t\t\t\t\tisBuggy = isBuggy || This.regions.some(function(e) { return !document.documentElement.contains(e); })\n\t\t\t\t\t\tisBuggy = isBuggy || This.content.some(function(e) { return !document.documentElement.contains(e); })\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(isBuggy) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// if we found any bug, we will need to restart a layout\n\t\t\t\t\t\t\tcssConsole.warn(\"Buggy css regions layout: the page changed; we need to restart.\");\n\t\t\t\t\t\t\tThis.restartLayout = true; \n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// if it was okay, let's fire some event\n\t\t\t\t\t\t\tThis.lastEventRAF = requestAnimationFrame(function() {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// TODO: only fire when necessary but...\n\t\t\t\t\t\t\t\tThis.dispatchEvent('regionfragmentchange');\n\t\t\t\t\t\t\t\tThis.dispatchEvent('regionoversetchange');\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t// NOTE: we recover the scroll position in case the browser mess it up\n\t\t\t\t\tdocument.documentElement.scrollTop = docElmScrollTop;\n\t\t\t\t\tdocument.body.scrollTop = docBdyScrollTop;\n\t\t\t\t\t\n\t\t\t\t\t// mark layout has being done\n\t\t\t\t\tThis.relayoutInProgress = false;\n\t\t\t\t\tThis.failedLayoutCount = 0;\n\t\t\t\t\t\n\t\t\t\t\t// restart a layout if a request was queued during the current one\n\t\t\t\t\tif(This.restartLayout) {\n\t\t\t\t\t\tThis.restartLayout = false;\n\t\t\t\t\t\tThis.relayout();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t} catch(ex) {\n\t\t\t\n\t\t\t// sometimes IE fails for no valid reason \n\t\t\t// (other than the page is still loading)\n\t\t\tsetImmediate(function() { throw ex; });\n\t\t\t\n\t\t\t// but we cannot accept to fail, so we need to try again\n\t\t\t// until we finish a complete layout pass...\n\t\t\tThis.failedLayoutCount++;\n\t\t\tif(This.failedLayoutCount<7) {requestAnimationFrame(function() { This._relayout() });}\n\t\t\telse {This.failedLayoutCount=0; This.relayoutScheduled=false; This.relayoutInProgress=false; This.restartLayout=false; }\n\t\t\t\n\t\t}\n\t}\n\n\tcssRegions.Flow.prototype.relayoutIfSizeChanged = function() {\n\t\t\n\t\t// go through all regions\n\t\t// and see if any did change of size\n\t\tvar rs = this.regions;     \n\t\tfor(var i=rs.length; i--; ) {\n\t\t\tif(\n\t\t\t\trs[i].offsetHeight !== rs[i].cssRegionsLastOffsetHeight\n\t\t\t\t|| rs[i].offsetWidth !== rs[i].cssRegionsLastOffsetWidth\n\t\t\t) {\n\t\t\t\tthis.relayout(); return;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\tcssRegions.Flow.prototype.addEventListenersTo = function(nodes) {\n\t\tvar This=this; if(nodes instanceof Element) { nodes=[nodes] }\n\t\t\n\t\tnodes.forEach(function(element) {\n\t\t\tif(!element.cssRegionsEventStream) {\n\t\t\t\telement.cssRegionsEventStream = new ES.DOMUpdateEventStream({target: element});\n\t\t\t\telement.cssRegionsEventStream.schedule(This.update);\n\t\t\t}\n\t\t});\n\t\t\n\t}\n\n\tcssRegions.Flow.prototype.removeEventListenersOf = function(nodes) {\n\t\tvar This=this; if(nodes instanceof Element) { nodes=[nodes] }\n\t\t\n\t\tnodes.forEach(function(element) {\n\t\t\tif(element.cssRegionsEventStream) {\n\t\t\t\telement.cssRegionsEventStream.dispose();\n\t\t\t\tdelete element.cssRegionsEventStream;\n\t\t\t}\n\t\t});\n\t\t\n\t}\n\n\t// alias\n\tcssRegions.NamedFlow = cssRegions.Flow;\n\n\t// return a disconnected array of the content of a NamedFlow\n\tcssRegions.NamedFlow.prototype.getContent = function getContent() {\n\t\treturn this.content.slice(0)\n\t}\n\n\t// return a disconnected array of the regions of a NamedFlow\n\tcssRegions.NamedFlow.prototype.getRegions = function getRegions() {\n\t\treturn this.regions.slice(0)\n\t}\n\n\tcssRegions.NamedFlow.prototype.getRegionsByContent = function getRegionsByContent(node) {\n\t\tvar regions = [];\n\t\tvar fragments = document.querySelectorAll('[data-css-regions-fragment-of=\"'+node.getAttribute('data-css-regions-fragment-source')+'\"]');\n\t\tfor (var i=0; i<fragments.length; i++) {\n\t\t\t\n\t\t\tvar current=fragments[i]; do {\n\t\t\t\t\n\t\t\t\tif(current.getAttribute('data-css-region')) {\n\t\t\t\t\tregions.push(current); break;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} while(current=current.parentNode);\n\t\t\t\n\t\t}\n\t\t\n\t\treturn regions;\n\t}\n\n\tdomEvents.EventTarget.implementsIn(cssRegions.Flow);\n\n\t//\n\t// this class is a collection of named flows (not an array, sadly)\n\t//\n\tcssRegions.NamedFlowCollection = function NamedFlowCollection() {\n\t\t\n\t\tthis.length = 0;\n\t\t\n\t}\n\n\tcssRegions.NamedFlowCollection.prototype.namedItem = function(k) {\n\t\treturn cssRegions.flows[k] || (cssRegions.flows[k]=new cssRegions.Flow(k));\n\t}\n\n\n\t//\n\t// this helper creates the required methods on top of the DOM {ie: public exports}\n\t//\n\tcssRegions.enablePolyfillObjectModel = function() {\n\t\t\n\t\t//\n\t\t// DOCUMENT INTERFACE\n\t\t//\n\t\t\n\t\t//\n\t\t// returns a static list of active named flows\n\t\t//\n\t\tdocument.getNamedFlows = function() {\n\t\t\t\t\n\t\t\tvar c = new cssRegions.NamedFlowCollection(); var flows = cssRegions.flows;\n\t\t\tfor(var flowName in cssRegions.flows) {\n\t\t\t\t\n\t\t\t\tif(Object.prototype.hasOwnProperty.call(flows, flowName)) {\n\t\t\t\t\t\n\t\t\t\t\t// only active flows can be included\n\t\t\t\t\tif(flows[flowName].content.length!=0 || flows[flowName].regions.length!=0) {\n\t\t\t\t\t\tc[c.length++] = c[flowName] = flows[flowName];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\treturn c;\n\t\t\t\n\t\t}\n\t\t\n\t\t//\n\t\t// returns a live object for any named flow\n\t\t//\n\t\tdocument.getNamedFlow = function(flowName) {\n\t\t\t\t\n\t\t\tvar flows = cssRegions.flows;\n\t\t\treturn (flows[flowName] || (flows[flowName]=new cssRegions.NamedFlow(flowName)));\n\t\t\t\n\t\t}\n\t\t\n\t\t//\n\t\t// ELEMENT INTERFACE\n\t\t//    \n\t\tObject.defineProperties(\n\t\t\tElement.prototype,\n\t\t\t{\n\t\t\t\t\"regionOverset\": {\n\t\t\t\t\tget: function() {\n\t\t\t\t\t\treturn this._regionOverset || 'fit';\n\t\t\t\t\t},\n\t\t\t\t\tset: function(value) {\n\t\t\t\t\t\tthis._regionOverset = value;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"getRegionFlowRanges\": {\n\t\t\t\t\tvalue: function getRegionFlowRanges() {\n\t\t\t\t\t\treturn null; // TODO: can we implement that? I think we can't (properly).\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"getComputedRegionStyle\": {\n\t\t\t\t\tvalue: function getComputedRegionStyle(element,pseudo) {\n\t\t\t\t\t\t// TODO: only works while we don't relayout\n\t\t\t\t\t\t// TODO: only works properly for elements actually in the region\n\t\t\t\t\t\tvar fragment = document.querySelector('[data-css-regions-fragment-of=\"'+element.getAttribute('data-css-regions-fragment-source')+'\"]');\n\t\t\t\t\t\tif(pseudo) {\n\t\t\t\t\t\t\treturn getComputedStyle(fragment||element, pseudo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn getComputedStyle(fragment||element);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\t\t\n\t\t\n\t\t//\n\t\t// CSSStyleDeclaration interface\n\t\t//\n\t\tcssCascade.polyfillStyleInterface('flow-into');\n\t\tcssCascade.polyfillStyleInterface('flow-from');\n\t\tcssCascade.polyfillStyleInterface('region-fragment');\n\t\tcssCascade.polyfillStyleInterface('break-before');\n\t\tcssCascade.polyfillStyleInterface('break-after');\n\n\t}\n\n\t// load the polyfill immediately if not especially told otherwise\n\tif(!(\"cssRegionsManualTrigger\" in window)) { cssRegions.enablePolyfill(); }\n\t\n});\nrequire.define('src/css-regions/lib/objectmodel.js');","//\n// this module holds the big-picture actions of the polyfill\n//\nmodule.exports = (function(window, document) { \"use strict\";\n\n\tvar domEvents = require('src/core/dom-events.js');\n\tvar cssSyntax = require('src/core/css-syntax.js');\n\tvar cssCascade = require('src/core/css-cascade.js');\n\tvar cssBreak = require('src/core/css-break.js');\n\t\n\trequire('src/css-regions/lib/range-extensions.js');\n\tvar cssRegionsHelpers = require('src/css-regions/lib/helpers.js');\n\tvar enableObjectModel = require('src/css-regions/lib/objectmodel.js');\n\t\n\tvar CSS_STYLE = \"cssregion,[data-css-region]>*,[data-css-regions-fragment-source]:not([data-css-regions-cloning]),[data-css-regions-fragment-source][data-css-regions-cloned]{display:none!important}[data-css-region]>cssregion:last-of-type{display:inline!important}[data-css-region]{content:normal!important}[data-css-special-continued-fragment]{counter-reset:none!important;counter-increment:none!important;margin-bottom:0!important;border-bottom-left-radius:0!important;border-bottom-right-radius:0!important}[data-css-continued-fragment]{counter-reset:none!important;counter-increment:none!important;margin-bottom:0!important;padding-bottom:0!important;border-bottom:none!important;border-bottom-left-radius:0!important;border-bottom-right-radius:0!important}[data-css-continued-fragment]::after{content:none!important;display:none!important}[data-css-special-starting-fragment]{text-indent:0!important;margin-top:0!important}[data-css-starting-fragment]{text-indent:0!important;margin-top:0!important;padding-top:0!important;border-top:none!important;border-top-left-radius:0!important;border-top-right-radius:0!important}[data-css-starting-fragment]::before{content:none!important;display:none!important}[data-css-continued-block-fragment][data-css-continued-fragment]:not(:empty)::after{content:''!important;display:inline-block!important;width:100%!important;height:0!important;font-size:0!important;line-height:0!important;margin:0!important;padding:0!important;border:0!important}\";\n\n\tvar cssRegions = {\n\t\t\n\t\t//\n\t\t// this function is at the heart of the region polyfill\n\t\t// it will iteratively fill a list of regions until no\n\t\t// content or no region is left\n\t\t//\n\t\t// the before-overflow size of a region is determined by\n\t\t// adding all content to it and comparing his offsetHeight\n\t\t// and his scrollHeight\n\t\t//\n\t\t// when this is done, we use dom ranges to detect the point\n\t\t// where the content exceed this box and we split the fragment\n\t\t// at that point.\n\t\t//\n\t\t// when splitting inside an element, the borders, paddings and\n\t\t// generated content must be tied to the right fragments which\n\t\t// require some code\n\t\t//\n\t\t// this functions returns whether some content was still remaining\n\t\t// when the flow when the last region was filled. please not this\n\t\t// can only happen if this last region has \"region-fragment\" set\n\t\t// to break, otherwhise all the content will automatically overflow\n\t\t// this last region.\n\t\t//\n\t\tlayoutContent: function(regions, remainingContent, callback, startTime) {\n\t\t\t\n\t\t\t//\n\t\t\t// this function will iteratively fill all the regions\n\t\t\t// when we reach the last region, we return the overset status\n\t\t\t//\n\t\t\t\n\t\t\t// validate args\n\t\t\tif(!regions) return callback.ondone(!!remainingContent.hasChildNodes());\n\t\t\tif(!regions.length) return callback.ondone(!!remainingContent.hasChildNodes());\n\t\t\tif(!startTime) startTime = Date.now();\n\t\t\t\n\t\t\t// get the next region\n\t\t\tvar region = regions.pop();\n\t\t\t  \n\t\t\t// NOTE: while we don't monitor that, and it can therefore become inaccurate\n\t\t\t// I'm going to follow the spec and refuse to mark as region inline/none elements]\n\t\t\twhile(true) {\n\t\t\t\tvar regionDisplay = getComputedStyle(region).display;\n\t\t\t\tif(regionDisplay == \"none\" || regionDisplay.indexOf(\"inline\") !== -1) {\n\t\t\t\t\tif(region = regions.pop()) { continue } else { return callback.ondone(!!remainingContent.hasChildNodes()) };\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// the polyfill actually use a <cssregion> wrapper\n\t\t\t// we need to link this wrapper and the actual region\n\t\t\tif(region.cssRegionsWrapper) {\n\t\t\t\tregion.cssRegionsWrapper.cssRegionHost = region;\n\t\t\t\tregion = region.cssRegionsWrapper;\n\t\t\t} else {\n\t\t\t\tregion.cssRegionHost = region;\n\t\t\t}\n\t\t\t\n\t\t\t// empty the region\n\t\t\tregion.innerHTML = '';\n\t\t\t\n\t\t\t// avoid doing the layout of empty regions\n\t\t\tif(!remainingContent.hasChildNodes()) {\n\t\t\t\t\n\t\t\t\tregion.cssRegionHost.cssRegionsLastOffsetHeight = region.cssRegionHost.offsetHeight;\n\t\t\t\tregion.cssRegionHost.cssRegionsLastOffsetWidth = region.cssRegionHost.offsetWidth;\n\t\t\t\t\n\t\t\t\tregion.cssRegionHost.regionOverset = 'empty';\n\t\t\t\t\n\t\t\t\tvar dummyCallback = { ondone:function(){}, onprogress:function(f){f()} };\n\t\t\t\tcssRegions.layoutContent(regions, remainingContent, dummyCallback, startTime);\n\t\t\t\t\n\t\t\t\treturn callback.ondone(false);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// append the remaining content to the region\n\t\t\tregion.appendChild(remainingContent);\n\t\t\t\n\t\t\t// check if we have more regions to process\n\t\t\tif(regions.length !== 0) {\n\t\t\t\t\n\t\t\t\treturn this.layoutContentInNextRegionsWhenReady(region, regions, remainingContent, callback, startTime);\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\treturn this.layoutContentInLastRegionWhenReady(region, regions, remainingContent, callback, startTime);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\tlayoutContentInNextRegionsWhenReady: function(region, regions, remainingContent, callback, startTime) {\n\t\t\t\t\t\n\t\t\t// delays until all images are loaded\n\t\t\tvar imgs = region.getElementsByTagName('img');\n\t\t\tfor(var imgs_index=imgs.length; imgs_index--; ) {\n\t\t\t\tif(!imgs[imgs_index].complete && !imgs[imgs_index].hasAttribute('height')) {\n\t\t\t\t\treturn setTimeout(\n\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\tthis.layoutContentInNextRegionsWhenReady(region, regions, remainingContent, callback, startTime+32);\n\t\t\t\t\t\t}.bind(this), \n\t\t\t\t\t\t16\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// check if there was an overflow or some break-before/after instruction\n\t\t\tvar regionDidOverflow = region.cssRegionHost.scrollHeight != region.cssRegionHost.offsetHeight;\n\t\t\tvar shouldSegmentContent = regionDidOverflow;\n\t\t\tif(!shouldSegmentContent) {\n\t\t\t\tvar first = region.firstElementChild;\n\t\t\t\tvar last = region.lastElementChild;\n\t\t\t\tvar current = first;\n\t\t\t\twhile(current) {\n\t\t\t\t\t\n\t\t\t\t\tif(current != first) {\n\t\t\t\t\t\tif(/(region|all|always)/i.test(cssCascade.getSpecifiedStyle(current,'break-before',undefined,true).toCSSString())) {\n\t\t\t\t\t\t\tshouldSegmentContent = true; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(current != last) {\n\t\t\t\t\t\tif(/(region|all|always)/i.test(cssCascade.getSpecifiedStyle(current,'break-after',undefined,true).toCSSString())) {\n\t\t\t\t\t\t\tcurrent = current.nextElementSibling;\n\t\t\t\t\t\t\tshouldSegmentContent = true; break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrent = current.nextElementSibling;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif(shouldSegmentContent) {\n\t\t\t\t\n\t\t\t\t// the remaining content is what was overflowing\n\t\t\t\tremainingContent = this.extractOverflowingContent(region);\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t// there's nothing more to insert\n\t\t\t\tremainingContent = document.createDocumentFragment();\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// if any content didn't fit\n\t\t\tif(remainingContent.hasChildNodes()) {\n\t\t\t\tregion.cssRegionHost.regionOverset = 'overset';\n\t\t\t} else {\n\t\t\t\tregion.cssRegionHost.regionOverset = 'fit';\n\t\t\t}\n\t\t\t\n\t\t\t// update flags\n\t\t\tregion.cssRegionHost.cssRegionsLastOffsetHeight = region.cssRegionHost.offsetHeight;\n\t\t\tregion.cssRegionHost.cssRegionsLastOffsetWidth = region.cssRegionHost.offsetWidth;\n\t\t\t\n\t\t\t// layout the next regions\n\t\t\t// WE LET THE NEXT REGION DECIDE WHAT TO RETURN\n\t\t\tif(startTime+200 > Date.now()) {\n\t\t\t\t\n\t\t\t\treturn cssRegions.layoutContent(regions, remainingContent, callback, startTime);\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\treturn callback.onprogress(function() {\n\t\t\t\t\tcssRegions.layoutContent(regions, remainingContent, callback);\n\t\t\t\t});\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\tlayoutContentInLastRegionWhenReady: function(region, regions, remainingContent, callback, startTime) {\n\t\t\t\n\t\t\t// delays until all images are loaded\n\t\t\tvar imgs = region.getElementsByTagName('img');\n\t\t\tfor(var imgs_index=imgs.length; imgs_index--; ) {\n\t\t\t\tif(!imgs[imgs_index].complete && !imgs[imgs_index].hasAttribute('height')) {\n\t\t\t\t\treturn setTimeout(\n\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\tthis.layoutContentInLastRegionWhenReady(region, regions, remainingContent, callback, startTime+32);\n\t\t\t\t\t\t}.bind(this), \n\t\t\t\t\t\t32\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// support region-fragment: break\n\t\t\tif(cssCascade.getSpecifiedStyle(region.cssRegionHost,\"region-fragment\",undefined,true).toCSSString().trim().toLowerCase()==\"break\") {\n\t\t\t\t\n\t\t\t\t// WE RETURN TRUE IF WE DID OVERFLOW\n\t\t\t\tvar didOverflow = (this.extractOverflowingContent(region).hasChildNodes());\n\t\t\t\t\n\t\t\t\t// update flags\n\t\t\t\tregion.cssRegionHost.cssRegionsLastOffsetHeight = region.cssRegionHost.offsetHeight;\n\t\t\t\tregion.cssRegionHost.cssRegionsLastOffsetWidth = region.cssRegionHost.offsetWidth;\n\t\t\t\t\n\t\t\t\treturn callback.ondone(didOverflow);\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t// update flags\n\t\t\t\tregion.cssRegionHost.cssRegionsLastOffsetHeight = region.cssRegionHost.offsetHeight;\n\t\t\t\tregion.cssRegionHost.cssRegionsLastOffsetWidth = region.cssRegionHost.offsetWidth;\n\t\t\t\t\n\t\t\t\t// WE RETURN FALSE IF WE DIDN'T OVERFLOW\n\t\t\t\treturn callback.ondone(region.cssRegionHost.offsetHeight != region.cssRegionHost.scrollHeight);\n\t\t\t\t\n\t\t\t}\n\t\t},\n\n\t\t\n\t\t//\n\t\t// this function returns a document fragment containing the content\n\t\t// that didn't fit in a particular <cssregion> element.\n\t\t//\n\t\t// in the simplest cases, we can just use hit-targeting to get very\n\t\t// close the the natural breaking point. for mostly textual flows,\n\t\t// this works perfectly, for the others, we may need some tweaks.\n\t\t//\n\t\t// there's a code detecting whether this hit-target optimization\n\t\t// did possibly fail, in which case we return to a setup where we\n\t\t// start from scratch.\n\t\t//\n\t\textractOverflowingContent: function(region, dontOptimize) {\n\t\t\t\n\t\t\t// make sure empty nodes don't make our life more difficult\n\t\t\tcssRegionsHelpers.embedTrailingWhiteSpaceNodes(region);\n\t\t\t\n\t\t\t// get the region layout\n\t\t\tvar sizingH = region.cssRegionHost.offsetHeight; // avail size (max-height)\n\t\t\tvar sizingW = region.cssRegionHost.offsetWidth; // avail size (max-width)\n\t\t\tvar pos = region.cssRegionHost.getBoundingClientRect(); // avail size?\n\t\t\tpos = {top: pos.top, bottom: pos.bottom, left: pos.left, right: pos.right};\n\t\t\t\n\t\t\t// substract from the bottom any border/padding of the region\n\t\t\tvar lostHeight = parseInt(getComputedStyle(region.cssRegionHost).paddingBottom);\n\t\t\tlostHeight += parseInt(getComputedStyle(region.cssRegionHost).borderBottomWidth);\n\t\t\tpos.bottom -= lostHeight; sizingH -= lostHeight;\n\t\t\t\n\t\t\t//\n\t\t\t// note: let's use hit targeting to find a dom range\n\t\t\t// which is close to the location where we will need to\n\t\t\t// break the content into fragments\n\t\t\t// \n\t\t\t\n\t\t\t// get the caret range for the bottom-right of that location\n\t\t\ttry {\n\t\t\t\tvar r = dontOptimize ? document.createRange() : document.caretRangeFromPoint(\n\t\t\t\t\tpos.left + sizingW - 1,\n\t\t\t\t\tpos.top + sizingH - 1\n\t\t\t\t);\n\t\t\t} catch (ex) {\n\t\t\t\ttry {\n\t\t\t\t\tcssConsole.error(ex.message);\n\t\t\t\t\tcssConsole.dir(ex);\n\t\t\t\t} catch (ex) {}\n\t\t\t}\n\t\t\t\n\t\t\t// helper for logging info\n\t\t\t/*cssConsole.log(\"extracting overflow\")\n\t\t\tcssConsole.log(pos.bottom)*/\n\t\t\tvar debug = function() {\n\t\t\t\t/*cssConsole.dir({\n\t\t\t\t\tstartContainer: r.startContainer,\n\t\t\t\t\tstartOffset: r.startOffset,\n\t\t\t\t\tbrowserBCR: r.getBoundingClientRect(),\n\t\t\t\t\tcomputedBCR: rect\n\t\t\t\t});*/\n\t\t\t}\n\t\t\t\n\t\t\tvar fixNullRect = function() {\n\t\t\t\tif(rect.bottom==0 && rect.top==0 && rect.left==0 && rect.right==0) {\n\t\t\t\t\t\n\t\t\t\t\tvar scrollTop = -(document.documentElement.scrollTop || document.body.scrollTop);\n\t\t\t\t\tvar scrollLeft = -(document.documentElement.scrollLeft || document.body.scrollLeft);\n\t\t\t\t\t\n\t\t\t\t\trect = {\n\t\t\t\t\t\twidth: 0,\n\t\t\t\t\t\theigth: 0,\n\t\t\t\t\t\ttop: scrollTop,\n\t\t\t\t\t\tbottom: scrollTop,\n\t\t\t\t\t\tleft: scrollLeft,\n\t\t\t\t\t\tright: scrollLeft\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// if the caret is outside the region\n\t\t\tif(!r || (region !== r.endContainer && !Node.contains(region,r.endContainer))) {\n\t\t\t\t\n\t\t\t\t// if the caret is after the region wrapper but inside the host...\n\t\t\t\tif(r && r.endContainer === region.cssRegionHost && r.endOffset==r.endContainer.childNodes.length) {\n\t\t\t\t\t\n\t\t\t\t\t// move back at the end of the region, actually\n\t\t\t\t\tr.setStart(region, region.childNodes.length);\n\t\t\t\t\tr.setEnd(region, region.childNodes.length);\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\t// move back into the region\n\t\t\t\t\tr = r || document.createRange();\n\t\t\t\t\tr.setStart(region, 0);\n\t\t\t\t\tr.setEnd(region, 0);\n\t\t\t\t\tdontOptimize=true;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// start finding the natural breaking point\n\t\t\tdo {\n\t\t\t\t\n\t\t\t\t// store the current selection rect for fast access\n\t\t\t\tvar rect = r.myGetExtensionRect(); fixNullRect();\n\t\t\t\tdebug();\n\t\t\t\t\n\t\t\t\t//\n\t\t\t\t// note: maybe the text is right-to-left\n\t\t\t\t// in this case, we can go further than the caret\n\t\t\t\t//\n\t\t\t\t\n\t\t\t\t// move the end point char by char until it's completely in the region\n\t\t\t\twhile(!(r.endContainer==region && r.endOffset==r.endContainer.childNodes.length) && rect.bottom<=pos.top+sizingH) {\n\t\t\t\t\t\n\t\t\t\t\tdebug();\n\t\t\t\t\t\n\t\t\t\t\t// look if we can optimize by moving fast forward\n\t\t\t\t\tvar nextSibling = r.endContainer.childNodes[r.endOffset];\n\t\t\t\t\tvar nextSiblingRect = !nextSibling || Node.getBoundingClientRect(nextSibling);\n\t\t\t\t\tif(nextSibling && nextSiblingRect.bottom<=pos.top+sizingH) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// if yes, move element by element\n\t\t\t\t\t\tr.setStartAfter(nextSibling)\n\t\t\t\t\t\tr.setEndAfter(nextSibling)\n\t\t\t\t\t\trect = nextSiblingRect\n\t\t\t\t\t\tfixNullRect()\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// otherwise, go char-by-char\n\t\t\t\t\t\tr.myMoveTowardRight(); rect = r.myGetExtensionRect(); fixNullRect();\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//\n\t\t\t\t// note: maybe the text is one line too big\n\t\t\t\t// in this case, we have to backtrack a little\n\t\t\t\t//\n\t\t\t\t\n\t\t\t\t// move the end point char by char until it's completely in the region\n\t\t\t\twhile(!(r.endContainer==region && r.endOffset==0) && rect.bottom>pos.top+sizingH) {\n\t\t\t\t\tdebug(); r.myMoveOneCharLeft(); rect = r.myGetExtensionRect(); fixNullRect();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdebug()\n\t\t\t\t\n\t\t\t\t//\n\t\t\t\t// note: if we optimized via hit-testing, this may be wrong\n\t\t\t\t// if next condition does not hold, we're fine. \n\t\t\t\t// otherwhise we must restart without optimization...\n\t\t\t\t//\n\t\t\t\t\n\t\t\t\t// if the selected content is possibly off-target\n\t\t\t\tvar optimizationFailled = false; if(!dontOptimize) {\n\t\t\t\t\t\n\t\t\t\t\tvar current = r.endContainer;\n\t\t\t\t\twhile(current = cssRegionsHelpers.getAllLevelPreviousSibling(current, region)) {\n\t\t\t\t\t\tif(Node.getBoundingClientRect(current).bottom > pos.top + sizingH) {\n\t\t\t\t\t\t\tr.setStart(region,0);\n\t\t\t\t\t\t\tr.setEnd(region,0);\n\t\t\t\t\t\t\toptimizationFailled=true;\n\t\t\t\t\t\t\tdontOptimize=true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} while(optimizationFailled) \n\t\t\t\n\t\t\t// \n\t\t\t// note: we should not break the content inside monolithic content\n\t\t\t// if we do, we need to change the selection to avoid that\n\t\t\t// \n\t\t\t\n\t\t\t// move the selection before the monolithic ancestors\n\t\t\tvar current = r.endContainer;\n\t\t\twhile(current !== region) {\n\t\t\t\tif(cssBreak.isMonolithic(current)) {\n\t\t\t\t\tr.setEndBefore(current);\n\t\t\t\t}\n\t\t\t\tcurrent = current.parentNode;\n\t\t\t}\n\t\t\t\n\t\t\t// if the selection is not in the region anymore, add the whole region\n\t\t\tif(!r || (region !== r.endContainer && !Node.contains(region,r.endContainer))) {\n\t\t\t\tcssConsole.dir(r.cloneRange()); debugger;\n\t\t\t\tr.setStart(region,region.childNodes.length);\n\t\t\t\tr.setEnd(region,region.childNodes.length);\n\t\t\t}\n\t\t\t\n\t\t\t// \n\t\t\t// note: we don't want to break inside a line.\n\t\t\t// backtrack to end of previous line...\n\t\t\t// \n\t\t\tvar first = r.startContainer.childNodes[r.startOffset], current = first; \n\t\t\tif(cssBreak.hasAnyInlineFlow(r.startContainer)) {\n\t\t\t\twhile((current) && (current = current.previousSibling)) {\n\t\t\t\t\t\n\t\t\t\t\tif(cssBreak.areInSameSingleLine(current,first)) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// optimization: first and current are on the same line\n\t\t\t\t\t\t// so if next and current are not the same line, it will still be\n\t\t\t\t\t\t// the same line the \"first\" element is in\n\t\t\t\t\t\tfirst = current;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(current instanceof Element) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// we don't want to break inside text lines\n\t\t\t\t\t\t\tr.setEndBefore(current);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// get last line via client rects\n\t\t\t\t\t\t\tvar lines = Node.getClientRects(current);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// if the text node did wrap into multiple lines\n\t\t\t\t\t\t\tif(lines.length>1) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// move back from the end until we get into previous line\n\t\t\t\t\t\t\t\tvar previousLineBottom = lines[lines.length-2].bottom;\n\t\t\t\t\t\t\t\tr.setEnd(current, current.nodeValue.length);\n\t\t\t\t\t\t\t\twhile(rect.bottom>previousLineBottom) {\n\t\t\t\t\t\t\t\t\tr.myMoveOneCharLeft(); rect = r.myGetExtensionRect(); fixNullRect();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// make sure we didn't exit the text node by mistake\n\t\t\t\t\t\t\t\tif(r.endContainer!==current) {\n\t\t\t\t\t\t\t\t\t// if we did, there's something wrong about the text node\n\t\t\t\t\t\t\t\t\t// but we can consider the text node as an element instead\n\t\t\t\t\t\t\t\t\tr.setEndBefore(current); // debugger; \n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// we can consider the text node as an element\n\t\t\t\t\t\t\t\tr.setEndBefore(current);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// if the two elements are not on the same line, \n\t\t\t\t\t\t// then we just found a line break!\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// if the selection is not in the region anymore, add the whole region\n\t\t\tif(!r || (region !== r.endContainer && !Node.contains(region,r.endContainer))) {\n\t\t\t\tcssConsole.dir(r.cloneRange()); debugger;\n\t\t\t\tr.setStart(region,region.childNodes.length);\n\t\t\t\tr.setEnd(region,region.childNodes.length);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t// \n\t\t\t// note: the css-break spec says that a region should not be emtpy\n\t\t\t// \n\t\t\t\n\t\t\t// if we end up with nothing being selected, add the first block anyway\n\t\t\tif(r.endContainer===region && r.endOffset===0 && r.endOffset!==region.childNodes.length) {\n\t\t\t\t\n\t\t\t\t// find the first allowed break point\n\t\t\t\tdo {\n\t\t\t\t\t\n\t\t\t\t\t//cssConsole.dir(r.cloneRange()); \n\t\t\t\t\t\n\t\t\t\t\t// move the position char-by-char\n\t\t\t\t\tr.myMoveTowardRight(); \n\t\t\t\t\t\n\t\t\t\t\t// but skip long islands of monolithic elements\n\t\t\t\t\t// since we know we cannot break inside them anyway\n\t\t\t\t\tvar current = r.endContainer;\n\t\t\t\t\twhile(current && current !== region) {\n\t\t\t\t\t\tif(cssBreak.isMonolithic(current)) {\n\t\t\t\t\t\t\tr.setStartAfter(current);\n\t\t\t\t\t\t\tr.setEndAfter(current);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurrent = current.parentNode;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t// do that until we reach a possible break point, or the end of the element\n\t\t\t\twhile(!cssBreak.isPossibleBreakPoint(r,region) && !(r.endContainer===region && r.endOffset===region.childNodes.length))\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// if the selection is not in the region anymore, add the whole region\n\t\t\tif(!r || region !== r.endContainer && !Node.contains(region,r.endContainer)) {\n\t\t\t\tcssConsole.dir(r.cloneRange()); debugger;\n\t\t\t\tr.setStart(region,region.childNodes.length);\n\t\t\t\tr.setEnd(region,region.childNodes.length);\n\t\t\t}\n\t\t\t\t\n\t\t\t// now, let's try to find a break-before/break-after element before the splitting point\n\t\t\tvar current = r.endContainer; if(current.hasChildNodes()) { if(r.endOffset>0) { current=current.childNodes[r.endOffset-1] } };\n\t\t\tvar first = r.endContainer.firstChild;\n\t\t\tdo {\n\t\t\t\tif(current.style) {\n\t\t\t\t\t\n\t\t\t\t\tif(current != first) {\n\t\t\t\t\t\tif(/(region|all|always)/i.test(cssCascade.getSpecifiedStyle(current,'break-before',undefined,true).toCSSString())) {\n\t\t\t\t\t\t\tr.setStartBefore(current);\n\t\t\t\t\t\t\tr.setEndBefore(current);\n\t\t\t\t\t\t\tdontOptimize=true; // no algo involved in breaking, after all\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(current !== region) {\n\t\t\t\t\t\tif(/(region|all|always)/i.test(cssCascade.getSpecifiedStyle(current,'break-after',undefined,true).toCSSString())) {\n\t\t\t\t\t\t\tr.setStartAfter(current);\n\t\t\t\t\t\t\tr.setEndAfter(current);\n\t\t\t\t\t\t\tdontOptimize=true; // no algo involved in breaking, after all\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} while(current = cssRegionsHelpers.getAllLevelPreviousSibling(current, region));\n\t\t\t\n\t\t\t// we're almost done! now, let's collect the ancestors to make some splitting postprocessing\n\t\t\tvar current = r.endContainer; var allAncestors=[];\n\t\t\tif(current.nodeType !== current.ELEMENT_NODE) current=current.parentNode;\n\t\t\twhile(current !== region) {\n\t\t\t\tallAncestors.push(current);\n\t\t\t\tcurrent = current.parentNode;\n\t\t\t}\n\t\t\t\n\t\t\t//\n\t\t\t// note: if we're about to split after the last child of\n\t\t\t// an element which has bottom-{padding/border/margin}, \n\t\t\t// we need to figure how how much of that p/b/m we can\n\t\t\t// actually keep in the first fragment\n\t\t\t// \n\t\t\t// TODO: avoid top & bottom p/b/m cuttings to use the \n\t\t\t// same variables names, it's ugly\n\t\t\t//\n\t\t\t\n\t\t\t// split bottom-{margin/border/padding} correctly\n\t\t\tif(r.endOffset == r.endContainer.childNodes.length && r.endContainer !== region) {\n\t\t\t\t\n\t\t\t\t// compute how much of the bottom border can actually fit\n\t\t\t\tvar box = r.endContainer.getBoundingClientRect();\n\t\t\t\tvar excessHeight = box.bottom - (pos.top + sizingH);\n\t\t\t\tvar endContainerStyle = getComputedStyle(r.endContainer);\n\t\t\t\tvar availBorderHeight = parseFloat(endContainerStyle.borderBottomWidth);\n\t\t\t\tvar availPaddingHeight = parseFloat(endContainerStyle.paddingBottom);\n\t\t\t\t\n\t\t\t\t// start by cutting into the border\n\t\t\t\tvar borderCut = excessHeight;\n\t\t\t\tif(excessHeight > availBorderHeight) {\n\t\t\t\t\tborderCut = availBorderHeight;\n\t\t\t\t\texcessHeight -= borderCut;\n\t\t\t\t\t\n\t\t\t\t\t// continue by cutting into the padding\n\t\t\t\t\tvar paddingCut = excessHeight;\n\t\t\t\t\tif(paddingCut > availPaddingHeight) {\n\t\t\t\t\t\tpaddingCut = availPaddingHeight;\n\t\t\t\t\t\texcessHeight -= paddingCut;\n\t\t\t\t\t} else {\n\t\t\t\t\t\texcessHeight = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\texcessHeight = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t// we don't cut borders with radiuses\n\t\t\t\t// TODO: accept to cut the content not affected by the radius\n\t\t\t\tif(typeof(borderCut)===\"number\" && borderCut!==0) {\n\t\t\t\t\t\n\t\t\t\t\t// check the presence of a radius:\n\t\t\t\t\tvar hasBottomRadius = (\n\t\t\t\t\t\tparseInt(endContainerStyle.borderBottomLeftRadius)>0\n\t\t\t\t\t\t|| parseInt(endContainerStyle.borderBottomRightRadius)>0\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\tif(hasBottomRadius) {\n\t\t\t\t\t\t// break before the whole border:\n\t\t\t\t\t\tborderCut = availBorderHeight;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t// split top-{margin/border/padding} correctly\n\t\t\tif(r.endOffset == 0 && r.endContainer !== region) {\n\t\t\t\t\n\t\t\t\t// note: the only possibility here is that we \n\t\t\t\t// did split after a padding or a border.\n\t\t\t\t// \n\t\t\t\t// it can only happen if the border/padding is \n\t\t\t\t// too big to fit the region but is actually \n\t\t\t\t// the first break we could find!\n\t\t\t\t\n\t\t\t\t// compute how much of the top border can actually fit\n\t\t\t\tvar box = r.endContainer.getBoundingClientRect();\n\t\t\t\tvar availHeight = (pos.top + sizingH) - pos.top;\n\t\t\t\tvar endContainerStyle = getComputedStyle(r.endContainer);\n\t\t\t\tvar availBorderHeight = parseFloat(endContainerStyle.borderTopWidth);\n\t\t\t\tvar availPaddingHeight = parseFloat(endContainerStyle.paddingTop);\n\t\t\t\tvar excessHeight = availBorderHeight + availPaddingHeight - availHeight;\n\t\t\t\t\n\t\t\t\tif(excessHeight > 0) {\n\t\t\t\t\n\t\t\t\t\t// start by cutting into the padding\n\t\t\t\t\tvar topPaddingCut = excessHeight;\n\t\t\t\t\tif(excessHeight > availPaddingHeight) {\n\t\t\t\t\t\ttopPaddingCut = availPaddingHeight;\n\t\t\t\t\t\texcessHeight -= topPaddingCut;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// continue by cutting into the border\n\t\t\t\t\t\tvar topBorderCut = excessHeight;\n\t\t\t\t\t\tif(topBorderCut > availBorderHeight) {\n\t\t\t\t\t\t\ttopBorderCut = availBorderHeight;\n\t\t\t\t\t\t\texcessHeight -= topBorderCut;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\texcessHeight = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\texcessHeight = 0;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// remove bottom-{pbm} from all ancestors involved in the cut\n\t\t\tfor(var i=allAncestors.length-1; i>=0; i--) {\n\t\t\t\tallAncestors[i].setAttribute('data-css-continued-fragment',true);\n\t\t\t\tif(getComputedStyle(allAncestors[i]).display.indexOf('block')>=0) {\n\t\t\t\t\tallAncestors[i].setAttribute('data-css-continued-block-fragment',true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(typeof(borderCut)===\"number\") {\n\t\t\t\tallAncestors[0].removeAttribute('data-css-continued-fragment');\n\t\t\t\tallAncestors[0].setAttribute('data-css-special-continued-fragment',true);\n\t\t\t\tallAncestors[0].style.borderBottomWidth = (availBorderHeight-borderCut)+'px';\n\t\t\t}\n\t\t\tif(typeof(paddingCut)===\"number\") {\n\t\t\t\tallAncestors[0].removeAttribute('data-css-continued-fragment');\n\t\t\t\tallAncestors[0].setAttribute('data-css-special-continued-fragment',true);\n\t\t\t\tallAncestors[0].style.paddingBottom = (availPaddingHeight-paddingCut)+'px';\n\t\t\t}\n\t\t\tif(typeof(topBorderCut)===\"number\") {\n\t\t\t\tallAncestors[0].removeAttribute('data-css-continued-fragment');\n\t\t\t\tallAncestors[0].setAttribute('data-css-continued-fragment',true);\n\t\t\t\tallAncestors[0].style.borderTopWidth = (availBorderHeight-topBorderCut)+'px';\n\t\t\t}\n\t\t\tif(typeof(topPaddingCut)===\"number\") {\n\t\t\t\tallAncestors[0].removeAttribute('data-css-continued-fragment');\n\t\t\t\tallAncestors[0].setAttribute('data-css-special-continued-fragment',true);\n\t\t\t\tallAncestors[0].style.paddingTop = (availPaddingHeight-topPaddingCut)+'px';\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t//\n\t\t\t// note: at this point we have a collapsed range \n\t\t\t// located at the split point\n\t\t\t//\n\t\t\t\n\t\t\t// select the overflowing content\n\t\t\tr.setEnd(region, region.childNodes.length);\n\t\t\t\n\t\t\t// extract it from the current region\n\t\t\tvar overflowingContent = r.extractContents();\n\t\t\t\n\t\t\t// remove trailing whitespace from the cut element\n\t\t\tvar tmp = allAncestors[0];\n\t\t\tif(tmp && (tmp=tmp.lastChild) && !tmp.tagName && tmp.nodeValue) {\n\t\t\t\tvar nodeValue = tmp.nodeValue.replace(/(\\s|\\r|\\n)*$/,'');\n\t\t\t\tif(nodeValue) {\n\t\t\t\t\t// if the last cut was just after a &shy; (soft hyphen), we need to append a dash\n\t\t\t\t\tif(/\\u00AD$/.test(nodeValue)) {\n\t\t\t\t\t\tnodeValue = nodeValue.replace(/\\u00AD$/, '-');\n\t\t\t\t\t} else if(overflowingContent && overflowingContent.textContent[0] == '\\u00AD') {\n\t\t\t\t\t\tnodeValue = nodeValue + '-';\n\t\t\t\t\t}\n\t\t\t\t\ttmp.nodeValue = nodeValue;\n\t\t\t\t} else {\n\t\t\t\t\ttmp.parentNode.removeChild(tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// \n\t\t\t// note: now we have to cancel out the artifacts of\n\t\t\t// the fragments cloning algorithm...\n\t\t\t//\n\t\t\t\n\t\t\t// do not forget to remove any top p/b/m on cut elements\n\t\t\tvar newFragments = overflowingContent.querySelectorAll(\"[data-css-continued-fragment]\");\n\t\t\tfor(var i=newFragments.length; i--;) { // TODO: optimize by using while loop and a simple matchesSelector.\n\t\t\t\tnewFragments[i].removeAttribute('data-css-continued-fragment')\n\t\t\t\tnewFragments[i].setAttribute('data-css-starting-fragment',true);\n\t\t\t}\n\t\t\t\n\t\t\t// deduct any already-used bottom p/b/m\n\t\t\tvar specialNewFragment = overflowingContent.querySelector('[data-css-special-continued-fragment]');\n\t\t\tif(specialNewFragment) {\n\t\t\t\tspecialNewFragment.removeAttribute('data-css-special-continued-fragment')\n\t\t\t\tspecialNewFragment.setAttribute('data-css-starting-fragment',true);\n\t\t\t\t\n\t\t\t\tif(typeof(borderCut)===\"number\") {\n\t\t\t\t\tspecialNewFragment.style.borderBottomWidth = (borderCut)+'px';\n\t\t\t\t}\n\t\t\t\tif(typeof(paddingCut)===\"number\") {\n\t\t\t\t\tspecialNewFragment.style.paddingBottom = (paddingCut);\n\t\t\t\t} else {\n\t\t\t\t\tspecialNewFragment.style.paddingBottom = '0px';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(typeof(topBorderCut)===\"number\") {\n\t\t\t\t\tspecialNewFragment.removeAttribute('data-css-starting-fragment')\n\t\t\t\t\tspecialNewFragment.setAttribute('data-css-special-starting-fragment',true);\n\t\t\t\t\tspecialNewFragment.style.borderTopWidth = (topBorderCut)+'px';\n\t\t\t\t}\n\t\t\t\tif(typeof(topPaddingCut)===\"number\") {\n\t\t\t\t\tspecialNewFragment.removeAttribute('data-css-starting-fragment')\n\t\t\t\t\tspecialNewFragment.setAttribute('data-css-special-starting-fragment',true);\n\t\t\t\t\tspecialNewFragment.style.paddingTop = (topPaddingCut)+'px';\n\t\t\t\t\tspecialNewFragment.style.paddingBottom = '0px';\n\t\t\t\t\tspecialNewFragment.style.borderBottomWidth = '0px';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if(typeof(borderCut)===\"number\") {\n\t\t\t\t\n\t\t\t\t// hum... there's an element missing here... {never happens anymore}\n\t\t\t\ttry { throw new Error() }\n\t\t\t\tcatch(ex) { setImmediate(function() { throw ex; }) }\n\t\t\t\t\n\t\t\t} else if(typeof(topPaddingCut)===\"number\") {\n\t\t\t\t\n\t\t\t\t// hum... there's an element missing here... {never happens anymore}\n\t\t\t\ttry { throw new Error() }\n\t\t\t\tcatch(ex) { setImmediate(function() { throw ex; }) }\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t// make sure empty nodes are reintroduced\n\t\t\tcssRegionsHelpers.unembedTrailingWhiteSpaceNodes(region);\n\t\t\tcssRegionsHelpers.unembedTrailingWhiteSpaceNodes(overflowingContent);\n\t\t\t\n\t\t\t// we're ready to return our result!\n\t\t\treturn overflowingContent;\n\t\t\t\n\t\t},\n\t\t\t\n\t\tenablePolyfill: function enablePolyfill() {\n\t\t\t\n\t\t\t//\n\t\t\t// [0] insert necessary css\n\t\t\t//\n\t\t\tvar s = document.createElement('style');\n\t\t\ts.setAttribute(\"data-css-no-polyfill\", true);\n\t\t\ts.textContent = CSS_STYLE;\n\t\t\tvar head = document.head || document.getElementsByTagName('head')[0];\n\t\t\thead.appendChild(s);\n\t\t\t\n\t\t\t// \n\t\t\t// [1] when any update happens:\n\t\t\t// construct new content and region flow pairs\n\t\t\t// restart the region layout algorithm for the modified pairs\n\t\t\t// \n\t\t\tcssCascade.startMonitoringProperties(\n\t\t\t\t[\"flow-into\",\"flow-from\",\"region-fragment\"], \n\t\t\t\t{\n\t\t\t\t\tonupdate: function onupdate(element, rule) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// let's just ignore fragments\n\t\t\t\t\t\tif(element.getAttributeNode('data-css-regions-fragment-of')) return;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// log some message in the console for debug\n\t\t\t\t\t\tcssConsole.dir({message:\"onupdate\",element:element,selector:rule.selector.toCSSString(),rule:rule});\n\t\t\t\t\t\tvar temp = null;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// compute the value of region properties\n\t\t\t\t\t\t//\n\t\t\t\t\t\tvar flowInto = (\n\t\t\t\t\t\t\tcssCascade.getSpecifiedStyle(element, \"flow-into\")\n\t\t\t\t\t\t\t.filter(function(t) { return t instanceof cssSyntax.IdentifierToken })\n\t\t\t\t\t\t);\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar flowIntoName = flowInto[0] ? flowInto[0].toCSSString().toLowerCase() : \"\";\n\t\t\t\t\t\tif(flowIntoName==\"none\"||flowIntoName==\"initial\"||flowIntoName==\"inherit\"||flowIntoName==\"default\") {flowIntoName=\"\"}\n\t\t\t\t\t\tvar flowIntoType = flowInto[1] ? flowInto[1].toCSSString().toLowerCase() : \"\"; \n\t\t\t\t\t\tif(flowIntoType!=\"content\") {flowIntoType=\"element\"}\n\t\t\t\t\t\tvar flowInto = flowIntoName ? flowIntoName + \" \" + flowIntoType : \"\";\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar flowFrom = (\n\t\t\t\t\t\t\tcssCascade.getSpecifiedStyle(element, \"flow-from\")\n\t\t\t\t\t\t\t.filter(function(t) { return t instanceof cssSyntax.IdentifierToken })\n\t\t\t\t\t\t);\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar flowFromName = flowFrom[0] ? flowFrom[0].toCSSString().toLowerCase() : \"\"; \n\t\t\t\t\t\tif(flowFromName==\"none\"||flowFromName==\"initial\"||flowFromName==\"inherit\"||flowFromName==\"default\") {flowFromName=\"\"}\n\t\t\t\t\t\tvar flowFrom = flowFromName;\n\t\t\t\t\t\t\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// if the value of any property did change...\n\t\t\t\t\t\t//\n\t\t\t\t\t\tif(element.cssRegionsLastFlowInto != flowInto || element.cssRegionsLastFlowFrom != flowFrom) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// remove the element from previous regions\n\t\t\t\t\t\t\tvar regionOverset = element.regionOverset;\n\t\t\t\t\t\t\tvar lastFlowFrom = (cssRegions.flows[element.cssRegionsLastFlowFromName]);\n\t\t\t\t\t\t\tvar lastFlowInto = (cssRegions.flows[element.cssRegionsLastFlowIntoName]);\n\t\t\t\t\t\t\tlastFlowFrom && lastFlowFrom.removeFromRegions(element);\n\t\t\t\t\t\t\tlastFlowInto && lastFlowInto.removeFromContent(element);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// relayout those regions \n\t\t\t\t\t\t\t// (it's async so it will wait for us\n\t\t\t\t\t\t\t// to add the element back if needed)\n\t\t\t\t\t\t\tlastFlowFrom && regionOverset!='empty' && lastFlowFrom.relayout();\n\t\t\t\t\t\t\tlastFlowInto && lastFlowInto.relayout();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// save some property values for later\n\t\t\t\t\t\t\telement.cssRegionsLastFlowInto = flowInto;\n\t\t\t\t\t\t\telement.cssRegionsLastFlowFrom = flowFrom;\n\t\t\t\t\t\t\telement.cssRegionsLastFlowIntoName = flowIntoName;\n\t\t\t\t\t\t\telement.cssRegionsLastFlowFromName = flowFromName;\n\t\t\t\t\t\t\telement.cssRegionsLastFlowIntoType = flowIntoType;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// add the element to new regions\n\t\t\t\t\t\t\t// and relayout those regions, if deemed necessary\n\t\t\t\t\t\t\tif(flowFromName) {\n\t\t\t\t\t\t\t\tvar lastFlowFrom = (cssRegions.flows[flowFromName] = cssRegions.flows[flowFromName] || new cssRegions.Flow(flowFromName));\n\t\t\t\t\t\t\t\tlastFlowFrom && lastFlowFrom.addToRegions(element);\n\t\t\t\t\t\t\t\tlastFlowFrom && lastFlowFrom.relayout();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(flowIntoName) {\n\t\t\t\t\t\t\t\tvar lastFlowInto = (cssRegions.flows[flowIntoName] = cssRegions.flows[flowIntoName] || new cssRegions.Flow(flowIntoName));\n\t\t\t\t\t\t\t\tlastFlowInto && lastFlowInto.addToContent(element);\n\t\t\t\t\t\t\t\tlastFlowInto && lastFlowInto.relayout();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t\tcssCascade.startMonitoringProperties(\n\t\t\t\t[\"break-before\",\"break-after\"], \n\t\t\t\t{onupdate:function(element){\n\t\t\t\t\t\n\t\t\t\t\t// avoid fragments triggering update loops\n\t\t\t\t\tif(element.getAttribute('data-css-regions-fragment-of')){return;}\n\t\t\t\t\t\n\t\t\t\t\t// update parent regions\n\t\t\t\t\twhile(element) {\n\t\t\t\t\t\tif(element.cssRegionsLastFlowIntoName) {\n\t\t\t\t\t\t\tcssRegions.flows[element.cssRegionsLastFlowIntoName].relayout();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telement=element.parentNode;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}}\n\t\t\t);\n\t\t\t\n\t\t\t\n\t\t\t//\n\t\t\t// [2] perform the OM exports\n\t\t\t//\n\t\t\tcssRegions.enablePolyfillObjectModel();\n\t\t\t\n\t\t\t//\n\t\t\t// [3] make sure to update the region layout when all images loaded\n\t\t\t//\n\t\t\twindow.addEventListener(\"load\", \n\t\t\t\tfunction() { \n\t\t\t\t\tvar flows = document.getNamedFlows();\n\t\t\t\t\tfor(var i=0; i<flows.length; i++) {\n\t\t\t\t\t\tflows[i].relayout();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t\t\n\t\t\t// \n\t\t\t// [4] make sure we react to window resizes\n\t\t\t//\n\t\t\t//\n\t\t\tvar lastWindowResize = 0;\n\t\t\tvar relayoutModifiedFlows = function() {\n\t\t\t\t\n\t\t\t\t// specify the function did run\n\t\t\t\trelayoutModifiedFlows.timeout = 0;\n\t\t\t\t\n\t\t\t\t// rerun the layout\n\t\t\t\tvar flows = document.getNamedFlows();\n\t\t\t\tfor(var i=0; i<flows.length; i++) {\n\t\t\t\t\tif(flows[i].lastRelayout > lastWindowResize) continue;\n\t\t\t\t\tif(flows[i].relayoutInProgress) {\n\t\t\t\t\t\tflows[i].relayout();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflows[i].relayoutIfSizeChanged();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tvar hasOngoingLayouts = function() {\n\t\t\t\t\n\t\t\t\tvar flows = document.getNamedFlows();\n\t\t\t\tfor(var i=0; i<flows.length; i++) {\n\t\t\t\t\tif(flows[i].lastRelayout > lastWindowResize) continue;\n\t\t\t\t\tif(flows[i].relayoutInProgress) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn false;\n\t\t\t\t\n\t\t\t}\n\t\t\tvar restartOngoingLayouts = function() {\n\t\t\t\t\n\t\t\t\tvar flows = document.getNamedFlows();\n\t\t\t\tfor(var i=0; i<flows.length; i++) {\n\t\t\t\t\tif(flows[i].lastRelayout > lastWindowResize) continue;\n\t\t\t\t\tif(flows[i].relayoutInProgress) {\n\t\t\t\t\t\tflows[i].relayout();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\twindow.addEventListener(\"resize\",\n\t\t\t\tfunction() {\n\t\t\t\t\t\n\t\t\t\t\t// update the last layout flag\n\t\t\t\t\tlastWindowResize = +new Date();\n\t\t\t\t\t\n\t\t\t\t\t// if we aren't planning a resfresh already\n\t\t\t\t\tif(!relayoutModifiedFlows.timeout) { \n\t\t\t\t\t\t\n\t\t\t\t\t\t// if we are already busy\n\t\t\t\t\t\tif(hasOngoingLayouts()) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// restart all layouts now\n\t\t\t\t\t\t\tsetTimeout(restartOngoingLayouts, 16);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// wait half a second before restarting them from now\n\t\t\t\t\t\t\trelayoutModifiedFlows.timeout = setTimeout(relayoutModifiedFlows, 500);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// debounce by running the resize code every 200ms\n\t\t\t\t\t\t\trelayoutModifiedFlows.timeout = setTimeout(relayoutModifiedFlows, 200);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t);\n\t\t\t\n\t\t},\n\t\t\n\t\t// this dictionary is supposed to contains all the currently existing flows\n\t\tflows: Object.create ? Object.create(null) : {}\n\t\t\n\t};\n\t\n\tenableObjectModel(window, document, cssRegions);\n\t\n\treturn cssRegions;\n})(window, document);\n\nrequire.define('src/css-regions/polyfill.js');","//require('core:polyfill-dom-matchMedia');\n//require('core:polyfill-dom-classList');\n//require('css-grid:polyfill');\nrequire('src/css-regions/polyfill.js');\nrequire.define('src/requirements.js');"]}